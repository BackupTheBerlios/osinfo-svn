#!/bin/bash
################################################################################
# List System information                                                      #
################################################################################
# Written by Arvid Norlander                                                   #
# 	   + Mikael Lammentausta                                                   #
# Some documentation are in Swedish                                            #
# Some parts are taken from:                                                   #
#   --Advanced Bash Scripting Guide (ABS)                                      #
################################################################################
      appname='osinfo'
major_version=0
minor_version=0
micro_version=4
patch_version=0
   dev_status=dev

# TODO: Import xml/kdialog/normal output libs here!
. bash.functions
. osinfo.modules
. xml.functions
#. bash_Debug_functions.sh
DEBUG=on
# TODO: Use a parameter
XMLFILE="osinfo.xml"

isverbose=0
usekdialog=0
# The root dir.
# To put this in a variable allows info on non-running systems
   prefix="/"


######## SETTING USERSPACE VARIABLES 
# PATH here allows normal users to run ifconfig and lsmod
export PATH=$PATH:/bin/:/sbin/:/usr/bin/:/usr/sbin/
# LC_ALL makes is possible to print to stdout, due to support for '¡' :)
[[ ! "$LC_ALL" ]] && export LC_ALL="en_GB"


#####
##### THIS BIT IS DEPRECATED
#####  Do not use any more
#####  For details ask in #osinfo on freenode.net
#####
# Information gathering
     Stty="$(type -p stty)"
    Uname="$(type -p uname)"
    Lspci="$(type -p lspci)"
 Ifconfig="$(type -p ifconfig)"
    Lsmod="$(type -p lsmod)"
     Last="$(type -p last)"
    Fdisk="$(type -p fdisk)"
   Uptime="$(type -p uptime)"
   Lpstat="$(type -p lpstat)"


# Processing
     Awk="$(type -p awk)"
     Sed="$(type -p sed)"
    Grep="$(type -p grep)" # remove
    Head="$(type -p head)" # remove
   Fgrep="$(type -p fgrep)"
      Tr="$(type -p tr)"

# Output
  Column="$(type -p column)"
 Kdialog="$(type -p kdialog)"

####
#### END OF DEPRECATED
#### 


function PRINT_Help {
	print_line
	gettext -s "${header}${appname} "$"displays information about the system""${tSTD}"
	echo 
	gettext -s -e $"Arguments are names of modules to get info from:"
	echo
	for MODULE in ${MODULES}; do
		echo -e "\t\t$MODULE"
	done
	echo
	gettext -s $"If arguments is \"all\" then list information from all modules."
	echo
	gettext -s "${tBOLD}"$"Syntax:""${tSTD}"
	echo "  $(basename $0) "$"[Options] arguments"
	echo "  $(basename $0) "$"[--usage|--help]"
	gettext -s "${tBOLD}"$"Options:""${tSTD}"
	gettext -s "      --xml               "$"Printout in xml format to osinfo.xml"
	gettext -s "  -v, --verbose           "$"Show more information"
	gettext -s "      --kdialog           "$"Show the information using KDialog"
	gettext -s "                            "$"from KDE. Experimental feature!"
	gettext -s "                            "$"Not usable yet!"
	gettext -s "  -P, --prefix [dir]      "$"Use this dir as root"
	gettext -s "                            "$"This disables some modules."
	gettext -s "  -V, --version           "$"Shows the version of ${tBOLD}${appname}${tSTD}"
	gettext -s "                            "$"and exits."
	echo
	print_line
	if [ "$1" ]; then
		exit $1
	else
		exit 0
	fi
}

if [ "$#" -gt 0 ]; then # there are arguments to the command
	while [ "$#" -gt 0 ]; do
		case "$1" in
			'--help'|'-help'|'--usage'|'-usage'|'-h'|'')
				PRINT_Help
				;;
			'-P'|'--prefix')
				if [ $2 ]; then
					prefix="$(echo $2 | $Sed 's/\/*$/\//')"
					shift 2
				else
					missing_arg "$1"
				fi
				;;
			'--kdialog')
				usekdialog=1
				shift 1
				;;
			'--xml')
				usexml=1
				shift 1
				;;
			'-v','--verbose')
				isverbose=1
				shift 1
				;;
			'--version')
				echo "${tBOLD}${appname}${tSTD}-${major_version}.${minor_version}.${micro_version}-${patch_version} ${dev_status}";
				echo "Copyright (C) 2005-2006 Arvid Norlander";
				echo "This is free software; see the source for copying conditions.  There is ${tBOLD}NO"
				echo "warranty${tSTD}; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
				echo
				exit 0;
				;;
			*)
				cmdsnames="$cmdsnames $1"
				shift 1;
				;;
		esac
	done
else
	PRINT_Help
fi


############################################
# IF OUTPUTTING TO XMLFILE, PRINT HEADER
if [ "$usexml" == 1 ]; then
	xml_doc_start "osinfo" "SYSTEM" "osinfo.dtd"
	echo "<osinfo>" #> $XMLFILE
fi
############################################



name_value_pair_list=""
k_title=""


################################################################################
# Adds a identifier and a value to "$name_value_pair_list".
# Parameters:
#   1 string   Name
#   2 string   Value
# WARNING: Do NOT indent! Uses a TWO line string!

function add_name_value_pair {
	[ "$usekdialog" == "1" ] && let "linecount = $linecount + 1"

name_value_pair_list="${name_value_pair_list}$(echo $1¡¡¡$2)\n"

#$(echo "$1" | $Tr ' ' '_')Å$(echo "$2" | $Tr ' ' '_')"
	# Uses "Å" (AltGr+L) because it is uncommon
	#TODO: sed don't work with non Latin space replacement. Why?
}
################################################################################



################################################################################
# Prints "$name_value_pair_list" then empties the "$name_value_pair_list"
# Uses colours
# Uses the "column" tool
function flush_name_value_pair {
	if [ "$usekdialog" -eq 1 ]; then # this is completely unmaintained. doesn't work
		TMPFILE="${TMPDIR:-/tmp}/${appname}.1.$$"
		echo  "$name_value_pair_list" | \
			$Tr 'Å' '\t' | \
			$Tr '¡' ' ' > $TMPFILE
		$Kdialog --textbox "$TMPFILE" 600 "$linecount" --title "$k_title"
		rm $TMPFILE
	elif [ "$usexml" == 1 ]; then

		##############################################
		# this outputs XML
		# Operation method: breaks value pair list into components, runs a for loop
		# and parses the items into xml. needs a variable to aid the process.
		# Could be better. :)

		unset openTag;
		for value in $(
			echo  -e "$name_value_pair_list" | \
			tr -s '¡' '\n' | \
			tr -s ' ' '¡'
		# TODO: is it possible to run a for loop with the whitescapes, each line only
		# constituting a new item in the loop, (not using whitescape, rather \n as the mark)?
		); do

			if [ ! "${openTag}" ]; then
				echo -e "\t\t$(xml_tag_start "${value}")" | tr '¡' ' '		#>> $XMLFILE		# open tag
				openTag=${value}
			else 
				echo -e "\t\t\t${value}"  | tr '¡' ' '				#>> $XMLFILE		# write content
				echo -e "\t\t$(xml_tag_stop "${openTag}")"  | tr '¡' ' '	#>> $XMLFILE		# close tag
				unset openTag;
			fi

		done
		##############################################

	else
		echo -e "$name_value_pair_list" | \
			$Column -ts '¡' | \
			$Sed "s/^\([-_.A-Za-z0-9()]*\)/${tBOLD}\1${tSTD}/" | \
			$Tr '¡' '\t'
	fi
	name_value_pair_list=""
	linecount=0
}
################################################################################


function wrong_module() {
	do_abort $"${1} are not a valid module!" 1
}


################################################################################
# Print module header
# Parameters:
#   1 string   Module name
print_module_header() {
	if [ "$usekdialog" == "1" ]; then
		k_title="$1"
	elif [ "$usexml" == 1 ]; then
		echo -e "\t$(xml_tag_start "${1}")"
	else
		print_line
		echo "${tcRED}${tUNDERLINE}"$"Report from module""${tSTD}${tUNDERLINE} ${tcBLUE}$1${tSTD}:"
	fi
}
################################################################################



################################################################################
# Print module footer (for xml)
# Parameters:
#   1 string   Module name
print_module_footer() {
	if [ "$usexml" == 1 ]; then
		echo -e "\t$(xml_tag_stop "${1}")"
	fi
}
################################################################################



for modul in $cmdsnames; do
	if [ $modul = 'all' ]; then
		cmdsnames="$MODULES"
		break;
	fi
	validate_arg "$modul" "$MODULES" || wrong_module "$modul"
done

if [ "$prefix" != '/' ] ; then
	tmp_cmdsnames="$cmdsnames"
	cmdsnames=""
	for modul in $tmp_cmdsnames; do
		realrootrequired=0
		for real_root_modul in $MODULES_REAL_ROOT_ONLY; do
			[ "$modul" == "$real_root_modul" ] && realrootrequired=1
		done
		[ $realrootrequired -eq 0 ] && cmdsnames="$cmdsnames $modul"
	done
fi

for modul in $cmdsnames; do
	case $modul in
#		uname)              eval "Module_Cmd_${modul}";;
		terminal|\
			network|\
			distro|\
			devices|\
			users|\
			processor|\
			system|\
			lsmod|\
			diskinfo|\
			printers|\
			applications) Module_${modul};;
	esac
done


[ "$usekdialog" -ne 1 ]  #&& print_line


############################################
# IF OUTPUTTING TO XMLFILE, PRINT FOOTER

if [ "$usexml" == 1 ]; then
	echo "</osinfo>" #> $XMLFILE
fi
############################################
