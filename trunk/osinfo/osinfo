#!/usr/bin/env bash
#################################################################################
# OSINFO
#
# osinfo lists system information available to the OS.
# see `man osinfo` for details.
#
#################################################################################
# Written by Arvid Norlander and Mikael Lammentausta                            #
#                                                                               #
# Some parts are taken from:                                                    #
#   --Advanced Bash Scripting Guide (ABS)                                       #
#################################################################################
appname='osinfo'
major_version=0
minor_version=2
micro_version=10
patch_version=3
dev_status=alpha
release_date='2006-09-xx'

#############################################################
##
# source the necessary files

source sources

[ -e "/etc/osinfo.conf" ] && \
. /etc/osinfo.conf                # the configuration file

#############################################################


# make a guess of the operating system
SYSTEM="$(uname -s  | tr 'A-Z' 'a-z' )"
#if [ ! "$(echo $SYSTEM | grep 'linux')" ] | [ ! "$(echo $SYSTEM | grep bsd)" ]; then
# freebsd doesn't understand '||' or evaluation, but it's not required
# NOTE: AnMaster: If you realy use bash it *should* understand ||.
#	echo "This script has not been tested on other operating systems than Linux and FreeBSD."
#	echo
#	exit 0;
#fi


function netcat() {
	if [ "$(type -p netcat)" ]; then
		netcat "$@"
	elif [ "$(type -p nc)" ]; then
		nc "$@"
	else
		info "netcat binary not found!"
		exit 1
	fi
}
# On *BSD, coreutils are prepended with 'g' to imply 'GNU'
# http://www.freebsd.org/cgi/url.cgi?ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/ports/sysutils/coreutils/pkg-descr
if [ "$(grep bsd <<< "$SYSTEM")" ]; then
	Meta_all="$MODULES_BSD"
	function seq() {
		gseq "$@"
	}
	function date() {
		gdate "$@"
	}
fi

######## SETTING USERSPACE VARIABLES
isverbose=0
isdebug=0
usekdialog=0
lanforce=0
usexml=0
makehtml=0
fake=0
dev_code=0
quiet=0
tcpdaemon=0
tcpsend=0

prefix="/"  # The root dir. Using a variable allows info on chrooted systems
PROFILES="desktop server laptop"
profile="desktop"    # default profile is desktop
#OUTPUT_MODES="stdout xml kdialog"  # this list is not used (yet)
output_mode="stdout" # default output mode is stdout


#XMLFILE="$(get_hostname)_$(get_mac_address).xml"
XMLFILE="$(get_hostname).xml"
XSLDEBUGFILE="osinfo.xsl"
XSLFILE="$(get_hostname).xsl"
rm "$XSLFILE" -f
HTMLFILE="$(get_hostname).html"
rel_hostdir='./hosts'


# if the conf file is not available..
[ ! "$error_log" ] && error_log="/var/log/osinfo.log"
[ ! "$rundir" ] && rundir="/var/run/osinfo"


# Before we break path hash some binaries so the script can find them (if they exist).
hash kdialog &>/dev/null
# PATH here allows normal users to run ifconfig and lsmod
export PATH=$PATH:/bin/:/sbin/:/usr/bin/:/usr/sbin/
# LC_ALL makes is possible to print to stdout, due to support for '' :)
#[[ ! "$LC_ALL" ]] && export LC_ALL="en_GB"







################################################################################
# Module functions
# ------------------------------------------------------------------------------
wrong_module() {
	do_abort "${1} is not a valid module!" 1
}



#######################
# THE MAIN FUNCTION
# this runs all checks and generates the print-out
#
# this is the place to put all env variables to be set for some module
run_modules() {
	for modul in $cmdsnames; do

		# TODO: check that the module being called is supported on the running OS

		# TODO: something like this to not even attempt to run REQ_ROOT modules
		#       as normal user, but shouldn't burden the script too much
		#       with excessive loops
		#allowed_modules=''
		#if ! CheckReq_root; then
		#	allowed_modules=$MODULES_ALL-$MODULES_SU_ONLY
		#fi

		if [ $modul = 'all' ]; then
			if [ "$SYSTEM" == "linux" ] ; then
				#cmdsnames="$MODULES_LINUX"
				break
			# TODO: please check if this works on bsd and old bash
			elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then
				#cmdsnames="$MODULES_BSD"
				break
			fi
		elif [ $modul = 'lanforce' ]; then
			lanforce=1
			usexml=1
			#cmdsnames="$MODULES_LANFORCE"
			break
		fi

		validate_arg "$modul" "$MODULES_ALL $MODULES_META" || wrong_module "$modul"
		# validate_arg is called to check that the module exits at all.
		# AnMaster: If we DON'T validate user input *and* use eval below we
		#           are *realy* stupid. So don't comment that out.
		#           Instead update the variable MODULES_ALL in osinfo.modules
		#           We MUST validate the user input if we are going to use eval
		#           otherwise someone could use that to run something evil
		#           (as root), like rm -rf /.

	done

	if [ "$prefix" != '/' ] ; then
		tmp_cmdsnames="$cmdsnames"
		cmdsnames=""
		for modul in $tmp_cmdsnames; do
			realrootrequired=0
			for real_root_modul in $MODULES_REAL_ROOT_ONLY; do
				[ "$modul" == "$real_root_modul" ] && realrootrequired=1
			done
			[ $realrootrequired -eq 0 ] && cmdsnames="$cmdsnames $modul"
		done
	fi

	if [ "$usexml" == 1 ]; then
		print_xml_header > "${XMLFILE}"
	fi

	if [ -z "$cmdsnames" ]; then
		PRINT_Help
	fi

	# this calls the module definitions. as there are Meta-modules
	# and the actual modules, we first check if there's a Meta-module
	# of that name. in that case, it is used.
	# NOTE: FreeBSD runs all modules
	for module in $cmdsnames; do

		# AnMaster: What the hell are you doing... why not use a case .. esac statment like we did before?
		#           that would solve it.
		# ruxpin: that would require a modification to this list after adding a module,
		#         which I want to avoid.
		# AnMaster: local modulename="Meta_${module}"
		#           metamod="${!modulename}"
		#           Needs bash 3 at least.
		#           Or base it on some declare magic.
		eval metamod="\${Meta_${module}}"

		if [ "$(echo $metamod)" ]; then

			for submodule in $metamod; do

				Module_${submodule}

			done

		else

			Module_${module}

		fi

	done

	#[ "$usekdialog" -ne 1 ]  #&& print_line

	if [ "$usexml" == 1 ]; then
		print_xml_footer >> "${XMLFILE}"
	elif [ "$usekdialog" -ne 1 ]; then
		print_line
	fi

	# Remove temporary files:
	cleanup_temp_files
}


# parse the command line arguments
parse_arguments "${@}"

# do some checks..
Check_logfile
#Check_rundir

# if we're not running in tcp daemon mode, call the main function
if [ $tcpdaemon -eq 0 ]; then
	run_modules
else
	listen_tcp
fi

# generate html
if [ $makehtml -eq 1 ]; then
	xsltproc "${XSLDEBUGFILE}" "${XMLFILE}" > "${HTMLFILE}"
fi

############################################
# FINALLY SEND OVER TCP IF THE OPTION IS SET
if [ $tcpsend -eq 1 ]; then
	cat "${XMLFILE}" | netcat "$HOST" "$PORT" -q 1
elif [ $usexml -eq 1 ] && [ $quiet -ne 1 ]; then
	cat "${XMLFILE}"
fi
############################################

# exit cleanly
exit 0
