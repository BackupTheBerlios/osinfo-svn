#!/bin/bash
#!/usr/local/bin/bash
################################################################################
# List System information                                                      #
################################################################################
# Written by Arvid Norlander                                                   #
# 	   + Mikael Lammentausta                                                   #
# Some documentation are in Swedish                                            #
# Some parts are taken from:                                                   #
#   --Advanced Bash Scripting Guide (ABS)                                      #
################################################################################
appname='osinfo'
major_version=0
minor_version=1
micro_version=2
patch_version=2
dev_status=dev

# TODO: Import xml/kdialog/normal output libs here!
source bash.functions
source osinfo.modules
source xml.functions
#. bash_Debug_functions.sh
DEBUG=on
# TODO: Use a parameter
XMLFILE="osinfo.xml"

SYSTEM="$(uname -s  | sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/')"
if [ ! "$(echo $SYSTEM | grep 'linux')" ] | [ ! "$(echo $SYSTEM | grep bsd)" ]; then
# freebsd doesn't understand '||' or evaluation, but it's not required
	gettext $"This script has not been tested on other operating systems than Linux and FreeBSD."
	echo
#	exit 0;
fi

#On BSD, coreutils are prebended with 'g' *sigh*
#http://www.freebsd.org/cgi/url.cgi?ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/ports/sysutils/coreutils/pkg-descr

if [ "$(echo $SYSTEM | grep bsd)" ]; then
	Seq="$(type -p gseq)"
	function seq() {
		$Seq "$@"
	}
fi




isverbose=0
usekdialog=0
# The root dir.
# To put this in a variable allows info on non-running systems
   prefix="/"


######## SETTING USERSPACE VARIABLES 
# PATH here allows normal users to run ifconfig and lsmod
export PATH=$PATH:/bin/:/sbin/:/usr/bin/:/usr/sbin/
# LC_ALL makes is possible to print to stdout, due to support for '¡' :)
[[ ! "$LC_ALL" ]] && export LC_ALL="en_GB"


function PRINT_Help {
	print_line
	gettext -s "${header}${appname} "$"displays information about the system""${tSTD}"
	echo 
	gettext -s -e $"Arguments are names of modules to get info from:"
	echo
        if [ "$SYSTEM" == "linux" ] ; then

			for MODULE in ${MODULES_LINUX}; do
				echo -e "\t\t$MODULE"
			done

        elif [ "$(echo $SYSTEM | grep bsd)" ]; then

			for MODULE in ${MODULES_BSD}; do
				echo -e "\t\t$MODULE"
			done

        fi
	echo
	gettext -s $"If arguments is \"all\" then list information from all modules."
	echo
	gettext -s "${tBOLD}"$"Syntax:""${tSTD}"
	echo "  $(basename $0) "$"[Options] arguments"
	echo "  $(basename $0) "$"[--usage|--help]"
	gettext -s "${tBOLD}"$"Options:""${tSTD}"
	gettext -s "      --xml               "$"Printout in xml format to osinfo.xml"
	gettext -s "  -v, --verbose           "$"Show more information"
	gettext -s "      --kdialog           "$"Show the information using KDialog"
	gettext -s "                            "$"from KDE. Experimental feature!"
	gettext -s "                            "$"Not usable yet!"
	gettext -s "  -P, --prefix [dir]      "$"Use this dir as root"
	gettext -s "                            "$"This disables some modules."
	gettext -s "  -V, --version           "$"Shows the version of ${tBOLD}${appname}${tSTD}"
	gettext -s "                            "$"and exits."
	echo
	print_line
	if [ "$1" ]; then
		exit $1
	else
		exit 0
	fi
}

if [ "$#" -gt 0 ]; then # there are arguments to the command
	while [ "$#" -gt 0 ]; do
		case "$1" in
			'--help'|'-help'|'--usage'|'-usage'|'-h'|'')
				PRINT_Help
				;;
			'-P'|'--prefix')
				if [ $2 ]; then
					prefix="$(echo $2 | sed 's/\/*$/\//')"
					shift 2
				else
					missing_arg "$1"
				fi
				;;
			'--kdialog')
				usekdialog=1
				shift 1
				;;
			'--xml')
				usexml=1
				shift 1
				;;
			'-v'|'--verbose')
				isverbose=1
				shift 1
				;;
			'--version')
				echo "${tBOLD}${appname}${tSTD}-${major_version}.${minor_version}.${micro_version}-${patch_version} ${dev_status}";
				echo "Copyright (C) 2005-2006 Arvid Norlander";
				echo "This is free software; see the source for copying conditions.  There is ${tBOLD}NO"
				echo "warranty${tSTD}; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
				echo
				exit 0;
				;;
			*)
				cmdsnames="$cmdsnames $1"
				shift 1;
				;;
		esac
	done
else
	PRINT_Help
fi


############################################
# IF OUTPUTTING TO XMLFILE, PRINT HEADER
if [ "$usexml" == 1 ]; then
	xml_doc_start "osinfo" "SYSTEM" "osinfo.dtd" #> $XMLFILE
	echo "<osinfo>" #> $XMLFILE
	XML_INDENT=1
fi
############################################



name_value_pair_list=""
k_title=""


################################################################################
# Adds a identifier and a value to "$name_value_pair_list".
# Parameters:
#   1 string   Name
#   2 string   Value
#
# WARNING: Do NOT indent! Uses a TWO line string!

function add_name_value_pair {
	name_value_pair_list="${name_value_pair_list}$(echo $1¡$2)\n"
	# uses a funny character '¡' that later will be parsed.
	# not very sophisticated. :/


	[ "$usekdialog" == "1" ] && let "linecount = $linecount + 1"

	# kdialog is unmaintained, but left here for future revisions.

	#$(echo "$1" | tr ' ' '_')Å$(echo "$2" | tr ' ' '_')"
	# Uses "Å" (AltGr+L) because it is uncommon
	#TODO: sed don't work with non Latin space replacement. Why?
}
################################################################################



### experimental, CAN BE DEBUGGED WITH MODULE SYSTEM
function add_values {

	# the header and values are written to values[] array 
	# the headers array consists of an item x = number of values

	# check existing values array
	FIRST_BLANK_VALUE=${#values[@]}

	# check the number of input values, modules may output blank, and that is concidered
	# a string, so this little eval thing compares the strings one by one
	AMT_VALUES=0
	for i in `seq 1 $#`; do
		if [ "$(eval "echo \$$i")" != "" ]; then
			((AMT_VALUES++))
		fi
	done

	# add an item to the headers array
	headers[${#headers[@]}]="$AMT_VALUES"

	# this will put the arguments into the values array
	IFS_bak=$IFS ; 	IFS="
" # a literal newline
	for VALUE in $@; do
		values[$FIRST_BLANK_VALUE]=$VALUE
		((FIRST_BLANK_VALUE++))
	done
	IFS=$IFS_bak


# this is for debugging
#	for HDR in $(seq 1 ${#headers[@]}); do
#		echo ${headers[$HDR]}
#	done

#	for VL in $(seq 1 ${#values[@]}); do
#		echo ${values[$VL]}
#	done

#	echo ${#headers[@]}
#	echo ${#values[@]}

}

function flush_values {

	INDEX=0

	VAL_STRING=""

	for ITEMS in ${headers[@]}; do

#		if [ "$ITEMS" -gt 0 ]; then

			for VALUE in `seq 1 $ITEMS`; do
				VAL_STRING=$VAL_STRING${values[$INDEX]}"\t\t";
				# this evaluation appends an additional tab space if it's required
				[[ "${#values[$INDEX]}" -le 6 ]] && VAL_STRING=$VAL_STRING"\t"

				((INDEX++))
			done
		VAL_STRING=$VAL_STRING"\n";

#		fi
	done

	echo -e "${VAL_STRING}" | \
		sed "s/^\([-_.A-Za-z0-9()]*\)/${tBOLD}\1${tSTD}/" 

	unset headers
	unset values

}


################################################################################
# Prints "$name_value_pair_list" then empties the "$name_value_pair_list"
# Uses colours
# Uses the "column" tool
function flush_name_value_pair {
	if [ "$usexml" == 1 ]; then
		
		##############################################
		# this outputs XML
		# Operation method: breaks value pair list into components, runs a for loop
		# and parses the items into xml. needs a variable to aid the process.
		# Could be better. :)
		
		
		#### OUTER OPENING TAG
		if [ "$value_pair_header" ]; then 
			for indent in $(seq 0 $XML_INDENT); do 
				echo -ne "\t" #>> $XMLFILE 
			done
			((XML_INDENT++))
			echo -e "$(xml_tag_start "${value_pair_header}")" 	#>> $XMLFILE		# open tag
			unset value_pair_header
		fi
		
		unset openTag
		#			tr -s '¡' '\n' | \
		for value in $(
			echo  -e "$name_value_pair_list" | \
				tr -s ' ' '¿'
			# TODO: is it possible to run a for loop with the whitescapes, each line only
			# constituting a new item in the loop, (not using whitescape, rather \n as the mark)?
		); do
		 
		 #echo ${value}
		 value1="$(echo ${value} | awk -F¡ {'print $1'})"
		 value2="$(echo ${value} | awk -F¡ {'print $2'})"
		 
		 
		 if [ ! "${openTag}" ]; then
			 #echo "new tag"
			 #echo $value1
			 for indent in `seq 0 $XML_INDENT`; do echo -ne "\t" #>> $XMLFILE 
			 done
			 ((XML_INDENT++))
			 echo -e "$(xml_tag_start "${value1}")" | tr '¿' ' '		#>> $XMLFILE		# open tag
			 openTag=${value1}
			 
			 if [  "${value2}" ]; then 
				 for indent in `seq 0 $XML_INDENT`; do echo -ne "\t" #>> $XMLFILE 
				 done
				 #echo "write data"
				 #echo $value2
				 
				 echo -e "${value2}"  | tr '¿' ' '				#>> $XMLFILE		# write content
			 fi
			 
			 #echo "close tag"
			 #echo $value1
			 ((XML_INDENT--))
			 for indent in `seq 0 $XML_INDENT`; do echo -ne "\t" #>> $XMLFILE 
			 done
			 echo -e "$(xml_tag_stop "${openTag}")"  | tr '¿' ' '	#>> $XMLFILE		# close tag
			 unset openTag;
		 fi
		 
		 
		 #### OUTER CLOSING TAG 
		 if [ "$value_pair_footer" ]; then 
			 for indent in `seq 0 $XML_INDENT`; do echo -ne "\t" #>> $XMLFILE 
			 done
			 ((XML_INDENT--))
			 echo -e "$(xml_tag_stop "${value_pair_footer}")" 	#>> $XMLFILE		# close
			 unset value_pair_footer
		 fi
		 
		done
		##############################################
		
	elif [ "$usekdialog" -eq 1 ]; then 
		
		##############################################
		# this outputs to KDIALOG
		# this is completely unmaintained. doesn't work
		
		TMPFILE="${TMPDIR:-/tmp}/${appname}.1.$$"
		echo -e "\n$value_pair_header"
		echo  "$name_value_pair_list" | \
			tr '¡' '\t' | \
			tr '' ' ' > $TMPFILE
		kdialog --textbox "$TMPFILE" 600 "$linecount" --title "$k_title"
		rm $TMPFILE
		
	else
		
		# FIXME: This bit doesn't work at all on Gentoo 2006.0 64-bit
		#set -x
		###############################################
		# output to STDOUT
		
		[[ "$value_pair_header" ]] && echo -e "\n$value_pair_header"
		echo -e "$name_value_pair_list" | \
			column -ts '¡' | \
			sed "s/^\([-_.A-Za-z0-9()]*\)/${tBOLD}\1${tSTD}/" | \
			tr '¡' '\t'
		#set +x
	fi
	
	unset name_value_pair_list
	unset value_pair_header
	linecount=0
}
################################################################################


function wrong_module() {
	do_abort $"${1} is not a valid module!" 1
}


################################################################################
# Print module header
# Parameters:
#   1 string   Module name
print_module_header() {
	if [ "$usekdialog" == "1" ]; then
		k_title="$1"
	elif [ "$usexml" == 1 ]; then
		echo -e "\t$(xml_tag_start "${1}")"
	else
		print_line
		echo "${tcRED}${tUNDERLINE}"$"Report from module""${tSTD}${tUNDERLINE} ${tcBLUE}$1${tSTD}:"
	fi
}
################################################################################



################################################################################
# Print module footer (for xml)
# Parameters:
#   1 string   Module name
print_module_footer() {
	if [ "$usexml" == 1 ]; then
		echo -e "\t$(xml_tag_stop "${1}")"
	fi
}
################################################################################



for modul in $cmdsnames; do
	
	if [ $modul = 'all' ]; then
		if [ "$SYSTEM" == "linux" ] ; then
			
			cmdsnames="$MODULES_LINUX"
			break;
			
		elif [ "$(echo $SYSTEM | grep bsd)" ]; then
			
			cmdsnames="$MODULES_BSD"
			break;
		fi
	fi
	# validate_arg "$modul" "$MODULES" || wrong_module "$modul"
	# why is this function called? breaking MODULES for each system breaks it...
done

if [ "$prefix" != '/' ] ; then
	tmp_cmdsnames="$cmdsnames"
	cmdsnames=""
	for modul in $tmp_cmdsnames; do
		realrootrequired=0
		for real_root_modul in $MODULES_REAL_ROOT_ONLY; do
			[ "$modul" == "$real_root_modul" ] && realrootrequired=1
		done
		[ $realrootrequired -eq 0 ] && cmdsnames="$cmdsnames $modul"
	done
fi

for modul in $cmdsnames; do
	case $modul in
		#		uname)              eval "Module_Cmd_${modul}";;
		terminal|\
			network|\
			distro|\
			devices|\
			users|\
			processor|\
			system|\
			lsmod|\
			hdd|\
			printers|\
			oem|\
			applications) Module_${modul};;
	esac
done
#		lsmod|\		# is very alpha, do not uncomment

[ "$usekdialog" -ne 1 ]  #&& print_line


############################################
# IF OUTPUTTING TO XMLFILE, PRINT FOOTER

if [ "$usexml" == 1 ]; then
	echo "</osinfo>" #> $XMLFILE
fi
############################################
