#!/bin/bash
#!/usr/local/bin/bash
################################################################################
# List System information                                                      #
################################################################################
# Written by Arvid Norlander and Mikael Lammentausta                           #
# Some parts are taken from:                                                   #
#   --Advanced Bash Scripting Guide (ABS)                                      #
################################################################################
appname='osinfo'
major_version=0
minor_version=2
micro_version=0
patch_version=1
dev_status=dev

# TODO: Import xml/kdialog/normal output libs here!
source bash.functions
source osinfo.modules
source xml.functions
source lanforce.functions
#. bash_Debug_functions.sh
DEBUG=on
# TODO: Use a parameter
XMLFILE="osinfo.xml"

SYSTEM="$(uname -s  | sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/')"
#if [ ! "$(echo $SYSTEM | grep 'linux')" ] | [ ! "$(echo $SYSTEM | grep bsd)" ]; then
# freebsd doesn't understand '||' or evaluation, but it's not required
#	gettext $"This script has not been tested on other operating systems than Linux and FreeBSD."
#	echo
#	exit 0;
#fi

#On *BSD, coreutils are prepended with 'g' to imply 'GNU'
#http://www.freebsd.org/cgi/url.cgi?ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/ports/sysutils/coreutils/pkg-descr

if [ "$(echo $SYSTEM | grep bsd)" ]; then
	Seq="$(type -p gseq)"
	function seq() {
		$Seq "$@"
	}
fi


isverbose=0
usekdialog=0
lanforce=0
usexml=0
# The root dir.
# To put this in a variable allows info on non-running systems
   prefix="/"

function PRINT_Help {
	print_line
	gettext -s "${header}${appname} "$"displays information about the system""${tSTD}"
	echo 
	gettext -s -e $"Arguments are names of modules to get info from:"
	echo
        if [ "$SYSTEM" == "linux" ] ; then

			for MODULE in ${MODULES_LINUX}; do
				echo -e "\t\t$MODULE"
			done

        elif [ "$(echo $SYSTEM | grep bsd)" ]; then

			for MODULE in ${MODULES_BSD}; do
				echo -e "\t\t$MODULE"
			done

        fi
	echo
	gettext -s $"If arguments is \"all\" then list information from all modules."
	echo
	gettext -s "${tBOLD}"$"Syntax:""${tSTD}"
	echo "  $(basename $0) "$"[Options] arguments"
	echo "  $(basename $0) "$"[--usage|--help]"
	gettext -s "${tBOLD}"$"Options:""${tSTD}"
	gettext -s "      --xml               "$"Printout in xml format to osinfo.xml"
	gettext -s "  -v, --verbose           "$"Show more information"
	gettext -s "      --kdialog           "$"Show the information using KDialog"
	gettext -s "                            "$"from KDE. Experimental feature!"
	gettext -s "                            "$"Not usable yet!"
	gettext -s "  -P, --prefix [dir]      "$"Use this dir as root"
	gettext -s "                            "$"This disables some modules."
	gettext -s "  -V, --version           "$"Shows the version of ${tBOLD}${appname}${tSTD}"
	gettext -s "                            "$"and exits."
	echo
	print_line
	if [ "$1" ]; then
		exit $1
	else
		exit 0
	fi
}


######## SETTING USERSPACE VARIABLES 
# PATH here allows normal users to run ifconfig and lsmod
export PATH=$PATH:/bin/:/sbin/:/usr/bin/:/usr/sbin/
# LC_ALL makes is possible to print to stdout, due to support for '°' :)
#[[ ! "$LC_ALL" ]] && export LC_ALL="en_GB"


if [ "$#" -gt 0 ]; then # there are arguments to the command
	while [ "$#" -gt 0 ]; do
		case "$1" in
			'--help'|'-help'|'--usage'|'-usage'|'-h'|'')
				PRINT_Help
				;;
			'-P'|'--prefix')
				if [ $2 ]; then
					prefix="$(echo $2 | sed 's/\/*$/\//')"
					shift 2
				else
					missing_arg "$1"
				fi
				;;
			'--kdialog')
				usekdialog=1
				shift 1
				;;
			'--xml')
				usexml=1
				shift 1
				;;
			# Add something about this in PRINT_Help:
			'--lanforce')
				#usexml=1
				lanforce=1
				shift 1
				;;
			# Add something about this in PRINT_Help:
			'--nc'|'--netcat')
				if [ ! "$2" ] || [ ! "$3" ]; then
					echo "You must set the target host and port!"
					exit 0;
				fi
				netcat=1
				HOST=$2
				PORT=$3
				shift 3
				;;
			'-v'|'--verbose')
				isverbose=1
				shift 1
				;;
			'--version')
				echo "${tBOLD}${appname}${tSTD}-${major_version}.${minor_version}.${micro_version}-${patch_version} ${dev_status}";
				echo "Copyright (C) 2005-2006 Arvid Norlander";
				echo "This is free software; see the source for copying conditions.  There is ${tBOLD}NO"
				echo "warranty${tSTD}; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
				echo
				exit 0;
				;;
			*)
				cmdsnames="$cmdsnames $1"
				shift 1;
				;;
		esac
	done
else
	PRINT_Help
fi



############################################
# XML HEADER & FOOTER FUNCTIONS

function print_xml_header () {
	if [ "$lanforce" == 1 ]; then

		xml_doc_start "osinfo" "SYSTEM" "lanforce.dtd" | tee $XMLFILE
		ip="$(ifconfig $interface_name | \
			grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | \
			grep -Eo '[0-9\.]+' )"
		lf_entity_start "$(hostname)" "$ip" | tee -a $XMLFILE

	else

		xml_doc_start "osinfo" "SYSTEM" "osinfo.dtd" | tee $XMLFILE
		xml_tag_start "${appname}" | tee -a $XMLFILE
		XML_INDENT=1
		
	fi
}

function print_xml_footer () {
	
	if [ "$lanforce" == 1 ]; then
		lf_entity_stop | tee -a $XMLFILE
		#lf_note
	else
		xml_tag_stop "${appname}" | tee -a $XMLFILE
	fi
}

############################################




################################################################################
# NOTE: this function is deprecated
# Adds a identifier and a value to "$name_value_pair_list".
# Parameters:
#   1 string   Name
#   2 string   Value
#
# WARNING: Do NOT indent! Uses a TWO line string!

name_value_pair_list=""
k_title=""

function add_name_value_pair {
	name_value_pair_list="${name_value_pair_list}$(echo $1°$2)\n"
	# uses a funny character '°' that later will be parsed.
	# not very sophisticated. :/


	[ "$usekdialog" == "1" ] && let "linecount = $linecount + 1"

	# kdialog is unmaintained, but left here for future revisions.

	#$(echo "$1" | tr ' ' '_')≈Å$(echo "$2" | tr ' ' '_')"
	# Uses "≈Å" (AltGr+L) because it is uncommon
	#TODO: sed don't work with non Latin space replacement. Why?
}
################################################################################



################################################################################
# value_header(), value_footer(), add_attribute(), add_values(), flush_values()
# -------------------------------------------------------------------
# these are a group of functions that are used by the modules to formulate the output.
#
# flush_values calls either print_xml, print_lanforce_xml or print_stdout
# depending on the parameters the user has set during invocations of osinfo.
#
# the other functions use the $infostring[] to store the information
# collected by the modules. the format of this array is like:
# [%header%System information] [%attribute%Operating system;os] [Linux]
# detailed information is given in each function.


function value_header() {

	# this function inserts the input string as the last available item
	# in the $infostring array. it also adds a %header% tag which will be
	# use by print_* functions to interpret how to parse the string.

	#headers[${#headers[@]}]="$1"
	#echo ${#infostring[@]} 
	infostring[${#infostring[@]}]="%header%$1"
	#echo ${infostring[0]}
}

function value_footer() {

	# this function searches the $infostring array backwards, 
	# looking for open headers. 

	# NEEDS DEBUGGING!
	
	#for HDR in $(seq ${#headers[@]} -1 0); do
	#echo ${headers[$HDR]}
	#	if [ "$(echo ${headers[$HDR]} | grep -Eo '^[A-÷a-ˆ ]+')" ]; then
			#echo $HDR
	#		headers[${#headers[@]}]="%footer%${headers[$HDR]}"
		        #value_string="/$HDR\n";
	#		break;
	#	fi
	#done
	
	found=""
	for position in $(seq ${#infostring[@]} -1 0); do
		item="$(echo ${infostring[$position]})"
		# first collect %footer%s into $found array
		if [ "$(echo ${item} | grep '^%footer%')" ]; then
			found="$(echo ${item} | \
				grep '^%footer%' | sed s/%footer%//)"

		# then continue and add a footer if it is not already found	
		elif [ "$(echo ${item} | grep '^%header%')" ]; then
			item="$(echo ${item} | sed s/%header%//)"

			if [ "${item}" != "${found}" ]; then
			#found[${#found[@]}]="$(echo ${item} | \
			#	grep '^%header%' | sed s/%header%/%footer%/)"
			# then test if this has 
			#echo $found
				infostring[${#infostring[@]}]="%footer%${item}"
				break;
			fi
		fi
	done

	#for VL in $(seq 0 ${#infostring[@]}); do
#		echo ${infostring[$VL]}
#	done

}

function add_attribute() {

	# parameters:
	#	1 free-form name	(eg. Operating system)	 (required)
	#	2 code tag for xml	(eg. os)				 (optional)

	# this function inserts the input string(s) as the last available item
	# in the $infostring array, with a field delimiter of ";". 
	# it also adds an %attribute% tag which will be use by print_* functions
	# to interpret how to parse the string.

	infostring[${#infostring[@]}]="%attribute%${1};${2}"

}

function add_values {

	# this function inserts the input string or strings into the $infostring[] array.

	#FIRST_BLANK_VALUE=${#values[@]}
	FIRST_BLANK_VALUE=${#infostring[@]}

	# check the number of input values.
	# modules may output a blank string, and because that is also considered
	# to be a string, this eval(uation) compares the strings one by one.
	#AMT_VALUES=0
	#for i in $(seq 1 1 $#); do
	#	if [ "$(eval "echo \$$i")" != "" ]; then
	#		((AMT_VALUES++))
	#	fi
	#done

	# add an item to the headers array
	#headers[${#headers[@]}]="$AMT_VALUES"


	# IFS need to be changed because the values are separated by newline
	IFS_bak="$IFS" ; 	IFS="
" # a literal newline, do not indent
	for value in $@; do
		#values[$FIRST_BLANK_VALUE]="$value"
		#infostring[$FIRST_BLANK_VALUE]="$value"
		infostring[${#infostring[@]}]="$value"
		#((FIRST_BLANK_VALUE++))
	done
	IFS="$IFS_bak"


	# THIS IS FOR DEBUGGING

	#	for HDR in $(seq 1 ${#headers[@]}); do
	#		echo ${headers[$HDR]}
	#	done

	#	for VL in $(seq 1 ${#values[@]}); do
	#		echo ${values[$VL]}
	#	done

	#	echo ${#headers[@]}
	#	echo ${#values[@]}

}


function flush_values {
	if [ "$usexml" == "0" ]; then
		print_stdout
	elif [ "$usexml" == "1" ] && [ "$lanforce" == "0" ]; then
		print_xml
	else
		print_lanforce_xml
	fi
	unset infostring
}


################################################################################
# print_xml(), print_lanforce_xml(), print_stdout()
# -------------------------------------------------------------------
# this set of functions formulates the items in $infostring for output.
# detailed information is given in each function.

function print_xml {

	# this function loops the $infostring and does the following steps
	# for each item:
	#	1 test if item does not begin with '%' => print value; next
	#	2 if there is an attribute tag open => close it
	#	3 if the item begins with %attribute% => print attribute ; next
	#	4 if the item begins with %header% => print header ; next
	#	5 if the item begins with %footer% => print footer ; next


	for itemnr in $(seq 0 $((${#infostring[@]}-1))); do
		item="${infostring[$itemnr]}"
		#echo $item
		if [ ! "$(echo ${item} | grep '^%')" ]; then

			for indent in $(seq 1 $XML_INDENT); do 
				echo -ne "\t" | tee -a "$XMLFILE" 
			done
			
			echo -e "$(xml_value "${item}")" | tee -a "$XMLFILE"

		else
		
			### CLOSE ATTRIBUTE TAG
			if [ "$attribute" == "open" ]; then
				((XML_INDENT--))
				for indent in $(seq 1 $XML_INDENT); do
					echo -ne "\t" | tee -a "$XMLFILE" 
				done				
				echo -e "$(xml_attribute_stop)" | tee -a "$XMLFILE"
				echo | tee -a "$XMLFILE"
				attribute="closed"
			fi

			### NEW ATTRIBUTE TAG
			if [ "$(echo ${item} | grep '^%attribute%')" ]; then
				for indent in $(seq 1 $XML_INDENT); do
					echo -ne "\t" | tee -a "$XMLFILE"
				done
				item="$(echo ${item} | sed s/%attribute%//)"
				name=$(echo ${item} | awk -F\; {'print $1'})
				code=$(echo ${item} | awk -F\; {'print $2'})
				xml_attribute_start "${name}" "${code}"
#				echo -e "$(xml_attribute_start "${name}" "${code}")" | tee -a $XMLFILE
				((XML_INDENT++))
				attribute="open"


			#### HEADER TAG
			elif [ "$(echo ${item} | grep '^%header%')" ]; then 
				for indent in $(seq 1 $XML_INDENT); do 
					echo -ne "\t" | tee -a "$XMLFILE" 
				done
				item="$(echo ${item} | sed s/%header%//)"
				echo -e "$(xml_tag_start "${item}")" | tee -a "$XMLFILE"
				((XML_INDENT++))

				
			### FOOTER TAG
			elif [ "$(echo ${item} | grep '^%footer%')" ]; then
				((XML_INDENT--))
				for indent in $(seq 1 $XML_INDENT); do
					echo -ne "\t" | tee -a "$XMLFILE"
				done
				item="$(echo ${item} | sed s/%footer%//)"
				echo -e "$(xml_tag_stop "${item}")" | tee -a "$XMLFILE"

			fi
		fi				
	done	
		 
}

function print_lanforce_xml {

	# this functions prepares the output xml to conform to the LanForce dtd.
	# LanForce is a commercial company who hired a dev to do this script :)
	# works pretty much the same as print_xml()

	for itemnr in $(seq 0 $((${#infostring[@]}-1))); do
		item="${infostring[$itemnr]}"
		#echo $item
		if [ ! "$(echo ${item} | grep '^%')" ]; then
			echo -e "   $(xml_value "${item}")" | tee -a "$XMLFILE"

		else
			### CLOSE ATTRIBUTE TAG
			if [ "$attribute" == "open" ]; then
				echo -e "  $(xml_attribute_stop)" | tee -a "$XMLFILE"
				attribute="closed"
			fi

			### ATTRIBUTE TAG
			if [ "$(echo ${item} | grep '^%attribute%')" ]; then
				item="$(echo ${item} | sed s/%attribute%//)"
				name=$(echo ${item} | awk -F\; {'print $1'})
				code=$(echo ${item} | awk -F\; {'print $2'})
				#xml_attribute_start "${name}" "${code}"
				echo -e "  $(xml_attribute_start "${name}" "${code}")" | tee -a "$XMLFILE"
				attribute="open"
			fi

			### OPEN ATTRIBUTE TAG
			#if [ "$(echo ${item} | grep '^%attribute%')" ]; then
			#	item="$(echo ${item} | sed s/%attribute%//)"
			#	name=$(echo ${item} | awk -F\; {'print $1'})
			#	code=$(echo ${item} | awk -F\; {'print $2'})
			#	lf_attribute "N/A" "${name}" "${code}" | tee -a $XMLFILE
			#fi
		fi
	done

}

function print_stdout {

	# this function formulates $infostring for stdout
	# header tags are printed; attribute names are printed;
	# values for each attribute are printed on the same line
	# separated with a tab.

	# $value_string is formulated in the following steps:
	#	1 test if item does not begin with '%' => add value + tab to string; next
	#	2 if there is an attribute tag open => add newline to string
	#	3 if the item begins with %attribute% => add attribute + tab to string
	#		if there is a need to add more tabs for indentation, add tabs ; next
	#	4 if the item begins with %header% => add header + newline to string; next

	# finally $value_string is printed at once.


	# TODO: get tabsize dynamically
	TABSIZE=6 

	# this routine gets the longest header string in $infostring
	longest_string=0
	for itemnr in $(seq 0 1 $((${#infostring[@]}-1))); do
		item="${infostring[$itemnr]}"
		#echo $item
		if [ "$(echo ${item} | grep '^%attribute%')" ]; then
			item="$(echo ${item} | sed s/%attribute%//)"
			name=$(echo ${item} | awk -F\; {'print $1'})
	
			if [ ${#name} -gt $longest_string ]; then
				longest_string=${#name}
			fi
		fi
	done

	# this routine formulates $value_string
	INDEX=0 ; value_string="" ; attribute="closed"
	for itemnr in $(seq 0 1 $((${#infostring[@]}-1))); do
		item="${infostring[$itemnr]}"

		if [ ! "$(echo ${item} | grep '^%')" ]; then
			# this is a normal value item
			value_string="${value_string}${item}\t";

		else
		
			if [ "$attribute" == "open" ]; then
				value_string="${value_string}\n"
				attribute="closed"
			fi

			if [ "$(echo ${item} | grep '^%header%')" ]; then 
				item="$(echo ${item} | sed s/%header%//)"
				value_string="${value_string}${item}\n";
			

			elif [ "$(echo ${item} | grep '^%attribute%')" ]; then
				item="$(echo ${item} | sed s/%attribute%//)"
				name=$(echo ${item} | awk -F\; {'print $1'})
				value_string="${value_string}${name}\t";
				attribute="open"

				
				# this evaluation counts the proper amount of tabs to add
				# for beautiful identation.
				#echo -en ${name} " : " ${#name} "\n"
				#echo "diff : " $(($longest_string-${#name}))
				tabs_to_add=$((($longest_string-${#name})/$TABSIZE))
				#echo "tabs to add : " $tabs_to_add	
				if [ $tabs_to_add -ge 1 ]; then
					for i in $(seq 1 $tabs_to_add); do
						value_string="${value_string}\t" 
					done
				fi
			fi
		fi
	done
	value_string=${value_string}"\n";

	echo -e "${value_string}" | \
		sed "s/^\([-_.A-Za-z0-9()]*\)/${tBOLD}\1${tSTD}/" 

}



################################################################################
# Prints "$name_value_pair_list" then empties the "$name_value_pair_list"
# Uses colours
# Uses the "column" tool
function flush_name_value_pair {
	if [ "$usexml" == 1 ]; then


		##############################################
		# this outputs XML
		# Operation method: breaks value pair list into components, runs a for loop
		# and parses the items into xml. needs a variable to aid the process.
		# Could be better. :)
		
		
		#### OUTER OPENING TAG
		if [ "$value_pair_header" ]; then 
			for indent in $(seq 0 $XML_INDENT); do 
				echo -ne "\t" | tee -a $XMLFILE 
			done
			((XML_INDENT++))
			echo -e "$(xml_tag_start "${value_pair_header}")" 	| tee -a $XMLFILE		# open tag
			unset value_pair_header
		fi
		
		unset openTag
		#			tr -s '°' '\n' | \
		for value in $(
			echo  -e "$name_value_pair_list" | \
				tr -s ' ' 'ø'
			# TODO: is it possible to run a for loop with the whitescapes, each line only
			# constituting a new item in the loop, (not using whitescape, rather \n as the mark)?
		); do
		 
		 #echo ${value}
		 value1="$(echo ${value} | awk -F° {'print $1'})"
		 value2="$(echo ${value} | awk -F° {'print $2'})"
		 
		 
		 if [ ! "${openTag}" ]; then
			 #echo "new tag"
			 #echo $value1
			 for indent in $(seq 0 $XML_INDENT); do echo -ne "\t" | tee -a $XMLFILE 
			 done
			 ((XML_INDENT++))
			 echo -e "$(xml_tag_start "${value1}")" | tr 'ø' ' '	| tee -a $XMLFILE	# open tag
			 openTag=${value1}
			 
			 if [  "${value2}" ]; then 
				 for indent in $(seq 0 $XML_INDENT); do echo -ne "\t" | tee -a $XMLFILE 
				 done
				 #echo "write data"
				 #echo $value2
				 
				 echo -e "${value2}"  | tr 'ø' ' '		| tee -a $XMLFILE	# write content
			 fi
			 
			 #echo "close tag"
			 #echo $value1
			 ((XML_INDENT--))
			 for indent in $(seq 0 $XML_INDENT); do echo -ne "\t" | tee -a $XMLFILE 
			 done
			 echo -e "$(xml_tag_stop "${openTag}")"  | tr 'ø' ' '	| tee -a $XMLFILE		# close tag
			 unset openTag;
		 fi
		 
		 
		 #### OUTER CLOSING TAG 
		 if [ "$value_pair_footer" ]; then 
			 for indent in $(seq 0 $XML_INDENT); do echo -ne "\t" | tee -a $XMLFILE 
			 done
			 ((XML_INDENT--))
			 echo -e "$(xml_tag_stop "${value_pair_footer}")" 	| tee -a $XMLFILE		# close
			 unset value_pair_footer
		 fi
		 
		done
		##############################################
		
	elif [ "$usekdialog" -eq 1 ]; then 
		
		##############################################
		# this outputs to KDIALOG
		# this is completely unmaintained. doesn't work
		
		TMPFILE="${TMPDIR:-/tmp}/${appname}.1.$$"
		echo -e "\n$value_pair_header"
		echo  "$name_value_pair_list" | \
			tr '°' '\t' | \
			tr '' ' ' > $TMPFILE
		kdialog --textbox "$TMPFILE" 600 "$linecount" --title "$k_title"
		rm $TMPFILE
		
	else
		
		# FIXME: This bit doesn't work at all on Gentoo 2006.0 64-bit
		#set -x
		###############################################
		# output to STDOUT
		
		[[ "$value_pair_header" ]] && echo -e "\n$value_pair_header"
		echo -e "$name_value_pair_list" | \
			column -ts '°' | \
			sed "s/^\([-_.A-Za-z0-9()]*\)/${tBOLD}\1${tSTD}/" | \
			tr '°' '\t'
		#set +x
	fi
	
	unset name_value_pair_list
	unset value_pair_header
	linecount=0
}
################################################################################


function wrong_module() {
	do_abort $"${1} is not a valid module!" 1
}


################################################################################
# Print module header
# Parameters:
#   1 string   Module name
module_header() {
	if [ "$usekdialog" == "1" ]; then
		k_title="$1"
	elif [ $usexml -eq 1 ]; then
		value_header "${1}"
	else
		print_line
		echo "${tcRED}${tUNDERLINE}"$"Report from module""${tSTD}${tUNDERLINE} ${tcBLUE}$1${tSTD}:"
	fi
}
################################################################################



################################################################################
# Print module footer (for xml)
# Parameters:
#   1 string   Module name
module_footer() {
	value_footer
}
################################################################################

	


for modul in $cmdsnames; do
	
	if [ $modul = 'all' ]; then
		if [ "$SYSTEM" == "linux" ] ; then
			
			cmdsnames="$MODULES_LINUX"
			break;
			
		elif [ "$(echo $SYSTEM | grep bsd)" ]; then
			
			cmdsnames="$MODULES_BSD"
			break;
		fi
	fi
	# validate_arg "$modul" "$MODULES" || wrong_module "$modul"
	# why is this function called? breaking MODULES for each system breaks it...
done

if [ "$prefix" != '/' ] ; then
	tmp_cmdsnames="$cmdsnames"
	cmdsnames=""
	for modul in $tmp_cmdsnames; do
		realrootrequired=0
		for real_root_modul in $MODULES_REAL_ROOT_ONLY; do
			[ "$modul" == "$real_root_modul" ] && realrootrequired=1
		done
		[ $realrootrequired -eq 0 ] && cmdsnames="$cmdsnames $modul"
	done
fi

if [ "$usexml" == 1 ]; then
	print_xml_header
fi

for modul in $cmdsnames; do

	case $modul in
		#		uname)              eval "Module_Cmd_${modul}";;
		terminal|\
			network|\
			distro|\
			devices|\
			users|\
			processor|\
			system|\
			lsmod|\
			hdd|\
			printers|\
			oem|\
			applications) Module_${modul};;
	esac
done
#		lsmod|\		# is very alpha, do not uncomment

[ "$usekdialog" -ne 1 ]  #&& print_line

if [ "$usexml" == 1 ]; then
	print_xml_footer
fi




############################################
# FINALLY SEND OVER TCP IF THE OPTION IS SET
if [ "$netcat" == "1" ]; then
	cat "$XMLFILE" | nc "$HOST" "$PORT"
fi
############################################

