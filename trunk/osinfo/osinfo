#!/usr/bin/env bash
#################################################################################
# OSINFO
#
# osinfo lists system information available to the OS.
#
# everything is collected honoring the requirement of minimum dependencies;
# ie. using standard *nix tools. some information is unavailable
# without special (but quite common) packages, but the availability
# of these is tested, and no error messaged are produced if these rarer
# tools are missing. see info below for a list of dependencies.
#
# the script has been currently tested on the following Linux distros:
#  Gentoo 2005.1 and 2006.0
#  Ubuntu 5.10 and 6.06
#  Fedora Core 4 and 5
#  Red Hat 9
#  Suse 10.0
#  SlackWare
#
# oldest tested bash is version 2.05.0
#
# and on FreeBSD 6.0
# on x86 and amd64 architectures (desktop and laptop) with various hardware
# configurations, ...
#
#
#################################################################################
# list of (known) dependencies:
#
# bash 2.02 or later
# GNU grep with support for extended regular expressions
# awk, sed, seq, tr, bc, uniq, sort
# netcat (for sending the xml output over tcp)
#
# per module: (incomplete)
# ----------
# users:   last, file:/var/log/wtmp
# dmi:     dmidecode
# oem:     lshw
# memory:  lshw
# cdrom:   lshw
# hdd:     fdisk, df, udev, smartmontools (optional), hdparm (optional)
# devices: lspci
# network: net-tools (hostname, ifconfig, route)
#          wireless-tools (iwconfig, iwlist) - optional
#
#################################################################################
# Written by Arvid Norlander and Mikael Lammentausta                            #
#                                                                               #
# Some parts are taken from:                                                    #
#   --Advanced Bash Scripting Guide (ABS)                                       #
#################################################################################
appname='osinfo'
major_version=0
minor_version=2
micro_version=8
patch_version=4
dev_status=alpha

# source some files
source bash.functions
source osinfo.modules
source xml.functions
source lanforce.functions


XMLFILE="osinfo.xml"

SYSTEM="$(uname -s  | tr 'A-Z' 'a-z' )"
#if [ ! "$(echo $SYSTEM | grep 'linux')" ] | [ ! "$(echo $SYSTEM | grep bsd)" ]; then
# freebsd doesn't understand '||' or evaluation, but it's not required
# NOTE: AnMaster: If you realy use bash it *should* understand ||.
#	echo "This script has not been tested on other operating systems than Linux and FreeBSD."
#	echo
#	exit 0;
#fi


# AnMaster: Why do we need gseq and not seq on *BSD?
# answer: On *BSD, coreutils are prepended with 'g' to imply 'GNU'
# http://www.freebsd.org/cgi/url.cgi?ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/ports/sysutils/coreutils/pkg-descr
if [ "$(grep bsd <<< "$SYSTEM")" ]; then
	function seq() {
		gseq "$@"
	}
fi


# initialize global variables
isverbose=0
isdebug=0
usekdialog=0
lanforce=0
usexml=0
fake=0
# The root dir.
# To put this in a variable allows info on non-running systems
prefix="/"


function PRINT_Help {
	local MODULE
	print_line
	echo "${header}${appname} displays information about the system${tSTD}"
	echo
	echo "Arguments are names of modules to get info from:"
	echo
	if [ "$SYSTEM" == "linux" ] ; then
		for MODULE in ${MODULES_LINUX}; do
			echo -e "\t\t$MODULE"
		done
	elif [ "$(grep bsd <<< "$SYSTEM")" ]; then
		for MODULE in ${MODULES_BSD}; do
			echo -e "\t\t$MODULE"
		done
	fi
	echo
	echo 'If arguments is "all" then list information from all modules.'
	echo
	echo "${tBOLD}Syntax:${tSTD}"
	echo "  $(basename $0) [Options] arguments"
	echo "  $(basename $0) [--usage|--help]"
	echo "${tBOLD}Options:${tSTD}"
	echo "      --xml               Printout in xml format to osinfo.xml"
	echo "      --lanforce          Makes the output to osinfo.xml according to a special DTD."
	echo "  -v, --verbose           Show more information"
	echo "  -o, --output [file]     Use this file for xml output."
	echo "      --debug             For testing"
	echo "  -D, --fulldebug         Print full debugging info, clutters output!"
	echo "      --kdialog           Show the information using KDialog"
	echo "                            from KDE. Experimental feature!"
	echo "                            Not usable yet!"
	echo "  -P, --prefix [dir]      Use this dir as root"
	echo "                            This disables some modules."
	echo "  -V, --version           Shows the version of ${tBOLD}${appname}${tSTD}"
	echo "                            and exits."
	echo
	print_line
	if [ "$1" ]; then
		exit $1
	else
		exit 0
	fi
}

# Before we break path hash some binaries so the script can find them (if they exist).
hash kdialog &>/dev/null


######## SETTING USERSPACE VARIABLES
# PATH here allows normal users to run ifconfig and lsmod
export PATH=$PATH:/bin/:/sbin/:/usr/bin/:/usr/sbin/
# LC_ALL makes is possible to print to stdout, due to support for '' :)
#[[ ! "$LC_ALL" ]] && export LC_ALL="en_GB"


####### PARSE THE COMMAND LINE ARGUMENTS
if [ "$#" -gt 0 ]; then
	while [ "$#" -gt 0 ]; do
		case "$1" in
			'--help'|'-help'|'--usage'|'-usage'|'-h'|'')
				PRINT_Help
				;;
			'-P'|'--prefix')
				if [ $2 ]; then
					# Make sure there is only one ending "/".
					prefix="$(echo $2 | sed 's/\/*$/\//')"
					shift 2
				else
					missing_arg "$1"
				fi
				;;
			'--kdialog')
				usekdialog=1
				shift 1
				;;
			'--xml')
				usexml=1
				shift 1
				;;
			'-o'|'--output')
				if [ $2 ]; then
					XMLFILE="$2"
					shift 2
				else
					missing_arg "$1"
				fi
				;;
			'--lanforce')
				usexml=1
				lanforce=1
				shift 1
				;;
			# TODO: This seems to need --xml too. After all cmd args are passed check for
			# TODO: "[ $netcat -eq 1 ] && [ $usexml -eq 0 ]; then errormessage" (or something like that).
			'--nc'|'--netcat')
				if [ "$2" ] && [ "$3" ]; then
					netcat=1
					HOST="$2"
					PORT="$3"
					shift 3
				else
					echo "You must set the target host and port!"
					missing_arg "$1" 2
				fi
				;;
			'-v'|'--verbose')
				isverbose=1
				shift 1
				;;
			'-D'|'--fulldebug')
				export isdebug=1
				set -x
				shift 1
				;;
			'--debug')
				export isdebug=1
				shift 1
				;;
			'--dev')
				# for faking input from files to debug stuff, for example
				# LVM drives when no such drives are available
				export fake=1
				shift 1
				;;
			'-V'|'--version')
				echo "${tBOLD}${appname}${tSTD}-${major_version}.${minor_version}.${micro_version}-${patch_version} ${dev_status}"
				echo "Copyright (C) 2005-2006 Arvid Norlander"
				echo "Copyright (C) 2006 Mikael Lammentausta"
				echo "This is free software; see the source for copying conditions.  There is ${tBOLD}NO"
				echo "warranty${tSTD}; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
				echo
				exit 0;
				;;
			*)
				cmdsnames="$cmdsnames $1"
				shift 1;
				;;
		esac
	done
else
	PRINT_Help
fi

############################################
# XML HEADER & FOOTER FUNCTIONS

function print_xml_header () {
	if [ "$lanforce" == 1 ]; then

		# AnMaster: To produce valid XML that *needs* to be "entityset"...
		xml_doc_start "entityset" "SYSTEM" "lanforce.dtd" | tee "${XMLFILE}"
		ip="$(ifconfig $interface_name | \
			grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | \
			grep -Eo '[0-9\.]+' )"
		lf_entity_start "$(hostname)" "$ip" | tee -a "${XMLFILE}"

	else

		xml_doc_start "osinfo" "SYSTEM" "osinfo.dtd" | tee "${XMLFILE}"
		xml_tag_start "${appname}" | tee -a "${XMLFILE}"
		XML_INDENT=1

	fi
}

function print_xml_footer () {
	if [ "$lanforce" == 1 ]; then
		lf_entity_stop | tee -a "${XMLFILE}"
		#lf_note
	else
		xml_tag_stop "${appname}" | tee -a "${XMLFILE}"
	fi
}

############################################





################################################################################
# value_header(), value_footer(), add_attribute(), add_values(), flush_values()
# -------------------------------------------------------------------
# these are a group of functions that are used by the modules to formulate the output.
#
# flush_values calls either print_xml, print_lanforce_xml or print_stdout
# depending on the parameters the user has set during invocations of osinfo.
#
# the other functions use the $infostring[] to store the information
# collected by the modules. the format of this array is like:
# [%header%System information] [%attribute%Operating system;os] [Linux]
# detailed information is given in each function.


function value_header() {

	# this function inserts the input string as the last available item
	# in the $infostring array. it also adds a %header% tag which will be
	# use by print_* functions to interpret how to parse the string.

	#echo ${#infostring[@]}
	infostring[${#infostring[@]}]="%header%\n${1}"
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
	#echo ${infostring[0]}
}


function value_footer() {

	# this function searches the $infostring array backwards,
	# looking for open headers.

	# NEEDS DEBUGGING!

	#for HDR in $(seq ${#headers[@]} -1 0); do
	#echo ${headers[$HDR]}
	#	if [ "$(echo ${headers[$HDR]} | grep -Eo '^[A-�-�]+')" ]; then
			#echo $HDR
	#		headers[${#headers[@]}]="%footer%${headers[$HDR]}"
		        #value_string="/$HDR\n";
	#		break;
	#	fi
	#done
	local IFS_bak="$IFS"
	IFS=$' \t\n'

	local found="" position item
	for position in $(seq ${#infostring[@]} -1 0); do
		item="${infostring[$position]}"
		# first collect %footer%s into $found array
		if [ "$(grep '^%footer%' <<< "${item}")" ]; then
			found="$(grep '^%footer%' <<< "${item}" | sed s/%footer%//)"

		# then continue and add a footer if it is not already found
		elif [ "$(grep '^%header%' <<< "${item}")" ]; then
			item="$(sed "s/%header%//" <<< "${item}")"

			if [ "${item}" != "${found}" ]; then
			#found[${#found[@]}]="$(echo ${item} | \
			#	grep '^%header%' | sed s/%header%/%footer%/)"
			# then test if this has
			#echo $found
				infostring[${#infostring[@]}]="%footer%${item}"
				# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
				break;
			fi
		fi
	done

	IFS="$IFS_bak"

	#for VL in $(seq 0 ${#infostring[@]}); do
#		echo ${infostring[$VL]}
#	done

}


# This function inserts the input string(s) as the last available item
# in the $infostring array, with a field delimiter of ";".
# it also adds an %attribute% tag which will be use by print_* functions
# to interpret how to parse the string.
# Parameters:
#  1 free-form name    (eg. Operating system)   (required)
#  2 code tag for xml  (eg. os)                 (optional)
function add_attribute() {
	infostring[${#infostring[@]}]="%attribute%${1};${2}"
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}

# This function inserts the input string or strings into the $infostring[] array.
function add_values {

	# check the number of input values.
	# modules may output a blank string, and because that is also considered
	# to be a string, this eval(uation) compares the strings one by one.
	#AMT_VALUES=0
	#for i in $(seq 1 1 $#); do
	#	if [ "$(eval "echo \$$i")" != "" ]; then
	#		((AMT_VALUES++))
	#	fi
	#done

	# IFS need to be changed because the values are separated by newline
	local IFS_bak="$IFS" value
	IFS=$'\n'
	for value in $@; do
		infostring[${#infostring[@]}]="$value"
	done
	IFS="$IFS_bak"


	# THIS IS FOR DEBUGGING

	#	for HDR in $(seq 1 ${#headers[@]}); do
	#		echo ${headers[$HDR]}
	#	done

	#	for VL in $(seq 1 ${#values[@]}); do
	#		echo ${values[$VL]}
	#	done

	#	echo ${#headers[@]}
	#	echo ${#values[@]}

}


function flush_values {
	if [ "$usexml" == "0" ]; then
		print_stdout
	elif [ "$usexml" == "1" ] && [ "$lanforce" == "0" ]; then
		print_xml
	else
		print_lanforce_xml
	fi

	# infostring is set at functions add_*
	# and needs to be reset here so that the informaton
	# from this module will not be reprinted later
	unset infostring
}


################################################################################
# print_xml(), print_lanforce_xml(), print_stdout()
# -------------------------------------------------------------------
# this set of functions formulates the items in $infostring for output.
# detailed information is given in each function.


# This function loops the $infostring and does the following steps
# for each item:
#  1 test if item does not begin with '%' => print value; next
#  2 if there is an attribute tag open => close it
#  3 if the item begins with %attribute% => print attribute ; next
#  4 if the item begins with %header% => print header ; next
#  5 if the item begins with %footer% => print footer ; next
function print_xml {
	local itemnr item name code attribute header

	for itemnr in $(seq 0 1 $((${#infostring[@]}-1))); do
		item="${infostring[$itemnr]}"
		#echo $item
		if [ ! "$(grep '^%' <<< "${item}")" ]; then

			for indent in $(seq 1 1 $XML_INDENT); do
				echo -ne "\t" | tee -a "${XMLFILE}"
			done

			# the following sed removes all formatting tags
			# from the value string. it's a tad slow, though.
			item="$(sed 's/\\[a-z]//g;s/^ *//' <<< "${item}")"
			xml_value "${item}" | tee -a "${XMLFILE}"

		else

			### CLOSE ATTRIBUTE TAG
			if [ "$attribute" == "open" ]; then
				((XML_INDENT--))
				for indent in $(seq 1 1 $XML_INDENT); do
					echo -ne "\t" | tee -a "${XMLFILE}"
				done
				xml_attribute_stop | tee -a "${XMLFILE}"
				echo | tee -a "${XMLFILE}"
				attribute="closed"
			fi

			### NEW ATTRIBUTE TAG
			if [ "$(grep '^%attribute%' <<< "${item}")" ]; then
				for indent in $(seq 1 1 $XML_INDENT); do
					echo -ne "\t" | tee -a "${XMLFILE}"
				done
				# parse item
				item="$(sed s/%attribute%// <<< "${item}")"

				# validate xml
				name="$(awk -F\; {'print $1'} <<< "${item}" | \
					sed 's/\\[a-z]//g' | tr 'A-Z' 'a-z')"

				code=$(awk -F\; {'print $2'} <<< "${item}")

				xml_attribute_start "${name}" "${code}" | tee -a ${XMLFILE}
				((XML_INDENT++))
				attribute="open"


			#### HEADER TAG
			# redundant: this will not go to xml

			elif [ "$(grep '^%header%' <<< "${item}")" ]; then

				# close open header tag.. this leaves the closing tag off
				if [ "$header" == "open" ]; then
					((XML_INDENT--))
				fi

				for indent in $(seq 1 1 $XML_INDENT); do
					echo -ne "\t" | tee -a "${XMLFILE}"
				done
				item="$(sed 's/%header%//' <<< "${item}")"

				# validate xml
				name="$(awk -F\; {'print $1'} <<< "${item}" | \
					sed 's/\\[a-z]//g;s|/|_|g' | tr ' A-Z' '_a-z')"

				xml_tag_start "${name}" | tee -a "${XMLFILE}"
				((XML_INDENT++))
				header="open"


			### FOOTER TAG
			elif [ "$(grep '^%footer%' <<< "${item}" )" ]; then
				((XML_INDENT--))
				for indent in $(seq 1 1 $XML_INDENT); do
					echo -ne "\t" | tee -a "${XMLFILE}"
				done
				item="$(sed 's/%footer%//' <<< "${item}")"

				# validate xml
				name="$(awk -F\; {'print $1'} <<< "${item}" | \
					sed 's/\\[a-z]//g;s|/|_|g' | tr ' A-Z' '_a-z')"

				xml_tag_stop "${name}" | tee -a "${XMLFILE}"
				header="closed"

			fi
		fi
	done

}


# This functions prepares the output xml to conform to the LanForce dtd.
# LanForce is a commercial company who hired a dev to do this script
# and that dev continued on an existing script.
# works pretty much the same as print_xml()
function print_lanforce_xml {
	for itemnr in $(seq 0 1 $((${#infostring[@]}-1))); do

		local item="${infostring[$itemnr]}" attribute code

		if [ ! "$(grep '^%' <<< "${item}")" ]; then

			# only print values for which attribute is active
			# (prevents attributes with no code tag from printing)
			if [ "$attribute" == "open" ]; then

				# the following sed removes all formatting tags
				# from the value string. it's a tad slow, though.
				item="$(sed 's/\\[a-z]//g;s/^ *//' <<< "${item}")"
				echo "   $(xml_value "${item}")" | tee -a "${XMLFILE}"

			fi

		else
			### CLOSE ATTRIBUTE TAG
			if [ "$attribute" == "open" ]; then
				echo -e "  $(xml_attribute_stop)" | tee -a "${XMLFILE}"
				attribute="closed"
			fi

			### ATTRIBUTE TAG
			if [ "$(grep '^%attribute%' <<< "${item}")" ]; then

				local item="$(sed s/%attribute%// <<< "${item}")"
				local code="$(awk -F\; {'print $2'} <<< "${item}")"

				# only print attributes and values with a code
				if [ "$code" != "" ]; then

					# validate xml
					local name="$(awk -F\; {'print $1'} <<< "${item}" | \
						sed 's/\\[a-z]//g' | tr ' A-Z' '_a-z')"

					echo -e "  $(xml_attribute_start ${name} ${code})" | \
						tee -a "${XMLFILE}"
					attribute="open"

				fi
			fi

			### OPEN ATTRIBUTE TAG
			#if [ "$(echo ${item} | grep '^%attribute%')" ]; then
			#	item="$(echo ${item} | sed s/%attribute%//)"
			#	name=$(echo ${item} | awk -F\; {'print $1'})
			#	code=$(echo ${item} | awk -F\; {'print $2'})
			#	lf_attribute "N/A" "${name}" "${code}" | tee -a ${XMLFILE}
			#fi
		fi
	done

}

# This function formulates $infostring for stdout
# header tags are printed; attribute names are printed;
# values for each attribute are printed on the same line
# separated with a tab.
#
# $value_string is formulated in the following steps:
#  1 Test if item does not begin with '%' => add value + tab to string; next
#  2 If there is an attribute tag open => add newline to string
#  3 If the item begins with %attribute% => add attribute + tab to string
#    If there is a need to add more tabs for indentation, add tabs ; next
#  4 If the item begins with %header% => add header + newline to string; next
#
#  Finally $value_string is printed at once.
function print_stdout {

	# Get tabsize dynamically
	TABSIZE=$(tput it)

	# this routine gets the longest header string in $infostring
	longest_string=0
	for itemnr in $(seq 0 1 $((${#infostring[@]}-1))); do
		item="${infostring[$itemnr]}"
		#echo $item
		if [ "$(grep '^%attribute%' <<< "${item}")" ]; then
			item="$(sed s/%attribute%// <<< "${item}")"
			name=$(awk -F\; {'print $1'} <<< "${item}")

			if [ ${#name} -gt $longest_string ]; then
				longest_string=${#name}
			fi
		fi
	done


	# this routine formulates $value_string
	# mechanism: sequentially parse the $infostring from start to end
	# and copy the contents to $item. if $item does not contain formulating
	# info (begin with %), then it is copied to $value_string.

	INDEX=0 ; value_string="" ; attribute="closed"
	for itemnr in $(seq 0 1 $((${#infostring[@]}-1))); do
		item="${infostring[$itemnr]}"

		# this is a normal value item
		if [ ! "$(grep '^%' <<< "${item}")" ]; then

			# test if an attribute is open,
			# whether the last item in value_string ended with newline
			# (prevents sequential values like in mod_hdd be affected)
			# and the previous item ended with other than a tab (\t)
			# FIXME: doesn't work right.
			if [ "$attribute" == "open" ] && \
				[ "${item: -1:2}" == "n" ] && \
				[ "${value_string: -1:2}" == "t" ]; then

				unset tab_string
				# there's something slightly wrong here
				for i in $(seq 0 1 $(($max_indent-$diff_indent-1)) ); do
					local tab_string="${tab_string}\t"
				done

				#local value_string="${value_string}${tab_string}"
			fi


			# this evaluation counts the proper amount of tabs to add
			# for beautiful identation.

			# lots of code has been commented for later debugging

				# bash always rounds downward, so 20/8 = 2

				# max indent is the indentation (in tabs) of the longest string
				# diff indent is the difference between the current item and the max
				local max_indent=$(($longest_string/$TABSIZE))
				local diff_indent=$(($max_indent-${#name}/$TABSIZE))

				#echo "diff : $diff"
				#if [ ${#name} -ne $TABSIZE ]; then
				# bc might not be available everywhere. not sure about that.
				#set -x
				#foo=$(echo ${#name}/$TABSIZE | bc -l | awk -F. {'print $NF'})
				#echo $foo
				#exit 0
				#if [ ${#name} -ne $TABSIZE ]; then
				#if [ $diff -ne 0 ]; then
					#tabs_to_add=$(($diff/$TABSIZE+1))
					local tabs_to_add=$diff_indent
					#echo "tabs to add : " $tabs_to_add
					if [ $tabs_to_add -ge 1 ]; then
						unset tab_string
						for i in $(seq 1 1 $tabs_to_add); do
							local tab_string="${tab_string}\t"
						done
						local value_string="${value_string}${tab_string}"
					fi
				#fi


			local value_string="${value_string}${item}\t";


		else


			# if an attribute is open, print a newline
			if [ "$attribute" == "open" ]; then
				local value_string="${value_string}\n"
				attribute="closed"
			fi


			# prints header
			if [ "$(grep '^%header%' <<< "${item}")" ]; then
				local item="$(sed s/%header%// <<< "${item}")"
				local value_string="${value_string}${tBOLD}${item}${tSTD}\n";


			# prints attribute
			elif [ "$(grep '^%attribute%' <<< "${item}")" ]; then

				local item="$(sed s/%attribute%// <<< "${item}")"
				local name=$(awk -F\; {'print $1'} <<< "${item}")
				local value_string="${value_string}${name}\t";
				attribute="open"


			fi
		fi
	done
	#local value_string=${value_string}"\n";

	# this sed makes the first item bold
	echo -e "${value_string}\n" #| sed "s/^\([-_.A-Za-z0-9()]*\)/${tBOLD}\1${tSTD}/"

}


################################################################################
# Module functions
# ------------------------------------------------------------------------------

function wrong_module() {
	do_abort "${1} is not a valid module!" 1
}


################################################################################
# Print module header
# Parameters:
#   1 string	Module name
module_header() {
	if [ "$usekdialog" == "1" ]; then
		k_title="$1"
	elif [ $usexml -eq 1 ]; then

		# make valid xml tag
		xml_tag="$(tr ' A-Z' '_a-z' <<< "${1}")"
		value_header "${xml_tag}"

	else
		print_line
		echo "${tcRED}${tUNDERLINE}Report from module${tSTD}${tUNDERLINE} ${tcBLUE}$1${tSTD}:"
	fi
}
################################################################################



################################################################################
# Print module footer (for xml)
# Parameters:
#   1 string   Module name
module_footer() {
	value_footer
}
################################################################################



#######################
# THE "MAIN" FUNCTION

# check the operating system module support etc
# AnMaster: FIXME: Should be done *after* meta modules as well as before? moment 22...
for modul in $cmdsnames; do

	# TODO: check that the module being called is supported on the running OS
	# this is the place to put all env variables to be set for some module

	# TODO: something like this...shouldn't burden the script too much
	# with excessive loops
	#allowed_modules=''
	#if ! CheckReq_root; then
	#	allowed_modules=$MODULES_ALL-$MODULES_SU_ONLY
	#fi

	if [ $modul = 'all' ]; then
		if [ "$SYSTEM" == "linux" ] ; then
			#cmdsnames="$MODULES_LINUX"
			break
		# TODO: please check if this works on bsd and old bash
		elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then
			#cmdsnames="$MODULES_BSD"
			break
		fi
	elif [ $modul = 'lanforce' ]; then
		lanforce=1
		usexml=1
		#cmdsnames="$MODULES_LANFORCE"
		break
	fi

	# FIXME: breaks meta-modules
	# FIX meta modules instead. And keep module list up to date...
	validate_arg "$modul" "$MODULES_ALL $MODULES_META" || wrong_module "$modul"
	# validate_arg is called to check that the module exits at all.
	# AnMaster: If we DON'T validate user input *and* use eval below we
	#           are *realy* stupid. So don't comment that out.
	#           Instead update the variable MODULES_ALL in osinfo.modules
	#           We MUST validate the user input if we are going to use eval
	#           otherwise someone could use that to run something evil (as root), like rm -rf /.

done

if [ "$prefix" != '/' ] ; then
	tmp_cmdsnames="$cmdsnames"
	cmdsnames=""
	for modul in $tmp_cmdsnames; do
		realrootrequired=0
		for real_root_modul in $MODULES_REAL_ROOT_ONLY; do
			[ "$modul" == "$real_root_modul" ] && realrootrequired=1
		done
		[ $realrootrequired -eq 0 ] && cmdsnames="$cmdsnames $modul"
	done
fi

if [ "$usexml" == 1 ]; then
	print_xml_header
fi

if [ -z "$cmdsnames" ]; then 
	PRINT_Help
fi

# this calls the module definitions. as there are Meta-modules
# and the actual modules, we first check if there's a Meta-module
# of that name. in that case, it is used.
for module in $cmdsnames; do

	# AnMaster: What the hell are you doing... why not use a case .. esac statment like we did before?
	#           that would solve it.
	# ruxpin: that would require a modification to this list after adding a module,
	#         which I want to avoid.
	# AnMaster: local modulename="Meta_${module}"
	#           metamod="${!modulename}"
	#           Needs bash 3 at least.
	#           Or base it on some declare magic.
	eval metamod="\${Meta_${module}}"

	if [ "$(echo $metamod)" ]; then

		for submodule in $metamod; do

			Module_${submodule}

		done

	else

		Module_${module}

	fi

done

#[ "$usekdialog" -ne 1 ]  #&& print_line

if [ "$usexml" == 1 ]; then
	print_xml_footer
elif [ "$usekdialog" -ne 1 ]; then
	print_line
fi

# Remove temporary files:
cleanup_temp_files

############################################
# FINALLY SEND OVER TCP IF THE OPTION IS SET
if [ "$netcat" == "1" ]; then
	cat "${XMLFILE}" | nc "$HOST" "$PORT"
fi
############################################

