#!/bin/bash
#!/usr/local/bin/bash
################################################################################
# List System information                                                      #
################################################################################
# Written by Arvid Norlander                                                   #
# 	   + Mikael Lammentausta                                                   #
# Some documentation are in Swedish                                            #
# Some parts are taken from:                                                   #
#   --Advanced Bash Scripting Guide (ABS)                                      #
################################################################################
appname='osinfo'
major_version=0
minor_version=1
micro_version=3
patch_version=0
dev_status=dev

# TODO: Import xml/kdialog/normal output libs here!
source bash.functions
source osinfo.modules
source xml.functions
#. bash_Debug_functions.sh
DEBUG=on
# TODO: Use a parameter
XMLFILE="osinfo.xml"

SYSTEM="$(uname -s  | sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/')"
if [ ! "$(echo $SYSTEM | grep 'linux')" ] | [ ! "$(echo $SYSTEM | grep bsd)" ]; then
# freebsd doesn't understand '||' or evaluation, but it's not required
	gettext $"This script has not been tested on other operating systems than Linux and FreeBSD."
	echo
#	exit 0;
fi

#On BSD, coreutils are prebended with 'g' *sigh*
#http://www.freebsd.org/cgi/url.cgi?ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/ports/sysutils/coreutils/pkg-descr

if [ "$(echo $SYSTEM | grep bsd)" ]; then
	Seq="$(type -p gseq)"
	function seq() {
		$Seq "$@"
	}
fi




isverbose=0
usekdialog=0
lanforce=0
# The root dir.
# To put this in a variable allows info on non-running systems
   prefix="/"


######## SETTING USERSPACE VARIABLES 
# PATH here allows normal users to run ifconfig and lsmod
export PATH=$PATH:/bin/:/sbin/:/usr/bin/:/usr/sbin/
# LC_ALL makes is possible to print to stdout, due to support for '¡' :)
[[ ! "$LC_ALL" ]] && export LC_ALL="en_GB"


function PRINT_Help {
	print_line
	gettext -s "${header}${appname} "$"displays information about the system""${tSTD}"
	echo 
	gettext -s -e $"Arguments are names of modules to get info from:"
	echo
        if [ "$SYSTEM" == "linux" ] ; then

			for MODULE in ${MODULES_LINUX}; do
				echo -e "\t\t$MODULE"
			done

        elif [ "$(echo $SYSTEM | grep bsd)" ]; then

			for MODULE in ${MODULES_BSD}; do
				echo -e "\t\t$MODULE"
			done

        fi
	echo
	gettext -s $"If arguments is \"all\" then list information from all modules."
	echo
	gettext -s "${tBOLD}"$"Syntax:""${tSTD}"
	echo "  $(basename $0) "$"[Options] arguments"
	echo "  $(basename $0) "$"[--usage|--help]"
	gettext -s "${tBOLD}"$"Options:""${tSTD}"
	gettext -s "      --xml               "$"Printout in xml format to osinfo.xml"
	gettext -s "  -v, --verbose           "$"Show more information"
	gettext -s "      --kdialog           "$"Show the information using KDialog"
	gettext -s "                            "$"from KDE. Experimental feature!"
	gettext -s "                            "$"Not usable yet!"
	gettext -s "  -P, --prefix [dir]      "$"Use this dir as root"
	gettext -s "                            "$"This disables some modules."
	gettext -s "  -V, --version           "$"Shows the version of ${tBOLD}${appname}${tSTD}"
	gettext -s "                            "$"and exits."
	echo
	print_line
	if [ "$1" ]; then
		exit $1
	else
		exit 0
	fi
}

if [ "$#" -gt 0 ]; then # there are arguments to the command
	while [ "$#" -gt 0 ]; do
		case "$1" in
			'--help'|'-help'|'--usage'|'-usage'|'-h'|'')
				PRINT_Help
				;;
			'-P'|'--prefix')
				if [ $2 ]; then
					prefix="$(echo $2 | sed 's/\/*$/\//')"
					shift 2
				else
					missing_arg "$1"
				fi
				;;
			'--kdialog')
				usekdialog=1
				shift 1
				;;
			'--xml')
				usexml=1
				shift 1
				;;
			'--lanforce')
				#usexml=1
				lanforce=1
				shift 1
				;;
			'--nc')
				if [ ! "$2" ] || [ ! "$3" ]; then
					echo "You must set the target host and port!"
					exit 0;
				fi
				netcat=1
				HOST=$2
				PORT=$3
				shift 3
				;;
			'-v'|'--verbose')
				isverbose=1
				shift 1
				;;
			'--version')
				echo "${tBOLD}${appname}${tSTD}-${major_version}.${minor_version}.${micro_version}-${patch_version} ${dev_status}";
				echo "Copyright (C) 2005-2006 Arvid Norlander";
				echo "This is free software; see the source for copying conditions.  There is ${tBOLD}NO"
				echo "warranty${tSTD}; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
				echo
				exit 0;
				;;
			*)
				cmdsnames="$cmdsnames $1"
				shift 1;
				;;
		esac
	done
else
	PRINT_Help
fi


############################################
# IF OUTPUTTING TO XMLFILE, PRINT HEADER
if [ "$usexml" == 1 ]; then
	xml_doc_start "osinfo" "SYSTEM" "osinfo.dtd" | tee $XMLFILE
	#echo "<osinfo>" | tee $XMLFILE
	XML_INDENT=1
fi
############################################



name_value_pair_list=""
k_title=""


################################################################################
# Adds a identifier and a value to "$name_value_pair_list".
# Parameters:
#   1 string   Name
#   2 string   Value
#
# WARNING: Do NOT indent! Uses a TWO line string!

function add_name_value_pair {
	name_value_pair_list="${name_value_pair_list}$(echo $1¡$2)\n"
	# uses a funny character '¡' that later will be parsed.
	# not very sophisticated. :/


	[ "$usekdialog" == "1" ] && let "linecount = $linecount + 1"

	# kdialog is unmaintained, but left here for future revisions.

	#$(echo "$1" | tr ' ' '_')Å$(echo "$2" | tr ' ' '_')"
	# Uses "Å" (AltGr+L) because it is uncommon
	#TODO: sed don't work with non Latin space replacement. Why?
}
################################################################################


function value_header() {

	# the headers array consists of items that are either:
	#	strings == header for xml
	#	an integer == number of values grouped in values[] array

	# this function inserts the input (string) as the last available item in the array.
#set -x
	headers[${#headers[@]}]="$1"
	infostring[${#infostring[@]}]="%header%$1"
#set +x


}

function add_attribute() {

	infostring[${#infostring[@]}]="%attribute%${1}"

}

function add_values {

	# a set of values are written to the infostring[] array.
	# the first input is the attribute, the rest are plain values.

	# check existing values array
	FIRST_BLANK_VALUE=${#values[@]}
	FIRST_BLANK_VALUE=${#infostring[@]}

	# check the number of input values, modules may output blank, and that is considered
	# a string, so this little eval thing compares the strings one by one
	AMT_VALUES=0
	for i in `seq 1 $#`; do
		if [ "$(eval "echo \$$i")" != "" ]; then
			((AMT_VALUES++))
		fi
	done

	# add an item to the headers array
	headers[${#headers[@]}]="$AMT_VALUES"


	# this will put the arguments into the values array
	IFS_bak=$IFS ; 	IFS="
" # a literal newline, do not indent
	for VALUE in $@; do
		values[$FIRST_BLANK_VALUE]="$VALUE"
		infostring[$FIRST_BLANK_VALUE]="$VALUE"
		((FIRST_BLANK_VALUE++))
	done
	IFS=$IFS_bak


	# THIS IS FOR DEBUGGING

#	for HDR in $(seq 1 ${#headers[@]}); do
	#		echo ${headers[$HDR]}
	#	done

	#	for VL in $(seq 1 ${#values[@]}); do
	#		echo ${values[$VL]}
	#	done

	#	echo ${#headers[@]}
	#	echo ${#values[@]}

}

function value_footer() {

	# this searches the headers array backwards, looking for an open header
	for HDR in $(seq ${#headers[@]} -1 0); do
#	echo ${headers[$HDR]}
		if [ "$(echo ${headers[$HDR]} | grep -Eo '^[A-Öa-ö ]+')" ]; then
#			echo $HDR
			headers[${#headers[@]}]="%footer%${headers[$HDR]}"
	        #VAL_STRING="/$HDR\n";
			break;
		fi
	done
	#set -x
	for position in $(seq ${#infostring[@]} -1 0); do
		if [ "$(echo ${infostring[$position]} | grep '^%header%')" ]; then
			infostring[${#infostring[@]}]="$(echo ${infostring[$position]} | sed s/%header%/%footer%/)"
			break;
		fi
	done
#set +x
}

function flush_values {
	if [ $usexml -eq 0 ]; then
		print_stdout
	elif [ $usexml -eq 1 ] && [ $lanforce -eq 0 ]; then
		print_xml
	else
		print_lanforce_xml
	fi
}

function print_xml {
	### XML OUTPUT ------\

	# debug:
#		for HDR in $(seq 1 ${#headers[@]}); do
#			echo ${headers[$HDR]}
#		done

#		for VL in $(seq 1 ${#values[@]}); do
#			echo ${values[$VL]}
#		done
#set -x
#cho $XML_INDENT
	
	for itemnr in $(seq 0 $((${#infostring[@]}-1))); do
		item="${infostring[$itemnr]}"
		#echo $item
		if [ ! "$(echo ${item} | grep '^%')" ]; then

			for indent in `seq 1 $XML_INDENT`; do 
				echo -ne "\t" | tee -a $XMLFILE 
			done
			
			echo -e "$(xml_value "${item}")" | tee -a $XMLFILE

		else
		
			### CLOSE ATTRIBUTE TAG
			if [ "$attribute" == "open" ]; then
				((XML_INDENT--))
				for indent in `seq 1 $XML_INDENT`; do
					echo -ne "\t" | tee -a $XMLFILE 
				done				
				echo -e "$(xml_attribute_stop)" | tee -a $XMLFILE
				echo | tee -a $XMLFILE
				attribute="closed"
			fi

			### ATTRIBUTE TAG
			if [ "$(echo ${item} | grep '^%attribute%')" ]; then
				for indent in `seq 1 $XML_INDENT`; do
					echo -ne "\t" | tee -a $XMLFILE 
				done
				item="$(echo ${item} | sed s/%attribute%//)"
				echo -e "$(xml_attribute_start "${item}")" | tee -a $XMLFILE
				((XML_INDENT++))
				attribute="open"


			#### OPENING TAG
			elif [ "$(echo ${item} | grep '^%header%')" ]; then 
				for indent in $(seq 1 $XML_INDENT); do 
					echo -ne "\t" | tee -a $XMLFILE 
				done
				item="$(echo ${item} | sed s/%header%//)"
				echo -e "$(xml_tag_start "${item}")" | tee -a $XMLFILE
				((XML_INDENT++))


			### CLOSING TAG
			elif [ "$(echo ${item} | grep '^%footer%')" ]; then
				((XML_INDENT--))
				for indent in `seq 1 $XML_INDENT`; do
					echo -ne "\t" | tee -a $XMLFILE 
				done
				item="$(echo ${item} | sed s/%footer%//)"
				echo -e "$(xml_tag_stop "${item}")" | tee -a $XMLFILE

			fi

		fi				
	done	
		 
}

function print_lanforce_xml {
	### XML OUTPUT ------\
	echo TODO
	exit 0;
}

function print_stdout {
	
	### STDOUT ---- \

	INDEX=0 ;  LONGEST_STRING=0
	for ITEMS in ${headers[@]}; do
		if [ ! "$(echo $ITEMS | grep -Eo '[A-Öa-ö]+')" ]; then
			for VALUE in `seq 1 $ITEMS`; do
				# fetch the longest string value
				#echo ${#values[$INDEX]}
				if [ ${#values[$INDEX]} -gt $LONGEST_STRING ]; then
					LONGEST_STRING=${#values[$INDEX]}
				fi
			((INDEX++))
			done
		fi
	done
	
	INDEX=0 ; VAL_STRING="" ; TABSIZE=7 ; 	
	# proper indentation requires this loop to be run twice
	for ITEMS in ${headers[@]}; do
		if [ "$(echo $ITEMS | grep -Eo '[A-Öa-ö]+')" ]; then
			# the item in the headers array is declared by value_header
			# and should be printed
	        VAL_STRING="$ITEMS\n";
		else
			for VALUE in `seq 1 $ITEMS`; do
			
				VAL_STRING="$VAL_STRING${values[$INDEX]}\t";
				
				# this evaluation counts the proper amount of tabs to add
				# for beautiful identation.
				#echo -en ${values[$INDEX]} " : " ${#values[$INDEX]} "\n"
				#echo "diff : " $(($LONGEST_STRING-${#values[$INDEX]}))
				TABS_TO_ADD=$((($LONGEST_STRING-${#values[$INDEX]})/$TABSIZE))
				#echo "tabs to add : " $TABS_TO_ADD	
				if [ $TABS_TO_ADD -ge 1 ]; then
					for i in `seq 1 $TABS_TO_ADD`; do
						VAL_STRING="$VAL_STRING\t" 
					done
				fi
				((INDEX++))
			done

			VAL_STRING=$VAL_STRING"\n";
		fi
	done

	echo -e "${VAL_STRING}" | \
		sed "s/^\([-_.A-Za-z0-9()]*\)/${tBOLD}\1${tSTD}/" 

	#unset headers
	#unset values

}



################################################################################
# Prints "$name_value_pair_list" then empties the "$name_value_pair_list"
# Uses colours
# Uses the "column" tool
function flush_name_value_pair {
	if [ "$usexml" == 1 ]; then


		##############################################
		# this outputs XML
		# Operation method: breaks value pair list into components, runs a for loop
		# and parses the items into xml. needs a variable to aid the process.
		# Could be better. :)
		
		
		#### OUTER OPENING TAG
		if [ "$value_pair_header" ]; then 
			for indent in $(seq 0 $XML_INDENT); do 
				echo -ne "\t" | tee -a $XMLFILE 
			done
			((XML_INDENT++))
			echo -e "$(xml_tag_start "${value_pair_header}")" 	| tee -a $XMLFILE		# open tag
			unset value_pair_header
		fi
		
		unset openTag
		#			tr -s '¡' '\n' | \
		for value in $(
			echo  -e "$name_value_pair_list" | \
				tr -s ' ' '¿'
			# TODO: is it possible to run a for loop with the whitescapes, each line only
			# constituting a new item in the loop, (not using whitescape, rather \n as the mark)?
		); do
		 
		 #echo ${value}
		 value1="$(echo ${value} | awk -F¡ {'print $1'})"
		 value2="$(echo ${value} | awk -F¡ {'print $2'})"
		 
		 
		 if [ ! "${openTag}" ]; then
			 #echo "new tag"
			 #echo $value1
			 for indent in `seq 0 $XML_INDENT`; do echo -ne "\t" | tee -a $XMLFILE 
			 done
			 ((XML_INDENT++))
			 echo -e "$(xml_tag_start "${value1}")" | tr '¿' ' '	| tee -a $XMLFILE	# open tag
			 openTag=${value1}
			 
			 if [  "${value2}" ]; then 
				 for indent in `seq 0 $XML_INDENT`; do echo -ne "\t" | tee -a $XMLFILE 
				 done
				 #echo "write data"
				 #echo $value2
				 
				 echo -e "${value2}"  | tr '¿' ' '		| tee -a $XMLFILE	# write content
			 fi
			 
			 #echo "close tag"
			 #echo $value1
			 ((XML_INDENT--))
			 for indent in `seq 0 $XML_INDENT`; do echo -ne "\t" | tee -a $XMLFILE 
			 done
			 echo -e "$(xml_tag_stop "${openTag}")"  | tr '¿' ' '	| tee -a $XMLFILE		# close tag
			 unset openTag;
		 fi
		 
		 
		 #### OUTER CLOSING TAG 
		 if [ "$value_pair_footer" ]; then 
			 for indent in `seq 0 $XML_INDENT`; do echo -ne "\t" | tee -a $XMLFILE 
			 done
			 ((XML_INDENT--))
			 echo -e "$(xml_tag_stop "${value_pair_footer}")" 	| tee -a $XMLFILE		# close
			 unset value_pair_footer
		 fi
		 
		done
		##############################################
		
	elif [ "$usekdialog" -eq 1 ]; then 
		
		##############################################
		# this outputs to KDIALOG
		# this is completely unmaintained. doesn't work
		
		TMPFILE="${TMPDIR:-/tmp}/${appname}.1.$$"
		echo -e "\n$value_pair_header"
		echo  "$name_value_pair_list" | \
			tr '¡' '\t' | \
			tr '' ' ' > $TMPFILE
		kdialog --textbox "$TMPFILE" 600 "$linecount" --title "$k_title"
		rm $TMPFILE
		
	else
		
		# FIXME: This bit doesn't work at all on Gentoo 2006.0 64-bit
		#set -x
		###############################################
		# output to STDOUT
		
		[[ "$value_pair_header" ]] && echo -e "\n$value_pair_header"
		echo -e "$name_value_pair_list" | \
			column -ts '¡' | \
			sed "s/^\([-_.A-Za-z0-9()]*\)/${tBOLD}\1${tSTD}/" | \
			tr '¡' '\t'
		#set +x
	fi
	
	unset name_value_pair_list
	unset value_pair_header
	linecount=0
}
################################################################################


function wrong_module() {
	do_abort $"${1} is not a valid module!" 1
}


################################################################################
# Print module header
# Parameters:
#   1 string   Module name
print_module_header() {
	if [ "$usekdialog" == "1" ]; then
		k_title="$1"
	elif [ $usexml -eq 1 ]; then
		value_header "${1}"
	else
		print_line
		echo "${tcRED}${tUNDERLINE}"$"Report from module""${tSTD}${tUNDERLINE} ${tcBLUE}$1${tSTD}:"
	fi
}
################################################################################



################################################################################
# Print module footer (for xml)
# Parameters:
#   1 string   Module name
print_module_footer() {
	if [ "$usexml" == 1 ]; then
		echo -e "\t$(xml_tag_stop "${1}")"
	fi
}
################################################################################



for modul in $cmdsnames; do
	
	if [ $modul = 'all' ]; then
		if [ "$SYSTEM" == "linux" ] ; then
			
			cmdsnames="$MODULES_LINUX"
			break;
			
		elif [ "$(echo $SYSTEM | grep bsd)" ]; then
			
			cmdsnames="$MODULES_BSD"
			break;
		fi
	fi
	# validate_arg "$modul" "$MODULES" || wrong_module "$modul"
	# why is this function called? breaking MODULES for each system breaks it...
done

if [ "$prefix" != '/' ] ; then
	tmp_cmdsnames="$cmdsnames"
	cmdsnames=""
	for modul in $tmp_cmdsnames; do
		realrootrequired=0
		for real_root_modul in $MODULES_REAL_ROOT_ONLY; do
			[ "$modul" == "$real_root_modul" ] && realrootrequired=1
		done
		[ $realrootrequired -eq 0 ] && cmdsnames="$cmdsnames $modul"
	done
fi

for modul in $cmdsnames; do
	case $modul in
		#		uname)              eval "Module_Cmd_${modul}";;
		terminal|\
			network|\
			distro|\
			devices|\
			users|\
			processor|\
			system|\
			lsmod|\
			hdd|\
			printers|\
			oem|\
			applications) Module_${modul};;
	esac
done
#		lsmod|\		# is very alpha, do not uncomment

[ "$usekdialog" -ne 1 ]  #&& print_line


############################################
# IF OUTPUTTING TO XMLFILE, PRINT FOOTER

if [ "$usexml" == 1 ]; then
	echo "</osinfo>" | tee -a  $XMLFILE
	echo "EOF" >> $XMLFILE
fi
############################################


############################################
# FINALLY SEND OVER TCP IS OPTION IS SET
if [ "$netcat" == "1" ]; then
	cat $XMLFILE | nc $HOST $PORT
fi
############################################

