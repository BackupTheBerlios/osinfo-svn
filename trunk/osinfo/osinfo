#!/usr/bin/env bash
#################################################################################
# OSINFO
#
# osinfo lists system information available to the OS.
# see `man osinfo` for details.
#
#################################################################################
# Written by Arvid Norlander and Mikael Lammentausta                            #
#                                                                               #
# Some parts are taken from:                                                    #
#   --Advanced Bash Scripting Guide (ABS)                                       #
#################################################################################
appname='osinfo'
major_version=0
minor_version=2
micro_version=9
patch_version=2
dev_status=alpha
release_date='2006-08-xx'

# source the necessary files
source osinfo.modules
source bash.functions
source xml.functions
source lanforce.functions

# guess the operating system
SYSTEM="$(uname -s  | tr 'A-Z' 'a-z' )"
#if [ ! "$(echo $SYSTEM | grep 'linux')" ] | [ ! "$(echo $SYSTEM | grep bsd)" ]; then
# freebsd doesn't understand '||' or evaluation, but it's not required
# NOTE: AnMaster: If you realy use bash it *should* understand ||.
#	echo "This script has not been tested on other operating systems than Linux and FreeBSD."
#	echo
#	exit 0;
#fi


# On *BSD, coreutils are prepended with 'g' to imply 'GNU'
# http://www.freebsd.org/cgi/url.cgi?ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/ports/sysutils/coreutils/pkg-descr
if [ "$(grep bsd <<< "$SYSTEM")" ]; then
	function seq() {
		gseq "$@"
	}
fi


# initialize global variables
isverbose=0
isdebug=0
usekdialog=0
lanforce=0
usexml=0
fake=0
dev_code=0
quiet=0
# The root dir.
# To put this in a variable allows info on non-running systems
prefix="/"
XMLFILE="osinfo.xml"
error_log="/var/log/osinfo.log"


function PRINT_Help {
	local MODULE
	print_line
	echo "${header}${appname} displays information about the system${tSTD}"
	echo
	echo "Arguments are names of modules to get info from:"
	echo
	if [ "$SYSTEM" == "linux" ] ; then
		for MODULE in ${MODULES_LINUX}; do
			echo -e "\t$MODULE"
		done
	elif [ "$(grep bsd <<< "$SYSTEM")" ]; then
		for MODULE in ${MODULES_BSD}; do
			echo -e "\t\t$MODULE"
		done
	fi
	echo
	echo 'If arguments is "all" then list information from all modules'
	echo
	echo "${tBOLD}Syntax:${tSTD}"
	echo "  $(basename $0) [Options] arguments"
	echo "  $(basename $0) [--usage|--help]"
	echo "${tBOLD}Options:${tSTD}"
	echo "       --xml               Printout in xml format to osinfo.xml"
	echo "       --lanforce          Makes the output to osinfo.xml according to a special DTD"
	echo "  -o   --output [file]     Use this file for xml output"
	echo "  -v   --verbose           Show more information"
	echo "  -vv  --veryverbose       Show even more information"
	echo "       --debug             For testing"
	echo "  -D   --fulldebug         Print full debugging info, clutters output!"
#	echo "       --kdialog           Show the information using KDialog"
#	echo "                           from KDE. Experimental feature!"
#	echo "                           Not usable yet!"
	echo "  -P   --prefix [dir]      Use this dir as root"
	echo "                           This disables some modules"
	echo "  -V   --version           Shows the version of ${tBOLD}${appname}${tSTD}"
	echo "                           and exits"
	echo
	print_line
	if [ "$1" ]; then
		exit $1
	else
		exit 0
	fi
}


function Check_logfile {
	if [ ! -e "$error_log" ]; then
		if [ ! $(touch "$error_log") ]; then
			info	"Could not create log file $error_log."
		fi
	fi

	if [ ! -w "$error_log" ]; then
		info	"Log file is not writable by you."
	fi
}


######## SETTING USERSPACE VARIABLES
#
# Before we break path hash some binaries so the script can find them (if they exist).
hash kdialog &>/dev/null
# PATH here allows normal users to run ifconfig and lsmod
export PATH=$PATH:/bin/:/sbin/:/usr/bin/:/usr/sbin/
# LC_ALL makes is possible to print to stdout, due to support for '' :)
#[[ ! "$LC_ALL" ]] && export LC_ALL="en_GB"


####### PARSE THE COMMAND LINE ARGUMENTS
if [ "$#" -gt 0 ]; then
	while [ "$#" -gt 0 ]; do
		case "$1" in
			'--help'|'-help'|'--usage'|'-usage'|'-h'|'')
				PRINT_Help
				;;
			'-P'|'--prefix')
				if [ $2 ]; then
					# Make sure there is only one ending "/".
					prefix="$(echo $2 | sed 's/\/*$/\//')"
					shift 2
				else
					missing_arg "$1"
				fi
				;;
			'--kdialog')
				usekdialog=1
				shift 1
				;;
			'--xml')
				usexml=1
				shift 1
				;;
			'-o'|'--output')
				if [ $2 ]; then
					usexml=1
					XMLFILE="${2}"
					shift 2
				else
					missing_arg "$1"
				fi
				;;
			'--lanforce')
				usexml=1
				lanforce=1
				shift 1
				;;
			'--nc'|'--netcat')
				if [ "$2" ] && [ "$3" ]; then
					usexml=1
					netcat=1
					HOST="$2"
					PORT="$3"
					shift 3
				else
					echo "You must set the target host and port!"
					missing_arg "$1" 2
				fi
				;;
			'-v'|'--verbose')
				isverbose=1
				shift 1
				;;
			'-vv'|'--very-verbose')
				isverbose=2
				shift 1
				;;
			'-D'|'--fulldebug')
				export isdebug=1
				set -x
				shift 1
				;;
			'--debug')
				export isdebug=1
				shift 1
				;;
			'--dev')
				# for using the developement option to debug stuff
				export dev_code=1
				shift 1
				;;
			'--fake')
				# for faking input from files to debug stuff, for example
				# LVM drives when no such drives are available
				export fake=1
				shift 1
				;;
			'--quiet'|'-q')
				quiet=1
				shift 1
				;;
			'-V'|'--version')
				echo "${tBOLD}${appname}${tSTD}-${major_version}.${minor_version}.${micro_version}-${patch_version} ${dev_status}"
				[ "$dev_status" == "stable" ] && \
				echo "Release date: "$(date -d $release_date +%A\ %e\ %B\ %Y)
				echo 'Copyright (C) 2005-2006 Arvid Norlander'
				echo 'Copyright (C) 2006 Mikael Lammentausta'
				echo "This is free software; see the source for copying conditions.  There is ${tBOLD}NO"
				echo "warranty${tSTD}; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
				echo
				exit 0;
				;;
			*)
				cmdsnames="$cmdsnames $1"
				shift 1;
				;;
		esac
	done
else
	PRINT_Help
fi


############################################
# XML HEADER & FOOTER FUNCTIONS
# -----------------------------

function print_xml_header () {
	if [ "$lanforce" == 1 ]; then

		# AnMaster: To produce valid XML that *needs* to be "entityset"...
		xml_doc_start 'entityset' 'SYSTEM' 'lanforce.dtd' > "${XMLFILE}"
		ip="$(ifconfig $interface_name | \
			grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | \
			grep -Eo '[0-9\.]+' )"
		lf_entity_start "$(hostname)" "$ip" >> "${XMLFILE}"

	else

		xml_doc_start 'osinfo' 'SYSTEM' 'osinfo.dtd' > "${XMLFILE}"
		#xml_tag_start "${appname}" >> "${XMLFILE}"
		xml_param_tag "${appname} version" "${major_version}.${minor_version}.${micro_version}-${patch_version} ${dev_status}" >> "${XMLFILE}"
		XML_INDENT=1

	fi
}

function print_xml_footer () {
	if [ "$lanforce" == 1 ]; then
		lf_entity_stop >> "${XMLFILE}"
		#lf_note
	else
		xml_tag_stop "${appname}" >> "${XMLFILE}"
	fi
}
############################################


###########################################################################
# module_header(), module_footer()
# --------------------------------
#
# Print module header
# Parameters:
#   1 string	Module name
module_header() {
	if [ "$usekdialog" == '1' ]; then
		k_title="$1"
	elif [ $usexml -eq 1 ]; then

		# make valid xml tag
		xml_tag="$(validate_xml_item "${1}")"
		add_header "${xml_tag}"

	else
		print_line
		echo "${tcRED}${tUNDERLINE}Report from module${tSTD}${tUNDERLINE} ${tcBLUE}$@${tSTD}:"
	fi
}

# Print module footer (for xml)
# Parameters:
#   1 string   Module name
module_footer() {
	value_footer
}
################################################################################




###########################################################################
# add_header(), add_footer(), add_attribute(), add_values(), flush_values()
# -------------------------------------------------------------------------
# these are a group of functions that are used by the modules to formulate the output.
#
# flush_values calls either print_xml, print_lanforce_xml or print_stdout
# depending on the parameters the user has set during invocations of osinfo.
#
# the other functions use the $infostring[] to store the information
# collected by the modules. the format of this array is like:
# [%header%System information] [%attribute%Operating system;os] [Linux]
# detailed information is given in each function.


############################
# add_header, add_nc_header
#
# this function inserts the input string as the last available item
# in the $infostring array. it also adds a %header% tag which will be
# use by print_* functions to interpret how to parse the string.
#
# Parameters: (example eth0)
#   1 the header. will be printed to stdout and without $2 to xml as <eth0>
#   2 xml syntax modifier. if "iface name", then xml tag will be <iface name="eth0">
function add_header() {
	infostring[${#infostring[@]}]="%header%${1};${2}"
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
	OpenHeaders=("${OpenHeaders[@]}" "${1};${2}")
}
# same as above, but without color. some modules use this because of
# a bug in the 'column' program
#
# Parameters: (example eth0)
#   1 the header. will be printed to stdout and without $2 to xml as <eth0>
#   2 xml syntax modifier. if "iface name", then xml tag will be <iface name="eth0">
function add_nc_header() {
	infostring[${#infostring[@]}]="%nc_header%${1};${2}"
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
	OpenHeaders=("${OpenHeaders[@]}" "${1};${2}")
}


##############
# add_footer
#
# adds a footer tag to infostring.
# Parameters:
#  1 xml closing tag <string> (optional)
# if no parameter is given, close last open header.
function add_footer() {
	if [ "$1" ]; then
		infostring[${#infostring[@]}]="%footer%${@}"
		# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
	else
		close_last_header
	fi

	unset OpenHeaders[$((${#OpenHeaders[@]}-1))]
}


################
# add_attribute
#
# This function inserts the input string(s) as the last available item
# in the $infostring array, with a field delimiter of ";".
# it also adds an %attribute% tag which will be use by print_* functions
# to interpret how to parse the string.
# Parameters:
#  1 free-form name    (eg. Operating system)   (required)
#  2 code tag for xml  (eg. os)                 (optional)
function add_attribute() {
	infostring[${#infostring[@]}]="%attribute%${1};${2}"
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}


#############
# add_values
#
# This function inserts the input string or strings into the $infostring[] array.
function add_values {
	infostring[${#infostring[@]}]="%value%${@}"
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}

###################
# add_value_footer
#
# This function inserts a value_footer, which indicates a dimension, eg. <footer>kB/s</footer>.
function add_value_footer {
	infostring[${#infostring[@]}]="%value_footer%${@}"
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}


################
# flush_values
#
# calls the print functions and clears the $infostring
function flush_values {
	# close all open headers
	local hdr
	for hdr in $(seq ${#OpenHeaders[@]} -1 1); do
		((hdr--)) # correct offset
		add_footer "${OpenHeaders[$hdr]}"
	done

	if [ "$usexml" == "0" ]; then
		print_stdout
	elif [ "$usexml" == "1" ] && [ "$lanforce" == "0" ]; then
		print_xml
	else
		print_lanforce_xml
	fi

	# infostring is set at functions add_*
	# and needs to be reset here so that the informaton
	# from this module will not be reprinted later
	unset infostring
}
###########################################################################



###########################################################################
# helper functions
# ----------------

# this function searches the $infostring array backwards,
# looking for open headers. this is called from add_footer.
function close_last_header() {
	local IFS_bak="$IFS"
	IFS=$' \t\n'

	local found="" position item
	for position in $(seq ${#infostring[@]} -1 0); do
		item="${infostring[$position]}"
		# first collect %footer%s into $found array
		if [ "$(grep '^%footer%' <<< "${item}")" ]; then
			found="$(grep '^%footer%' <<< "${item}" | sed s/%footer%//)"

		# then continue and add a footer if it is not already found
		elif [ "$(grep '^%header%' <<< "${item}")" ]; then
			item="$(sed "s/%header%//" <<< "${item}")"

			if [ "${item}" != "${found}" ]; then
			#found[${#found[@]}]="$(echo ${item} | \
			#	grep '^%header%' | sed s/%header%/%footer%/)"
			# then test if this has
			#echo $found
				infostring[${#infostring[@]}]="%footer%${item}"
				# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
				break;
			fi
		fi
	done

	IFS="$IFS_bak"

	#for VL in $(seq 0 ${#infostring[@]}); do
	#	echo ${infostring[$VL]}
	#done
}

# this is used for informational sentences in case of errors, warnings, notes etc.
function info {
	infostring[${#infostring[@]}]="%info%${@}"
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}
#################################################################


################################################################################
# print_xml(), print_lanforce_xml(), print_stdout()
# -------------------------------------------------
# this set of functions formulates the items in $infostring for output.
# detailed information is given in each function.


# This function formulates $infostring for stdout
# header tags are printed; attribute names are printed;
# values for each attribute are printed on the same line,
# and indentation is formed with the 'column' tool.
function print_stdout {
	local header_color="${tcGREEN}"
	local info_color="${tcYELLOW}"
	local item itemnr value_string=""

	for itemnr in $(seq 1 1 ${#infostring[@]} ); do
		((itemnr--)) # correct offset to start at zero
		item="${infostring[$itemnr]}"
		# case by the "%identifier%" tag
		case $(awk -F% {'print $2'} <<< ${item}) in

			'value')
				# add item to the value string,
				# leaving the value identifier in
				value_string="${value_string}${item}";
			;;

			'value_footer')
				# strip tag and discard the xml code tag
				item="$(sed s/%value_footer%// <<< "${item}" )"
				# add item to the value string,
				# the preceding space is intentional.
				value_string="${value_string} ${item}";
			;;

			'attribute')
				# strip tag and discard the xml code tag
				item="$(sed s/%attribute%// <<< "${item}" | \
				        awk -F\; {'print $1'})"
				# add item to the value string,
				# each attribute starts with a newline
				value_string="${value_string}\n${item}";
			;;

			'header')
				# strip tag, do not care of the xml modifier
				item="$(sed 's/%header%//' <<< "${item}" | \
				        awk -F\; {'print $1'} )"
				# add item to the value string,
				# each header starts with a newline,
				# and is printed in special color
				value_string="${value_string}\n${header_color}${item}${tSTD}";
			;;

			'nc_header')
				# strip tag
				item="$(sed s/%nc_header%// <<< "${item}" | \
				        awk -F\; {'print $1'} )"
				# add item to the value string,
				# each header starts with a newline,
				# and is printed in special color
				value_string="${value_string}\n${item}";
			;;

			'info')
				# strip tag
				item="$(sed s/%info%// <<< "${item}")"
				# add item to the value string,
				# each info note starts with a newline,
				# and is printed in special color
				value_string="${value_string}\n${info_color}${item}${tSTD}";
			;;

		esac
	done

	# EXPLANATION OF THE INDENTATION SOLUTION
	# this is a trick to overcome the limitation in column;
	# use the special character '$' as the column delimiter, since
	# it won't accept a string. the character _has_ to be ascii-standard.
	# the column delimiter can be %value% or %col%

	# the bad thing is that column interprets color codes as characters,
	# and using colours on $value_string messes up column.

	echo -e $(sed 's/%value%\|%col%/\$/g' <<< ${value_string}) | column -t -s$ 
}


# This function loops the $infostring and does a case on each item
function print_xml {
	local item itemnr code idtag value_item
	attrib_status="closed"

	for itemnr in $(seq 1 1 ${#infostring[@]} ); do

		((itemnr--)) # correct offset to start at zero

		item="${infostring[$itemnr]}"
		idtag="$(awk -F% {'print $2'} <<< ${item})"

		# case by the "%identifier%" tag
		case $idtag in

			'value_footer')
				## add indentation
				for indent in $(seq 1 1 $XML_INDENT); do
					echo -ne "\t" >> "${XMLFILE}"
				done

				# strip tag and discard the xml code tag
				item="$(sed s/%value_footer%// <<< "${item}" )"
				# send the preceding value and the footer to xmlfile.
				xml_value "$value_item ${item}" >> "${XMLFILE}"
				unset value_item
			;;

			*)

				# if the value item is set (no footer), then print
				if [ "$value_item" ]; then
					## add indentation
					for indent in $(seq 1 1 $XML_INDENT); do
						echo -ne "\t" >> "${XMLFILE}"
					done

					xml_value "$value_item" >> "${XMLFILE}"
					unset value_item
				fi


				case $idtag in

				'value')
					# the following sed removes all formatting tags
					# from the value string. it's a tad slow, though.
					# put value_item on hold for value_footer
					value_item="$(sed 's/%value%// ; s/\\[a-z]//g;s/^ *//' <<< "${item}")"

					#xml_value "${item}" >> "${XMLFILE}"
				;;

				*)

					if [ "$attrib_status" == "open" ]; then
						close_attribute_tag
					fi

					case $idtag in

						'attribute')
							open_attribute_tag "$item"
						;;

						'header')
							## add indentation
							for indent in $(seq 1 1 $XML_INDENT); do
								echo -ne "\t" >> "${XMLFILE}"
							done

							# strip tag
							item="$(sed s/%header%// <<< "${item}")"
							code="$(awk -F\; {'print $2'} <<< "${item}" )"
							item="$(awk -F\; {'print $1'} <<< "${item}" )"
							item="$(validate_xml_item "${item}")"

							# modify xml output due to contents of $item
							if [ "$code" != "" ]; then
								xml_param_tag "${code}" "${item}" >> "${XMLFILE}"
							else
								xml_tag_start "${item}" >> "${XMLFILE}"
							fi

							unset code
							((XML_INDENT++))
						;;

						'footer')
							((XML_INDENT--))
							## add indentation
							for indent in $(seq 1 1 $XML_INDENT); do
								echo -ne "\t" >> "${XMLFILE}"
							done

							# strip tag
							item="$(sed s/%footer%// <<< "${item}")"
							item="$(validate_xml_item "${item}")"
							xml_tag_stop "${item}" >> "${XMLFILE}"
						;;
					esac
				esac
			;;
		esac
	done
}

#############################
## print_xml helper functions
	close_attribute_tag() {
		### CLOSE ATTRIBUTE TAG
		## add indentation
		((XML_INDENT--))
		for indent in $(seq 1 1 $XML_INDENT); do
			echo -ne "\t" >> "${XMLFILE}"
		done

		xml_attribute_stop >> "${XMLFILE}"
		echo >> "${XMLFILE}"
		attrib_status="closed"
	}

	open_attribute_tag() {
		for indent in $(seq 1 1 $XML_INDENT); do
				echo -ne "\t" >> "${XMLFILE}"
		done

		# parse item
		item="$(sed s/%attribute%// <<< "${item}")"
		code=$(awk -F\; {'print $2'} <<< "${item}")
		# item validation strips away the code
		item="$(validate_xml_item "${item}")"
		xml_attribute_start "${item}" "${code}" >> ${XMLFILE}
		((XML_INDENT++))
		attrib_status="open"
	}

	validate_xml_item() {
		awk -F\; {'print $1'} <<< "${1}" | \
			sed 's/\\[a-z]//g; s/\ \|\//_/g' | tr 'A-Z' 'a-z'
	}
#######


# This function prepares the output xml to conform to the LanForce dtd.
# LanForce is a commercial company who hired a dev to do this script
# and that dev continued on an existing script.
# works pretty much the same as print_xml()
print_lanforce_xml() {
	local item itemnr code
	attrib_status="closed"

	for itemnr in $(seq 1 1 ${#infostring[@]} ); do

		((itemnr--)) # correct offset to start at zero

		item="${infostring[$itemnr]}"
		idtag="$(awk -F% {'print $2'} <<< ${item})"

		# case by the "%identifier%" tag
		case $idtag in

			'value')
				# only print value for an attribute that is printed!
				if [ "$attrib_status" == "open" ]; then
					# the following sed removes all formatting tags
					# from the value string. it's a tad slow, though.
					item="$(sed 's/%value%// ; s/\\[a-z]//g;s/^ *//' <<< "${item}")"
					# echo three spaces as indentation
					echo -ne "   " >> "${XMLFILE}"
					xml_value "${item}" >> "${XMLFILE}"
				fi
			;;

			'value_footer')

				if [ "$attrib_status" == "open" ]; then
					# strip tag and discard the xml code tag
					item="$(sed s/%value_footer%// <<< "${item}" )"
					# add item to the value string,
					# the preceding space is intentional.
					lf_value_footer "${item}" >> "${XMLFILE}"
				fi
			;;

			'attribute')
				# parse item
				item="$(sed s/%attribute%// <<< "${item}")"
				code=$(awk -F\; {'print $2'} <<< "${item}")

				if [ "$attrib_status" == "open" ]; then
					close_lf_attribute_tag
				fi

				if [ "$code" != "" ]; then
					name=$(awk -F\; {'print $1'} <<< "${item}")

					echo -ne "  " >> "${XMLFILE}"
					xml_attribute_start "${name}" "${code}" >> "${XMLFILE}"

					attrib_status="open"
				fi
			;;
		esac
	done

	[ "$attrib_status" == "open" ] && close_lf_attribute_tag
}
#############################
## print_lanforce_xml helper functions
	close_lf_attribute_tag() {
		### CLOSE ATTRIBUTE TAG
		## add indentation

		echo -ne "  " >> "${XMLFILE}"
		xml_attribute_stop >> "${XMLFILE}"
		attrib_status="closed"
	}
#######
################################################################################



################################################################################
# Module functions
# ------------------------------------------------------------------------------
wrong_module() {
	do_abort "${1} is not a valid module!" 1
}



#######################
# THE "MAIN" FUNCTION
#
# this is the place to put all env variables to be set for some module
Check_logfile
for modul in $cmdsnames; do

	# TODO: check that the module being called is supported on the running OS

	# TODO: something like this to not even attempt to run REQ_ROOT modules
	#       as normal user, but shouldn't burden the script too much
	#       with excessive loops
	#allowed_modules=''
	#if ! CheckReq_root; then
	#	allowed_modules=$MODULES_ALL-$MODULES_SU_ONLY
	#fi

	if [ $modul = 'all' ]; then
		if [ "$SYSTEM" == "linux" ] ; then
			#cmdsnames="$MODULES_LINUX"
			break
		# TODO: please check if this works on bsd and old bash
		elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then
			#cmdsnames="$MODULES_BSD"
			break
		fi
	elif [ $modul = 'lanforce' ]; then
		lanforce=1
		usexml=1
		#cmdsnames="$MODULES_LANFORCE"
		break
	fi

	validate_arg "$modul" "$MODULES_ALL $MODULES_META" || wrong_module "$modul"
	# validate_arg is called to check that the module exits at all.
	# AnMaster: If we DON'T validate user input *and* use eval below we
	#           are *realy* stupid. So don't comment that out.
	#           Instead update the variable MODULES_ALL in osinfo.modules
	#           We MUST validate the user input if we are going to use eval
	#           otherwise someone could use that to run something evil
	#           (as root), like rm -rf /.

done

if [ "$prefix" != '/' ] ; then
	tmp_cmdsnames="$cmdsnames"
	cmdsnames=""
	for modul in $tmp_cmdsnames; do
		realrootrequired=0
		for real_root_modul in $MODULES_REAL_ROOT_ONLY; do
			[ "$modul" == "$real_root_modul" ] && realrootrequired=1
		done
		[ $realrootrequired -eq 0 ] && cmdsnames="$cmdsnames $modul"
	done
fi

if [ "$usexml" == 1 ]; then
	print_xml_header
fi

if [ -z "$cmdsnames" ]; then
	PRINT_Help
fi

# this calls the module definitions. as there are Meta-modules
# and the actual modules, we first check if there's a Meta-module
# of that name. in that case, it is used.
for module in $cmdsnames; do

	# AnMaster: What the hell are you doing... why not use a case .. esac statment like we did before?
	#           that would solve it.
	# ruxpin: that would require a modification to this list after adding a module,
	#         which I want to avoid.
	# AnMaster: local modulename="Meta_${module}"
	#           metamod="${!modulename}"
	#           Needs bash 3 at least.
	#           Or base it on some declare magic.
	eval metamod="\${Meta_${module}}"

	if [ "$(echo $metamod)" ]; then

		for submodule in $metamod; do

			Module_${submodule}

		done

	else

		Module_${module}

	fi

done

#[ "$usekdialog" -ne 1 ]  #&& print_line

if [ "$usexml" == 1 ]; then
	print_xml_footer
elif [ "$usekdialog" -ne 1 ]; then
	print_line
fi

# Remove temporary files:
cleanup_temp_files

############################################
# FINALLY SEND OVER TCP IF THE OPTION IS SET
if [ "$netcat" == "1" ]; then
	cat "${XMLFILE}" | nc "$HOST" "$PORT"
elif [ $usexml -eq 1 ] && [ $quiet -ne 1 ]; then
	cat "${XMLFILE}"
fi
############################################

# exit cleanly
exit 0
