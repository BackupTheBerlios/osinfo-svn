#!/usr/bin/env bash
#################################################################################
# OSINFO
#
# osinfo lists system information available to the OS.
# see `man osinfo` for details.
#
#################################################################################
# Written by Arvid Norlander and Mikael Lammentausta                            #
#                                                                               #
# Some parts are taken from:                                                    #
#   --Advanced Bash Scripting Guide (ABS)                                       #
#################################################################################
appname='osinfo'
major_version=0
minor_version=2
micro_version=9
patch_version=9
dev_status=alpha
release_date='2006-09-xx'

#############################################################
##
# source the necessary files

source modules/osinfo.modules
source modules/cdrom
source modules/devices

source lib/bash.functions         # colour & line functions
source lib/PRINT_Help             # print --help 
source lib/PRINT_Version          # print --version

source lib/xml.functions          # xml tag codes
source lib/xslt.functions         # xslt generation 
source lib/lanforce.functions     # lanforce xml tag codes

source lib/infostring.functions   # infostring handler functions

source lib/check.functions        # check various functionalities
source lib/cmdline	              # command line options, leave last!

[ -e "/etc/osinfo.conf" ] && \
. /etc/osinfo.conf                # the configuration file

#############################################################


# make a guess of the operating system
SYSTEM="$(uname -s  | tr 'A-Z' 'a-z' )"
#if [ ! "$(echo $SYSTEM | grep 'linux')" ] | [ ! "$(echo $SYSTEM | grep bsd)" ]; then
# freebsd doesn't understand '||' or evaluation, but it's not required
# NOTE: AnMaster: If you realy use bash it *should* understand ||.
#	echo "This script has not been tested on other operating systems than Linux and FreeBSD."
#	echo
#	exit 0;
#fi


function netcat() {
	if [ "$(type -p netcat)" ]; then
		netcat "$@"
	elif [ "$(type -p nc)" ]; then
		nc "$@"
	else
		info "netcat binary not found!"
		exit 1
	fi
}
# On *BSD, coreutils are prepended with 'g' to imply 'GNU'
# http://www.freebsd.org/cgi/url.cgi?ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/ports/sysutils/coreutils/pkg-descr
if [ "$(grep bsd <<< "$SYSTEM")" ]; then
	Meta_all="$MODULES_BSD"
	function seq() {
		gseq "$@"
	}
	function date() {
		gdate "$@"
	}
fi

######## SETTING USERSPACE VARIABLES
isverbose=0
isdebug=0
usekdialog=0
lanforce=0
usexml=0
fake=0
dev_code=0
quiet=0
tcpdaemon=0
tcpsend=0
# The root dir.
# To put this in a variable allows info on non-running systems
prefix="/"

#XMLFILE="$(get_hostname)_$(get_mac_address).xml"
XMLFILE="$(get_hostname).xml"
XSLFILE="osinfo.xsl.debug"
rm "$XSLFILE" -f

# if the conf file is not available..
[ ! "$error_log" ] && error_log="/var/log/osinfo.log"
[ ! "$rundir" ] && rundir="/var/run/osinfo"


# Before we break path hash some binaries so the script can find them (if they exist).
hash kdialog &>/dev/null
# PATH here allows normal users to run ifconfig and lsmod
export PATH=$PATH:/bin/:/sbin/:/usr/bin/:/usr/sbin/
# LC_ALL makes is possible to print to stdout, due to support for '' :)
#[[ ! "$LC_ALL" ]] && export LC_ALL="en_GB"





############################################
# XML HEADER & FOOTER FUNCTIONS
# -----------------------------
function print_xml_header () {
	# initialize variables (ip, hostname, date)

	local ip="$(ifconfig $interface_name | \
		grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | \
		grep -Eo '[0-9\.]+' | head -n 1)"

    local timestamp="$(date +%Y-%m-%d\ %H:%M:%S)"

	local hostname="$(hostname 2> /dev/null)" 

	###############
	# STANDARD XML
	if [ $lanforce -eq 0 ]; then

		#!DOCTYPE
		xml_doc_start 'osinfo' 'SYSTEM' 'osinfo.dtd' > "${XMLFILE}"

		# osinfo
		xml_tag_start "${appname}" >> "${XMLFILE}"

		XML_INDENT=1

		# osinfo version
		add_indentation
		xml_param_tag_closed "${appname} version" \
		"${major_version}.${minor_version}.${micro_version}-${patch_version} ${dev_status}" >> "${XMLFILE}"

		# hostname
		add_indentation
		xml_param_tag_closed "client hostname" "$(get_hostname)" >> "${XMLFILE}"

		# IP address
		add_indentation
		xml_param_tag_closed "ip v4" "${ip}" >> "${XMLFILE}"

		# profile
		add_indentation
		profile="desktop"
		xml_param_tag_closed "computer profile" "${profile}" >> "${XMLFILE}"

		# scanning date
		add_indentation
		xml_param_tag_closed "scanning date" "${timestamp}" >> "${XMLFILE}"

	###############
	# LANFORCE XML
	elif [ $lanforce -eq 1 ]; then

		# AnMaster: To produce valid XML that *needs* to be "entityset"...
		xml_doc_start 'entityset' 'SYSTEM' 'lanforce.dtd' > "${XMLFILE}"
		lf_entity_start "$hostname" "$ip" >> "${XMLFILE}"

	fi
}

function print_xml_footer () {
	if [ "$lanforce" == 1 ]; then
		lf_entity_stop >> "${XMLFILE}"
		#lf_note
	else
		xml_tag_stop "${appname}" >> "${XMLFILE}"
	fi
}
############################################




################################################################################
# print_xml(), print_lanforce_xml(), print_stdout()
# -------------------------------------------------
# this set of functions formulates the items in $infostring for output.
# detailed information is given in each function.


# This function formulates $infostring for stdout
# header tags are printed; attribute names are printed;
# values for each attribute are printed on the same line,
# and indentation is formed with the 'column' tool.
function print_stdout {
	local header_color="${tcGREEN}"
	local info_color="${tcYELLOW}"
	local item itemnr value_string=""

	for itemnr in $(seq 1 1 ${#infostring[@]} ); do
		((itemnr--)) # correct offset to start at zero
		item="${infostring[$itemnr]}"
		# case by the "%identifier%" tag
		case $(awk -F% {'print $2'} <<< ${item}) in

			'value')
				# add item to the value string,
				# leaving the value identifier in
				value_string="${value_string}${item}";
			;;

			'value_footer')
				# strip tag and discard the xml code tag
				item="$(sed s/%value_footer%// <<< "${item}" )"
				# add item to the value string,
				# the preceding space is intentional.
				value_string="${value_string} ${item}";
			;;

			'attribute')
				# strip tag and discard the xml code tag
				item="$(sed s/%attribute%// <<< "${item}" | \
				        awk -F\; {'print $1'})"
				# add item to the value string,
				# each attribute starts with a newline
				value_string="${value_string}\n${item}";
			;;

			'header')
				# strip tag, do not care of the xml modifier
				item="$(sed 's/%header%//' <<< "${item}" | \
				        awk -F\; {'print $1'} )"
				# add item to the value string,
				# each header starts with a newline,
				# and is printed in special color
				value_string="${value_string}\n${header_color}${item}${tSTD}";
			;;

			'nc_header')
				# strip tag
				item="$(sed s/%nc_header%// <<< "${item}" | \
				        awk -F\; {'print $1'} )"
				# add item to the value string,
				# each header starts with a newline,
				# and is printed in special color
				value_string="${value_string}\n${item}";
			;;

			'info')
				# strip tag
				item="$(sed s/%info%// <<< "${item}")"
				# add item to the value string,
				# each info note starts with a newline,
				# and is printed in special color
				value_string="${value_string}\n${info_color}${item}${tSTD}";
			;;

		esac
	done

	# EXPLANATION OF THE INDENTATION SOLUTION
	# this is a trick to overcome the limitation in column;
	# use the special character '$' as the column delimiter, since
	# it won't accept a string. the character _has_ to be ascii-standard.
	# the column delimiter can be %value% or %col%

	# the bad thing is that column interprets color codes as characters,
	# and using colours on $value_string messes up column.

	echo -e $(sed 's/%value%/\$/g ; s/%col%/\$/g' <<< ${value_string}) | \
	          column -t -s$ 
}


# This function loops the $infostring and does a case on each item
function print_xml {
	local item itemnr code idtag iddesc value_item
	attrib_status="closed"

	# if you want to hack this, look at the case structure.
	# it is hierarchic because values may have footers, and
	# the attribute shouldn't be closed before the proper footer
	# is already added.. sorry for the confusion :)

	for itemnr in $(seq 1 1 ${#infostring[@]} ); do

		((itemnr--)) # correct offset to start at zero

		item="${infostring[$itemnr]}"
		idtag="$(awk -F% {'print $2'} <<< ${item})"

		# case by the "%identifier%" tag
		case $idtag in

			# adds the footer (value dimension)
			'value_footer')
				add_indentation

				# strip tag and discard the xml code tag
				item="$(sed s/%value_footer%// <<< "${item}" )"
				# send the preceding value and the footer to xmlfile.
				xml_value "$value_item ${item}" >> "${XMLFILE}"
				unset value_item
			;;

			# add everything else but the footer
			*)
				# if the value item is set (no footer), then print value
				if [ "$value_item" ]; then
					add_indentation

					xml_value "$value_item" >> "${XMLFILE}"
					unset value_item
				fi

				# another case, which prints most everything
				case $idtag in

				'value')
					# the following sed removes all formatting tags
					# from the value string. it's a tad slow, though.
					# put value_item on hold for value_footer
					value_item="$(sed 's/%value%// ; s/\\[a-z]//g;s/^ *//' <<< "${item}")"

					#xml_value "${item}" >> "${XMLFILE}"
				;;

				*)

					# no more values, then close attribute tag
					if [ "$attrib_status" == "open" ]; then
						close_attribute_tag
					fi

					case $idtag in

						'attribute')
							iddesc="$(awk -F% {'print $3'} <<< ${item})"
							iddesc="$(awk -F\; {'print $1'} <<< ${iddesc})"
							open_attribute_tag "$item"

							add_indentation
							xml_description "$iddesc" >> "${XMLFILE}"
						;;

						'header')
							## add indentation
							add_indentation

							# strip tag
							item="$(sed s/%header%// <<< "${item}")"
							code="$(awk -F\; {'print $2'} <<< "${item}" )"
							item="$(awk -F\; {'print $1'} <<< "${item}" )"
							item="$(validate_xml_item "${item}")"

							# modify xml output due to contents of $item
							if [ "$code" != "" ]; then
								xml_param_tag "${code}" "${item}" >> "${XMLFILE}"
							else
								xml_tag_start "${item}" >> "${XMLFILE}"
							fi

							unset code
							((XML_INDENT++))
						;;

						'footer')
							((XML_INDENT--))
							add_indentation

							# strip tag
							item="$(sed s/%footer%// <<< "${item}")"
							item="$(validate_xml_item "${item}")"
							xml_tag_stop "${item}" >> "${XMLFILE}"
						;;
					esac
				esac
			;;
		esac
	done
}

#############################
## print_xml helper functions
	add_indentation() {
		for indent in $(seq 1 1 $XML_INDENT); do
			echo -ne "\t" >> "${XMLFILE}"
		done	
	}

	close_attribute_tag() {
		### CLOSE ATTRIBUTE TAG
		## add indentation
		((XML_INDENT--))
		add_indentation

		xml_attribute_stop >> "${XMLFILE}"
		echo >> "${XMLFILE}"
		attrib_status="closed"
	}

	open_attribute_tag() {
		add_indentation

		# parse item
		item="$(sed s/%attribute%// <<< "${item}")"
		code=$(awk -F\; {'print $2'} <<< "${item}")
		# item validation strips away the code
		item="$(validate_xml_item "${item}")"
		xml_attribute_start "${item}" "${code}" >> ${XMLFILE}
		((XML_INDENT++))
		attrib_status="open"
	}

	validate_xml_item() {
		awk -F\; {'print $1'} <<< "${1}" | \
			sed 's/\\[a-z]//g; s/\ \|\//_/g' | tr 'A-Z' 'a-z'
	}
#######


# This function prepares the output xml to conform to the LanForce dtd.
# LanForce is a commercial company who hired a dev to do this script
# and that dev continued on an existing script.
# works pretty much the same as print_xml()
print_lanforce_xml() {
	local item itemnr code
	attrib_status="closed"

	for itemnr in $(seq 1 1 ${#infostring[@]} ); do

		((itemnr--)) # correct offset to start at zero

		item="${infostring[$itemnr]}"
		idtag="$(awk -F% {'print $2'} <<< ${item})"

		# case by the "%identifier%" tag
		case $idtag in

			'value')
				# only print value for an attribute that is printed!
				if [ "$attrib_status" == "open" ]; then
					# the following sed removes all formatting tags
					# from the value string. it's a tad slow, though.
					item="$(sed 's/%value%// ; s/\\[a-z]//g;s/^ *//' <<< "${item}")"
					# echo three spaces as indentation
					echo -ne "   " >> "${XMLFILE}"
					xml_value "${item}" >> "${XMLFILE}"
				fi
			;;

			'value_footer')

				if [ "$attrib_status" == "open" ]; then
					# strip tag and discard the xml code tag
					item="$(sed s/%value_footer%// <<< "${item}" )"
					# add item to the value string,
					# the preceding space is intentional.
					lf_value_footer "${item}" >> "${XMLFILE}"
				fi
			;;

			'attribute')
				# parse item
				item="$(sed s/%attribute%// <<< "${item}")"
				code=$(awk -F\; {'print $2'} <<< "${item}")

				if [ "$attrib_status" == "open" ]; then
					close_lf_attribute_tag
				fi

				if [ "$code" != "" ]; then
					name=$(awk -F\; {'print $1'} <<< "${item}")

					echo -ne "  " >> "${XMLFILE}"
					xml_attribute_start "${name}" "${code}" >> "${XMLFILE}"

					attrib_status="open"
				fi
			;;
		esac
	done

	[ "$attrib_status" == "open" ] && close_lf_attribute_tag
}
#############################
## print_lanforce_xml helper functions
	close_lf_attribute_tag() {
		### CLOSE ATTRIBUTE TAG
		## add indentation

		echo -ne "  " >> "${XMLFILE}"
		xml_attribute_stop >> "${XMLFILE}"
		attrib_status="closed"
	}
################################################################################



################################################################################
# Module functions
# ------------------------------------------------------------------------------
wrong_module() {
	do_abort "${1} is not a valid module!" 1
}



#######################
# THE MAIN FUNCTION
# this runs all checks and generates the print-out
#
# this is the place to put all env variables to be set for some module
run_modules() {
	for modul in $cmdsnames; do

		# TODO: check that the module being called is supported on the running OS

		# TODO: something like this to not even attempt to run REQ_ROOT modules
		#       as normal user, but shouldn't burden the script too much
		#       with excessive loops
		#allowed_modules=''
		#if ! CheckReq_root; then
		#	allowed_modules=$MODULES_ALL-$MODULES_SU_ONLY
		#fi

		if [ $modul = 'all' ]; then
			if [ "$SYSTEM" == "linux" ] ; then
				#cmdsnames="$MODULES_LINUX"
				break
			# TODO: please check if this works on bsd and old bash
			elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then
				#cmdsnames="$MODULES_BSD"
				break
			fi
		elif [ $modul = 'lanforce' ]; then
			lanforce=1
			usexml=1
			#cmdsnames="$MODULES_LANFORCE"
			break
		fi

		validate_arg "$modul" "$MODULES_ALL $MODULES_META" || wrong_module "$modul"
		# validate_arg is called to check that the module exits at all.
		# AnMaster: If we DON'T validate user input *and* use eval below we
		#           are *realy* stupid. So don't comment that out.
		#           Instead update the variable MODULES_ALL in osinfo.modules
		#           We MUST validate the user input if we are going to use eval
		#           otherwise someone could use that to run something evil
		#           (as root), like rm -rf /.

	done

	if [ "$prefix" != '/' ] ; then
		tmp_cmdsnames="$cmdsnames"
		cmdsnames=""
		for modul in $tmp_cmdsnames; do
			realrootrequired=0
			for real_root_modul in $MODULES_REAL_ROOT_ONLY; do
				[ "$modul" == "$real_root_modul" ] && realrootrequired=1
			done
			[ $realrootrequired -eq 0 ] && cmdsnames="$cmdsnames $modul"
		done
	fi

	if [ "$usexml" == 1 ]; then
		print_xml_header
	fi

	if [ -z "$cmdsnames" ]; then
		PRINT_Help
	fi

	# this calls the module definitions. as there are Meta-modules
	# and the actual modules, we first check if there's a Meta-module
	# of that name. in that case, it is used.
	# NOTE: FreeBSD runs all modules
	for module in $cmdsnames; do

		# AnMaster: What the hell are you doing... why not use a case .. esac statment like we did before?
		#           that would solve it.
		# ruxpin: that would require a modification to this list after adding a module,
		#         which I want to avoid.
		# AnMaster: local modulename="Meta_${module}"
		#           metamod="${!modulename}"
		#           Needs bash 3 at least.
		#           Or base it on some declare magic.
		eval metamod="\${Meta_${module}}"

		if [ "$(echo $metamod)" ]; then

			for submodule in $metamod; do

				Module_${submodule}

			done

		else

			Module_${module}

		fi

	done

	#[ "$usekdialog" -ne 1 ]  #&& print_line

	if [ "$usexml" == 1 ]; then
		print_xml_footer
	elif [ "$usekdialog" -ne 1 ]; then
		print_line
	fi

	# Remove temporary files:
	cleanup_temp_files
}


#####################################
## the daemon tcp listening function
#
# listens to a tcp port, writes the input xml 
listen_tcp() {

	PRINT_Version

	if [ $isverbose -ge 1 ]; then
		info "Daemonizing" 
		info "Listening to tcp connections from $tcp_listening_port..."
		info "Press Ctrl-Z to exit" 
		flush_values
	fi

	local hostdir="${rundir}/hosts"
	# create hosts dir if it doesn't exist
	[ ! -e "${hostdir}" ] && mkdir -p "${hostdir}" 

	local clients client_hostname

	# allocate a temp file
    tcp_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
    TempFiles=("${TempFiles[@]}" "$tcp_tmp")

	killall -9 nc

	# in an eternal loop...
	while [ a = a ]; do

		# listen for incoming xml files
		if [ $isverbose -ge 1 ]; then
			netcat -v -l -p $tcp_listening_port > "$tcp_tmp" # which breaks after EOF
		else
			netcat -l -p $tcp_listening_port > "$tcp_tmp" # which breaks after EOF
		fi

		# notify the user of the received file
		[ $isverbose -ge 1 ] && \
			info "$(wc -l $tcp_tmp | grep -Eo '^[0-9]*') lines caught!"

		# if the input is (not) valid osinfo xml..
		if [ ! "$(grep -i '<!doctype osinfo' )" ]; then
			info "Input is not valid osinfo xml!"
			
		else

			# extract hostname from the xml
			client_hostname="$(grep -i 'client hostname' "$tcp_tmp" | \
							   sed 's/[^\"]*\"\([^\"]*\)\"[^.]*/\1/' )"

			# create or update the xml file for the host
			cat "$tcp_tmp" > "${hostdir}/${client_hostname}.xml"
			[ $isverbose -ge 1 ] && \
				info "File '${hostdir}/${client_hostname}.xml' saved"

			# create or update <hostname>.html. 
			# if the specific <hostname>.xsl is not found, use 'generic-host.xsl'
			if [ -e "${hostdir}/${client_hostname}.xsl" ]; then
				xsltproc "${hostdir}/${client_hostname}.xsl" \
						 "${hostdir}/${client_hostname}.xml" > \
						 "${hostdir}/${client_hostname}.html" 2> "$error_log"

			elif [ -e "${hostdir}/generic-host.xsl" ]; then
				xsltproc "${hostdir}/generic-host.xsl" \
						 "${hostdir}/${client_hostname}.xml" > \
						 "${hostdir}/${client_hostname}.html" 2> "$error_log"
			else
				info "No applicaple xsl template files found in '${hostdir}'!"
			fi

			# inform the user
			if [ $isverbose -ge 1 ] && [ -e "${hostdir}/${client_hostname}.html" ]; then
				info "File '${hostdir}/${client_hostname}.html' updated"
			fi

			# create or update index.html
			if [ -e "${rundir}/index.xsl" ]; then

				for clients in "${hostdir}/*.xml"; do

					xsltproc "${rundir}/index.xsl" $clients > \
							 "${rundir}/index.html" 2> "$error_log"

				done
			else
				info "index.xsl template file was not found in '${rundir}'!"
			fi

			# inform the user
			if [ $isverbose -ge 1 ] && [ -e "${rundir}/index.html" ]; then
				info "File '${rundir}/index.html' updated"
			fi

		fi

		flush_values
	
		# :)

	done

	cleanup_temp_files
}


# parse the command line arguments
parse_arguments "${@}"

# do some checks..
Check_logfile
#Check_rundir

# if we're not running in tcp daemon mode, call the main function
if [ $tcpdaemon -eq 0 ]; then
	run_modules
else
	listen_tcp
fi


############################################
# FINALLY SEND OVER TCP IF THE OPTION IS SET
if [ $tcpsend -eq 1 ]; then
	cat "${XMLFILE}" | netcat "$HOST" "$PORT" -q 1
elif [ $usexml -eq 1 ] && [ $quiet -ne 1 ]; then
	cat "${XMLFILE}"
fi
############################################

# exit cleanly
exit 0
