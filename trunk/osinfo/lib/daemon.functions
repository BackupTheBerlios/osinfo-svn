################################################################################
################################################################################
## osinfo daemon functions                                                    ##
################################################################################
################################################################################

###############
# listen_tcp
#
# listens to a tcp port, writes the input xml to $rundir,
# generates a html from the file and updates the index.html
listen_tcp() {
	PRINT_Version
	local clients client_hostname
	INDEXXMLFILE="index.xml"

	if [ $isverbose -ge 1 ]; then
		info "Daemonizing" 
		info "Listening to tcp connections from $tcp_listening_port..."
		info "Press Ctrl-Z to exit" 
		flush_values
	fi

	local hostdir="${rundir}/hosts"
	# create hosts dir if it doesn't exist
	[ ! -e "${hostdir}" ] && mkdir -p "${hostdir}" 

	# allocate a temp file
    tcp_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
    TempFiles=("${TempFiles[@]}" "$tcp_tmp")

	# kill other netcat instances (nc often hangs)
	killall -9 nc 2>/dev/null

	# in an eternal loop...
	while [ a = a ]; do

		netcat_instance	> "${tcp_tmp}"	# which breaks after EOF

		# notify the user of the received file
		info "$(date)" 
		info "$(wc -l $tcp_tmp | grep -Eo '^[0-9]*') lines caught!"
		flush_values

		# if the input is (not) valid osinfo xml..
		if [ ! "$(grep -i '<!doctype osinfo' ${tcp_tmp})" ]; then
			info "Input is not valid osinfo xml!"
			
		else

			update_hostxml "${tcp_tmp}"
			if [ $makehtml -eq 1 ]; then
				update_hosthtml
				create_indexxml > "${INDEXXMLFILE}"
				update_sidebar > "${hostdir}/sidebar.html"
				#update_index >  "${hostdir}/overview.html"
			fi
			
		fi

		flush_values
		unset client_hostname
	
		# :)

	done

	cleanup_temp_files
}


################
# create_indexxml
#
# creates index.xml
create_indexxml() {
	local host

	print_xml_header

	for profile in ${PROFILES}; do

		# if the profile type is found in one file..
		if [ "$(grep -l profile\=\"$profile ${hostdir}/*.xml 2> /dev/null)" ]; then		

			add_indentation
			((XML_INDENT++))
			xml_tag_start "${profile}s"

			# run a loop for all xml files in the hosts dir
			for host in $(grep -l profile\=\"$profile ${hostdir}/*.xml 2> /dev/null); do

				print_short_client_id

			done

			((XML_INDENT--))
			add_indentation
			echo "</${profile}s>"

		fi

	done

	print_xml_footer	

	# inform the user
	if [ $isverbose -ge 1 ] && [ -e "${INDEXXMLFILE}" ]; then
		info "File '$INDEXXMLFILE' created"
		flush_values
	fi
}


print_short_client_id() {

	local hostname="$(extract 'computer hostname' ${host} )"
	if [ "$hostname" ]; then

		# <hostname>
		add_indentation 
		xml_tag_start "$hostname"
		((XML_INDENT++))

			# hostname
			add_indentation
			xml_param_tag_closed "computer hostname" "$(extract 'computer hostname' ${host} )" 

			# operating system
			add_indentation
			xml_param_tag_closed "computer OS" "$(extract 'computer OS' ${host} )"
						
			# processor
			add_indentation
			xml_param_tag_closed "computer CPU" "$(extract 'computer CPU' ${host} )"

			# profile
			add_indentation
			xml_param_tag_closed "computer profile" "$profile"

		((XML_INDENT--))

		# </hostname>
		add_indentation
		xml_tag_start "/$hostname"

	fi
}



# didn't work right
update_index_with_xsl() {
	if [ -e "${rundir}/index.xsl" ]; then

		# run a loop for all xml files in the hosts dir
		for clients in "${hostdir}/*.xml"; do

			xsltproc "${rundir}/index.xsl" $clients > \
					 "${rundir}/index.html" 2> "$error_log"

		done

	else
		info "index.xsl template file was not found in '${rundir}'!"
	fi

	# inform the user
	if [ $isverbose -ge 1 ] && [ -e "${rundir}/index.html" ]; then
		info "File '${rundir}/index.html' updated"
		flush_values
	fi
}


update_hostxml() {
	# input is $1
	# if client_hostname is already defined, it won't be used
	# (which is an unlikely scenario)
	
	# extract hostname from the xml
	[ ! "$client_hostname" ] && \
	client_hostname="$(extract 'computer hostname' ${1} )"

	# create or update the xml file for the host
	cat "$tcp_tmp" > "${hostdir}/${client_hostname}.xml"
	[ $isverbose -ge 1 ] && \
		info "File '${hostdir}/${client_hostname}.xml' saved" && \
		flush_values
}


update_hosthtml() {
	# input is $1.
	# if client_hostname is already defined, it won't be used
	
	# extract hostname from the xml
	[ ! "$client_hostname" ] && \
	client_hostname="$(extract 'computer hostname' ${1} )"

	# create or update <hostname>.html. 
	# if the specific <hostname>.xsl is not found, use 'generic-host.xsl'
	if [ -e "${hostdir}/${client_hostname}.xsl" ]; then
		xsltproc "${hostdir}/${client_hostname}.xsl" \
				 "${hostdir}/${client_hostname}.xml" > \
				 "${hostdir}/${client_hostname}.html" 2> "$error_log"

	elif [ -e "${hostdir}/generic-host.xsl" ]; then
		xsltproc "${hostdir}/generic-host.xsl" \
				 "${hostdir}/${client_hostname}.xml" > \
				 "${hostdir}/${client_hostname}.html" 2> "$error_log"
	else
		info "No applicaple xsl template files found in '${hostdir}'!"
	fi

	# inform the user
	if [ $isverbose -ge 1 ] && [ -e "${hostdir}/${client_hostname}.html" ]; then
		info "File '${hostdir}/${client_hostname}.html' updated"
		flush_values
	fi
}


extract() {
	# $1 is the extract string
	# $2 is the input file
	grep -i "${1}" "${2}" | \
	   sed 's/[^\"]*\"\([^\"]*\)\"[^.]*/\1/' 
}


####################
# netcat_instance
#
# which breaks after EOF
netcat_instance() {
	# listen for incoming xml files
	if [ $isverbose -ge 1 ]; then
		netcat -v -l -p $tcp_listening_port
	else
		netcat -l -p $tcp_listening_port
	fi
}


###
# makes a generic host-xsl template
generate_generic_host_xsl() {
	cat <<EOF>> "${hostdir}/generic-host.xsl"
TODO
EOF
}
