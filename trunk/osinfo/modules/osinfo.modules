################################################################################
################################################################################
## General helper functions                                                   ##
################################################################################
################################################################################

##
# Checks if lshw was already run.
#  if it wasn't then run lshw and export the filename of the temporary file.
#  otherwise just return.
lshw_xml() {
	if [ -z "$lshw_xml_file" ]; then
		export lshw_xml_file="$(mktemp /tmp/osinfo.XXXXXX)"
		lshw -xml > "$lshw_xml_file"
	fi
}

##################################
# extracts a node from input file
# based on indentation, and the begin and end keywords
#
# operation is case-insensitive
#
#	parameters:
#	(1) node id, the begin keyword
#	(2) input file
#	(3) node closer, the end keyword, defaults to 'node id'
extr_node() {
	local node_id="${1}"
	local input_file="${2}"
	local node_closer="${3}"
	local nr node
	local all_nodes=""
	local node_count=0

	input_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$input_tmp" )

	# add line numbers
	grep -n . "${input_file}" > "$input_tmp"

	# if a special node closer is not defined, use the node_id
	[ ! "$node_closer" ] && node_closer="${node_id}"

	# get all matching nodes and node count
	all_nodes="$(grep  -i "${node_id}" "$input_tmp")"
	# NOTE: this uses an extra grep, because '<<<' adds a '\n' and
	# wc counts an empty variable line length as '1'
	node_count="$(grep -i "${node_id}" <<< "${all_nodes}" | wc -l)"

	if [ $node_count -ge 1 ]; then

		# this loop extracts the information between the node begin
		# and end lines, based on indentation level (xml), echoing
		# the results out
		for nr in $(seq 1 1 $node_count); do
			this_node="$(sed -n "$nr{p;q;}" <<< "${all_nodes}")"

			# this gets the line number of the wanted node from lshw
			local begin="$(awk -F: {'print $1'} <<< ${this_node})"
			local node_indent="$(awk -F: {'print $2'} <<< "${this_node}" | \
					     grep -Eo '^[ ]*' | wc -m)"

			# this loop takes care that all subnodes are included, by comparing
			# the indentation level. not very elegant..
			# basically it just searches for $node_closer and gets the line#
			IFS_bak="$IFS"; IFS=$'\n' ;
			for node in $(sed -n "$(($begin+1)),\${p;}" $input_tmp | \
				      grep ${node_closer}); do

				# if the indentation matches...
				if [ "$(awk -F: {'print $2'} <<< ${node} | grep -Eo '\ *' | \
					wc -m)" == "$node_indent" ]; then

					# read the line# to $nigeb (begin backwards)
					# the line number of the closing node
					local nigeb="$(awk -F: {'print $1'} <<< "${node}" )"
					((nigeb--)) # this prevents the closing node to displaying
						    # as sometimes this may not be wanted
					break;

				fi

			done

			# if the closing node wasn't found, read to EOF
			[ ! "$nigeb" ] && nigeb="$"
			IFS="$IFS_bak"

			# then what's between the first node and the closing id
			# is echoed to whichever function called this
			echo "%node $nr%"
			sed -n "$begin,$nigeb{p;}" $input_file

		done
	fi
}

# extracts value from <xml>value</xml>
extr_xml_value() {
	#sed 's/[^>]*>\([^<]*\)<[^.]*/\1/' <<< "${1}"
	sed 's/[^>]*>\([^<]*\)\(<[^.]*\)*/\1/' <<< "${1}"
}


TempFiles=()
##
# Cleans up some temporary files in the TempFiles array.
#
cleanup_temp_files() {
	if [ "$lshw_xml_file" ]; then
		rm -f "$lshw_xml_file"
	fi
	local File
	for File in "${TempFiles[@]}"; do
		rm -f "$File"
	done
}

##
# Keeps track of open headers, and closes them in the correct
# order upon flush_values.
OpenHeaders=()



################################################################################
################################################################################
## Modules                                                                    ##
################################################################################
################################################################################



########
# LVM
# fake module that calls the hdd subfunction
Module_lvm () {
	local moduleName="Logical Volumes"
	module_header "${moduleName}"

	if CheckReq_root; then
		scan_hdd_lvm
	fi

	flush_values
}


######################
# buses
#
Module_bus () {
	module_header "Data buses"
	local sysfs_prepath="/sys/devices/ide"
	local ide_devices="0/0.0 0/0.1 1/0.0 1/0.1"


	# IDE bus
	add_header "IDE bus"
	for ide_path in $ide_devices; do
		if [ -e "$sysfs_prepath$ide_path" ]; then
			add_attribute "IDE $(sed 's/^.\///' <<< $ide_path)" 
			add_values    "$(cat $sysfs_prepath$ide_path/media)"
		fi
	done
	add_footer


	flush_values
}






# GENERAL INFORMATION OF THE SYSTEM
Module_system() {
	local moduleName="System"
	module_header "${moduleName}"

	# hostname
	add_attribute "Hostname" "hostname"
	add_values    "$(hostname 2> /dev/null)"

	# operating system is set in the SYSTEM variable earlier
	add_attribute "Operating system"		"os"
	add_values    "$(get_operating_system)"

	add_attribute "Operating system kernel"	"os_build"
	add_values    "$(uname -sr 2> /dev/null)"

	#add_attribute "System encoding"
	# this is probably incorrect. determines the default output encoding
	# of the echo command.
	#add_values    "$(echo Ã¤ | file - | awk -F': ' {'print $2'})"

	add_attribute "System uptime"			"uptime"
	add_values    "$(uptime | awk -F, {'print $1'} | \
	                 grep -Eo 'up [a-z0-9: ]*' | sed 's/^[up ]*//')"

	if CheckReq_sensors; then
		scan_cpu_temp
		scan_mb_temp
	fi

	flush_values
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}

# helpers
	get_operating_system() {
		if [ "$(grep -i linux <<< "$SYSTEM")" ]; then
			[ ! "$distro_id" ] && identify_Linux_distro
			echo "$distro_id $(uname -s) $distro_release"
		elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then
			echo "$SYSTEM"
		fi
	}

	scan_cpu_temp() {
		add_attribute "CPU temperature"
		local cpu_temp="$(sensors | grep -i 'cpu temp' | \
						  grep -Eo '[0-9\.]+[[:punct:]]?[ ]?[CF]+')"
		add_values       "$(awk  {'print $1'} <<< $cpu_temp )"
		}

	scan_mb_temp() {
		add_attribute "M/B temperature"
		local mobo_temp="$(sensors | grep -i 'M/B temp' | \
		                   grep -Eo '\+[0-9]*[[:punct:]]?[ ]?[CF]+')"
		add_values       "$(awk -F'+' {'print $2'} <<< $mobo_temp)\n "
		#add_value_footer "C"
		}

	scan_cpu_fan () {
		add_attribute   "Fan"
		local cpu_fan="$(sensors | grep -i 'cpu fan' | \
						  grep -Eo '[0-9]+ RPM')"
		add_values       "$(awk  {'print $1'} <<< $cpu_fan )" 
		[ "$cpu_fan" ] && add_value_footer "RPM"
		}

		scan_cpu_voltage () {
			add_attribute   "Voltage"
			local cpu_voltage="$(sensors | grep -i 'vcore' | \
							 grep -Eo '\+[0-9. ]*')"
			add_values       "$(awk  {'print $2'} <<< $cpu_voltage)"
			[ "$cpu_voltage" ] && add_value_footer "V"
			}



# OPERATING SYSTEM KERNEL
Module_kernel() {
	local moduleName="Kernel"
	module_header "${moduleName}"

	local kernel_makefile

	add_attribute "Kernel name"
	add_values    "$(uname -o 2> /dev/null)"

	add_attribute "Kernel release"		'os_build' #FIXME
	add_values    "$(uname -r 2> /dev/null)"

	add_attribute "Kernel version"
	add_values    "$(uname -v 2> /dev/null)"

	# Unique kernel name
	if [ -e "/usr/src/linux" ]; then
		kernel_makefile="/usr/src/linux/Makefile"
	elif [ "$(ls /usr/src/linux* 2> /dev/null)" ]; then
		kernel_makefile="/usr/src/linux*/Makefile"
	fi
	if [ -e "${kernel_makefile}" ]; then
		add_attribute "Kernel name"
		add_values    "$(head ${kernel_makefile} | grep NAME | \
		                 head -n 1 | awk -F= {'print $2'})"
	fi

	flush_values
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}


# INFORMATION OF THE TERMINAL IN USE
Module_terminal() {
	local moduleName="Terminal info"
	module_header "${moduleName}"

	add_attribute "Terminal type"
	add_values    "$TERM"

	# TODO
	#add_attribute "Terminal encoding"
	#add_values    "?"

	add_attribute "Terminal speed"
	add_values    "$(stty speed)"

	add_attribute "Rows"
	add_values    "$(stty size | awk '{print $1}')"

	add_attribute "Columns"
	add_values    "$(stty size | awk '{print $2}')"

	flush_values
}


#######################
# PRINTERS AVAILABLE TO THE SYSTEM

# EXPERIMENTAL!

# uses only lpstat (cups) and hasn't been tested on multi-printer
# environments
#
# TODO: add some kind of timeout function
Module_printers() {
	local moduleName="Printers"
	module_header "${moduleName}"

	local lp_nr

	# first of all, check if lpstat is available
	if [ "$(type -p lpstat)" ]; then

		#  if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then

		add_attribute 	'Printer'	'local_printer'

		# as there may be several printers, print info from all
		#for lp_nr in $(seq 1 1 $(lpstat -a | wc -l) ); do
		#	add_values  "$(lpstat -a 2> /dev/null | sed -n "$lp_nr{p;q;}")"
		#done

		add_attribute	'model'
		add_attribute	'location'
		add_attribute	'server'
		add_attribute	'spooler'
		add_attribute	'status'
		add_attribute	'completed jobs'

	fi

	#module_footer
	flush_values
}



###################################################
# MODULE WLAN
#
# detects wireless network access points
#
# uses wireless-tools (iwconfig, iwlist)
# Linux only
#
# under developement, does not yet work!
Module_wlan() {
	local moduleName="Wlan information"
	module_header	"${moduleName}"

	iw_src="$(mktemp /tmp/osinfo.XXXXXX)"
	ap_src="$(mktemp /tmp/osinfo.XXXXXX)"
	cell_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$iw_src" "$ap_src" "$cell_tmp")
	#TempFiles=("${TempFiles[@]}" "$cell_tmp")

	if [ ! "$(type -p iwconfig)" ]; then

		info "No wireless extensions found"

	elif [ "$SYSTEM" == "linux" ] ; then

		# get the basic info
		iwconfig 2>/dev/null > $iw_src
		local wlan_devices="$(grep 'IEEE 802' ${iw_src} | awk  {'print $1'})"
		iwlist $wlan_devices scan 2> /dev/null > $ap_src


		# for debugging purposes
		if [ "$fake" == 1 ]; then
			iw_src="debug/wlan-iwconfig-on"
			wlan_devices="eth1"
			ap_src="debug/wlan-stations"
		fi

		local ap_count="$(grep -i cell $ap_src | wc -l)"

		# print status
		if [ "$ap_count" -ge 1 ]; then
			info "$ap_count access points found by device $wlan_devices"
		else
			info "No access points found by device $wlan_devices"
		fi

		# process all access points
		IFS_bak="$IFS"
		IFS=$'\n'

		for access_point in $(grep -i cell ${ap_src}); do

			# this functions extracts each cell into a temp file
			extr_node $access_point $ap_src Cell > $cell_tmp

			add_header    "$(awk -F: '/ESSID/ {print $2}' $cell_tmp | sed 's/\"//g')"

			if [ $accociated ]; then
				#access_points[${access_points[@]}]="$(grep -A 1 -i ${access_point}" \
				#awk -F: '/ESSID/ {print $2}' | sed 's/\"//g' )"


				#add_attribute   'associated ESSID'
				#add_header    "$(grep -Eo 'ESSID[:"A-Za-z/ ]*' "${iw_src}" | \
				#                awk -F: {'print $2'})"

				add_attribute   'device node'
				add_values      "$(grep -Eo '^[a-z0-9]'+ ${iw_src})"
								# the device associated to this AP

				add_attribute   'device'
				#add_values     "some_device_from_mod_devices"
			fi

			add_attribute   'link quality'
			add_values      "$(grep -Eo 'Quality[\=:][a-zA-Z0-9\/]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"
			add_attribute   'address'
			add_values      "$(awk -F"Address:" '{print $2}' $cell_tmp | sed 's/^\ *//')"

			add_attribute   'channel'
			add_values      "$(grep -Eo 'Channel[\=:][a-zA-Z0-9]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"

			add_attribute   'frequency'
			add_attribute   'bit rate'

			add_attribute   'protocol'
			add_values      "$(grep -Eo 'Protocol[\=:][a-zA-Z0-9. ]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"

			add_attribute   'mode'
			add_values      "$(grep -Eo 'Mode[\=:][a-zA-Z]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"

			add_attribute   'encryption key'
			add_values      "$(grep -Eo 'Encryption key[\=:][a-zA-Z]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"
			add_attribute   'encryption type'

			add_attribute   'security mode'

			add_attribute   'signal level'
			add_values      "$(grep -Eo 'Signal level[\=:][-a-zA-Z0-9\/ ]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"


			#value_footer

		done

		IFS="$IFS_bak"

	fi

	#module_footer
	flush_values
}



#######################
# APPLICATIONS
#
# version information of standard *nix, dev, and dependency packages.
# probably should take an additional switch like --X, --server, etc.
Module_applications() {
	local moduleName="Applications"
	module_header "${moduleName}"

	local APPLICATIONS app versionstring category cat_print=0
	local missing_ERRMSG="if you want to be able to use all modules of ${appname}"
	

	## Applications to look for..
	if [ "$SYSTEM" == "linux" ] ; then

		APPLICATIONS="Graphical_interface: X kde-config gnome-about xfce4-session \
		              fluxbox fvwm2 enlightenment \
			Shells: bash csh dsh fish pdsh rrs tcsh zsh \
			Compilers: gcc gcj icc \
			System: udevinfo \
			Userspace_tools: make unsermake awk sed grep ls gzip lspci lshw dmidecode smartctl hdparm \
			Languages: perl python java-config ruby php \
			Servers: apache2 mysql ssh smbd cups-config \
			Miscellaneous: x11vnc nagios firefox thunderbird mozilla"

		UNTESTED="Graphical_interface: \
			Compilers: ccc cxx cfal erlang fpc gforth ghc gnat \
		               gnat-gcc gnat-gpl gpc icc ifc open-cobol \
			Tools: mono"

			# Shells: ash ccsh dash esh ksh mksh psh rssh sash shish
			# don't take any version parameters


	elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then

		APPLICATIONS="Graphical_interface: X kde-config gnome-about \
			Shells: bash csh dsh fish pdsh rrs tcsh zsh \
			Compilers: gcc gcj icc \
			Tools: awk grep gzip lshw dmidecode lspci lshw smartctl hdparm \
			Languages: perl python java-config ruby php \
			Servers: apache2 mysql ssh smbd cups-config \
			Miscellaneous: x11vnc"

	fi


	## Write the header for output
	if [ $usexml = 1 ]; then
		add_attribute "Applications" 'software'
	fi


	## Process all categories
	for app in $APPLICATIONS; do
		# if the variable $app is a category definition,
		if [ $(grep \: <<< $app) ] && [ $usexml -eq 0 ]; then

			category="$(sed 's/\:// ; s/_/\ /g' <<< $app)"

			# check verbosity level, do not print shells
			# if verbosity is less than 1
			if [ $isverbose -lt 1 ] && [ "$category" == "Shells" ]; then
				cat_print=0
			else 
				# print the category to stdout
				cat_print=1
				add_header "$category"
			fi

			flush_values

		# use the subfunction to get the version information
		elif [ "$(type -p $app)" ] && [ $cat_print -eq 1 ]; then # it is installed
			versionstring="$(get_version $app)"
			# if the application doesn't tell what it is, echo it
			if [ "$(grep -i ${app} <<< ${versionstring})" ]; then
				add_values	"\t${versionstring}\n"
			else
				add_values	"\t${versionstring} ($app)\n"
			fi
		fi
	done

	flush_values
}

	###########################################
	# helper functions for applications module
	get_version() {
		local app="${1}"
		case "$app" in
			'perl')
				echo  "Perl" $($app --version 2>&1 | grep 'perl, v' | \
							   grep -Eo 'v[ A-Za-z0-9.-]*')
				;;
			'python')
				python -V 2>&1 | head -n 1 
				;;
			'X')
				X -version 2>&1 | grep Revision
				;;
			'kde-config')
				kde-config -version 2>&1 | grep KDE
				;;
			'gnome-about')
				gnome-about --version 2>&1 | sed 's/gnome-about//'
				;;
			'xfce4-session')
				xfce4-session --version | head -n 1 | sed 's/xfce4-session/Xfce4/'
				;;
			'fluxbox')
				fluxbox -version 2> /dev/null | head -n 1
				;;
			'apache2'|'apache')
				$app -V | head -n 1 | awk -F': ' {'print $2'}
				;;
			'cups-config')
				echo  "Cups $($app --version 2>&1 )"
				;;
			'smbd')
				echo  "Samba $($app -V 2>&1 )"
				;;
			'udevinfo')
				$app -V 2>&1 
				;;
			'awk')
				# awk is a bit tricky.. it can go into a captive cmd interpreter mode
				if [ ! "$(awk -V 2> /dev/null)" ]; then
					awk -W version 2>&1 | head -n 1 
				else
					awk -V
				fi
				;;
			'dmidecode')
				echo  "dmidecode $(dmidecode -V 2> /dev/null )"
				;;
			'java-config')
				echo "Java $(java-config -f)"
				;;
			'ssh')
				ssh -V 2>&1 /dev/null
				;;
			'icc')
				icc 2>&1 -V | head -n 1
				;;
			'ls')
				ls --version | head -n 1 | sed 's/ls// ; s#(\|)\|^\ ##g'
				;;
			'pdsh')
				pdsh -V | head -n 1
				;;
			'firefox')
				firefox --version 2>/dev/null | head -n 1
				;;
			*)
				$app --version 2>&1 | grep '\w' | head -n 1
				;;
			'lspci')
				info "please install pciutils ${missing_ERRMSG}"
				;;
			'lshw')
				info "please install lshw ${missing_ERRMSG}"
				;;
			'smartctl')
				info "please install smartmontools ${missing_ERRMSG}"
				;;
			'dmidecode')
				info "please install dmidecode ${missing_ERRMSG}"
				;;
		esac
	}
	###########################################


#######################
# ENVIRONMENT VARIABLES
#
# xml only, stdout is not needed
Module_env() {
	local moduleName="Environment variables"
	module_header "${moduleName}"

	## Write the header for output
	add_attribute   'System enviroment variables\n' \
	                'system_enviroment_variables'
	## Process all variables
	for var in $(env); do

		add_values  "${var}\n"

	done

	#module_footer
	flush_values
}

