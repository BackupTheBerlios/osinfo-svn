################################################################################
################################################################################
## General helper functions                                                   ##
################################################################################
################################################################################

##
# Checks if lshw was already run.
#  if it wasn't then run lshw and export the filename of the temporary file.
#  otherwise just return.
lshw_xml() {
	if [ -z "$lshw_xml_file" ]; then
		export lshw_xml_file="$(mktemp /tmp/osinfo.XXXXXX)"
		lshw -xml > "$lshw_xml_file"
	fi
}

##################################
# extracts a node from input file
# based on indentation, and the begin and end keywords
#
# operation is case-insensitive
#
#	parameters:
#	(1) node id, the begin keyword
#	(2) input file
#	(3) node closer, the end keyword, defaults to 'node id'
extr_node() {
	local node_id="${1}"
	local input_file="${2}"
	local node_closer="${3}"
	local nr node
	local all_nodes=""
	local node_count=0

	input_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$input_tmp" )

	# add line numbers
	grep -n . "${input_file}" > "$input_tmp"

	# if a special node closer is not defined, use the node_id
	[ ! "$node_closer" ] && node_closer="${node_id}"

	# get all matching nodes and node count
	all_nodes="$(grep  -i "${node_id}" "$input_tmp")"
	# NOTE: this uses an extra grep, because '<<<' adds a '\n' and
	# wc counts an empty variable line length as '1'
	node_count="$(grep -i "${node_id}" <<< "${all_nodes}" | wc -l)"

	if [ $node_count -ge 1 ]; then

		# this loop extracts the information between the node begin
		# and end lines, based on indentation level (xml), echoing
		# the results out
		for nr in $(seq 1 1 $node_count); do
			this_node="$(sed -n "$nr{p;q;}" <<< "${all_nodes}")"

			# this gets the line number of the wanted node from lshw
			local begin="$(awk -F: {'print $1'} <<< ${this_node})"
			local node_indent="$(awk -F: {'print $2'} <<< "${this_node}" | \
					     grep -Eo '^[ ]*' | wc -m)"

			# this loop takes care that all subnodes are included, by comparing
			# the indentation level. not very elegant..
			# basically it just searches for $node_closer and gets the line#
			IFS_bak="$IFS"; IFS=$'\n' ;
			for node in $(sed -n "$(($begin+1)),\${p;}" $input_tmp | \
				      grep ${node_closer}); do

				# if the indentation matches...
				if [ "$(awk -F: {'print $2'} <<< ${node} | grep -Eo '\ *' | \
					wc -m)" == "$node_indent" ]; then

					# read the line# to $nigeb (begin backwards)
					# the line number of the closing node
					local nigeb="$(awk -F: {'print $1'} <<< "${node}" )"
					((nigeb--)) # this prevents the closing node to displaying
						    # as sometimes this may not be wanted
					break;

				fi

			done

			# if the closing node wasn't found, read to EOF
			[ ! "$nigeb" ] && nigeb="$"
			IFS="$IFS_bak"

			# then what's between the first node and the closing id
			# is echoed to whichever function called this
			echo "%node $nr%"
			sed -n "$begin,$nigeb{p;}" $input_file

		done
	fi
}

# extracts value from <xml>value</xml>
extr_xml_value() {
	sed 's/[^>]*>\([^<]*\)<[^.]*/\1/' <<< "${1}"
}


TempFiles=()
##
# Cleans up some temporary files in the TempFiles array.
#
cleanup_temp_files() {
	if [ "$lshw_xml_file" ]; then
		rm -f "$lshw_xml_file"
	fi
	local File
	for File in "${TempFiles[@]}"; do
		rm -f "$File"
	done
}

##
# Keeps track of open headers, and closes them in the correct
# order upon flush_values.
OpenHeaders=()



################################################################################
################################################################################
## Modules                                                                    ##
################################################################################
################################################################################



########
# LVM
# fake module that calls the hdd subfunction
Module_lvm () {
	local moduleName="Logical Volumes"
	module_header "${moduleName}"

	if CheckReq_root; then
		scan_hdd_lvm
	fi

	flush_values
}


######################
# buses
#
Module_bus () {
	module_header "Data buses"
	local sysfs_prepath="/sys/devices/ide"
	local ide_devices="0/0.0 0/0.1 1/0.0 1/0.1"


	# IDE bus
	add_header "IDE bus"
	for ide_path in $ide_devices; do
		if [ -e "$sysfs_prepath$ide_path" ]; then
			add_attribute "IDE $(sed 's/^.\///' <<< $ide_path)" 
			add_values    "$(cat $sysfs_prepath$ide_path/media)"
		fi
	done
	add_footer


	flush_values
}






# GENERAL INFORMATION OF THE SYSTEM
Module_system() {
	local moduleName="System"
	module_header "${moduleName}"

	# hostname
	add_attribute "Hostname" "hostname"
	add_values    "$(hostname 2> /dev/null)"

	# operating system is set in the SYSTEM variable earlier
	add_attribute "Operating system"		"os"
	add_values    "$(get_operating_system)"

	add_attribute "Operating system kernel"	"os_build"
	add_values    "$(uname -sr 2> /dev/null)"

	#add_attribute "System encoding"
	# this is probably incorrect. determines the default output encoding
	# of the echo command.
	#add_values    "$(echo Ã¤ | file - | awk -F': ' {'print $2'})"

	add_attribute "System uptime"			"uptime"
	add_values    "$(uptime | awk -F, {'print $1'} | \
	                 grep -Eo 'up [a-z0-9: ]*' | sed 's/^[up ]*//')"

	if CheckReq_sensors; then
		scan_cpu_temp
		scan_mb_temp
	fi

	flush_values
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}

# helpers
	get_operating_system() {
		if [ "$(grep -i linux <<< "$SYSTEM")" ]; then
			[ ! "$distro_id" ] && identify_Linux_distro
			echo "$distro_id $(uname -s) $distro_release"
		elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then
			echo "$SYSTEM"
		fi
	}

	scan_cpu_temp() {
		add_attribute "CPU temperature"
		local cpu_temp="$(sensors | grep -i 'cpu temp' | \
						  grep -Eo '[0-9\.]+[[:punct:]]?[ ]?[CF]+')"
		add_values       "$(awk  {'print $1'} <<< $cpu_temp )"
		}

	scan_mb_temp() {
		add_attribute "M/B temperature"
		local mobo_temp="$(sensors | grep -i 'M/B temp' | \
		                   grep -Eo '\+[0-9]*[[:punct:]]?[ ]?[CF]+')"
		add_values       "$(awk -F'+' {'print $2'} <<< $mobo_temp)\n "
		#add_value_footer "C"
		}

	scan_cpu_fan () {
		add_attribute   "Fan"
		local cpu_fan="$(sensors | grep -i 'cpu fan' | \
						  grep -Eo '[0-9]+ RPM')"
		add_values       "$(awk  {'print $1'} <<< $cpu_fan )" 
		[ "$cpu_fan" ] && add_value_footer "RPM"
		}

		scan_cpu_voltage () {
			add_attribute   "Voltage"
			local cpu_voltage="$(sensors | grep -i 'vcore' | \
							 grep -Eo '\+[0-9. ]*')"
			add_values       "$(awk  {'print $2'} <<< $cpu_voltage)"
			[ "$cpu_voltage" ] && add_value_footer "V"
			}



# OPERATING SYSTEM KERNEL
Module_kernel() {
	local moduleName="Kernel"
	module_header "${moduleName}"

	local kernel_makefile

	add_attribute "Kernel name"
	add_values    "$(uname -o 2> /dev/null)"

	add_attribute "Kernel release"		'os_build' #FIXME
	add_values    "$(uname -r 2> /dev/null)"

	add_attribute "Kernel version"
	add_values    "$(uname -v 2> /dev/null)"

	# Unique kernel name
	if [ -e "/usr/src/linux" ]; then
		kernel_makefile="/usr/src/linux/Makefile"
	elif [ "$(ls /usr/src/linux* 2> /dev/null)" ]; then
		kernel_makefile="/usr/src/linux*/Makefile"
	fi
	if [ -e "${kernel_makefile}" ]; then
		add_attribute "Kernel name"
		add_values    "$(head ${kernel_makefile} | grep NAME | \
		                 head -n 1 | awk -F= {'print $2'})"
	fi

	flush_values
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}


# INFORMATION OF THE TERMINAL IN USE
Module_terminal() {
	local moduleName="Terminal info"
	module_header "${moduleName}"

	add_attribute "Terminal type"
	add_values    "$TERM"

	# TODO
	#add_attribute "Terminal encoding"
	#add_values    "?"

	add_attribute "Terminal speed"
	add_values    "$(stty speed)"

	add_attribute "Rows"
	add_values    "$(stty size | awk '{print $1}')"

	add_attribute "Columns"
	add_values    "$(stty size | awk '{print $2}')"

	flush_values
}


#######################
# PRINTERS AVAILABLE TO THE SYSTEM

# EXPERIMENTAL!

# uses only lpstat (cups) and hasn't been tested on multi-printer
# environments
#
# TODO: add some kind of timeout function
Module_printers() {
	local moduleName="Printers"
	module_header "${moduleName}"

	local lp_nr

	# first of all, check if lpstat is available
	if [ "$(type -p lpstat)" ]; then

		#  if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then

		add_attribute 	'Printer'	'local_printer'

		# as there may be several printers, print info from all
		#for lp_nr in $(seq 1 1 $(lpstat -a | wc -l) ); do
		#	add_values  "$(lpstat -a 2> /dev/null | sed -n "$lp_nr{p;q;}")"
		#done

		add_attribute	'model'
		add_attribute	'location'
		add_attribute	'server'
		add_attribute	'spooler'
		add_attribute	'status'
		add_attribute	'completed jobs'

	fi

	#module_footer
	flush_values
}


#######################
# USERS
#
# reports the current user, the user's X11 session manager + shell
# the last logged user, and other users that have logged in
# (that wtmp has registered).
Module_users() {
	local moduleName="Users"
	module_header "${moduleName}"

	local last_login_date login_count user users login_from user_uid user_gid \
	      user_fullname user_unixname groups user_home user_shell wtmp_begin session_id
	local wtmp_file="/var/log/wtmp"

	if [ ! "$(last 2>/dev/null)" ] || \
	   [ ! -s ${wtmp_file} ]; then # last gives nothing but an error, or
		                           # the wtmp file doesn't exist or is empty
		info	"\n${wtmp_file} does not exist or is empty. Cannot parse past user data. " \
		        "If this is unintentional, submit a bug and provide the location of your wtmp file."
		unset wtmp_file
	fi

	passwd_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
	if [ -w $error_log ]; then
		getent passwd > "$passwd_tmp" 2>> "$error_log"
	else
		getent passwd > "$passwd_tmp" 2> /dev/null
	fi
	TempFiles=("${TempFiles[@]}" "$passwd_tmp")


	### CURRENT USER (ACTIVE UID)
	get_user_data "$(whoami)"
	user_uid="$(id -u)"
	user_gid="$(id -g)"
	last_login_date="$(date -d "$(last 2>/dev/null | grep -m 1 $(whoami) | \
		   grep -Eo '[a-zA-Z]{3} [a-zA-Z]{3}\ *[0-9]{1,2} [0-9:]{5}')" \
		   +"%Y-%m-%d %T")"

	print_current_user_data


	###############################
	### wtmp data
	###
	if [ ! -s ${wtmp_file} ]; then 
		flush_values
	else

		# get the wtmp log starting point
		local wtmp_begin="$(last -1 | tail -n 1)"
		local total_users=0

		if [ $usexml -eq 1 ]; then
			add_header      "wtmp statistics"
			add_values      "$wtmp_begin"
			add_footer
		fi

		fake_users="reboot\|wtmp\|ftp"
		users="$(last | awk {'print $1'} | sort | uniq | \
		          grep -v "$fake_users" | grep '^[a-zA-Z]')"
		          # ^^ removes fake users

		for user in $users; do

			((total_users++))

			# call subfunction to collect the data
			# if the current user is the same as last user,
			# do not unset the buffer. speeds up things
			# when there are a lot of non-local users
			if [ "$user" != $(whoami) ]; then 
				unset_user_data				
				get_user_data "$user"
			fi

			if [ $total_users -eq 1 ]; then
			####################################
			### LAST LOGGED IN USER
			###
				print_last_user_data
			fi

			#################################
			### ALL USERS
			###

			## before printing any user data, print out the header
			if [ $total_users -eq 1 ]; then
				print_all_users_header
			fi

			# output user data
			print_user_data
			unset_user_data
		done
	fi

	flush_values
}

	###### BEGIN USERS SUBFUNCTIONS #############
	#
	# these functions are called from Module_users.
	# FIXME: *BSD doesn't have 'getent' command
	#
	get_user_data () {
		local user="$1"

		# get the full username (user_fullname)
		#
		# because 'last' command, part of the sysvinit core package,
		# interprets the binary file /var/log/wtmp, but chomps off
		# the loginname at 8 characters, we need to find the full names
		# from the source file. a dirty hack but may well be the only way...
		if [ ${#user} -ge 8 ]; then
			# parse special chars to meta-chars
			user_unixname="$(sed 's/[[:punct:]]/\\&/g' <<< $user)"
			user_unixname="$(grep -m 1 -Eoa "$user_unixname[a-zA-Z0-9\\\+]*" \
							 ${wtmp_file} | uniq)"
		else
			user_unixname="$user"
		fi

		# get data from $passwd_tmp
		if [ -e "$passwd_tmp" ]; then
			user_uid="$(awk -F: /^$user_unixname\:/{'print $3'} "$passwd_tmp")"
			user_gid="$(awk -F: /^$user_unixname\:/{'print $4'} "$passwd_tmp")"
			user_realname="$(awk -F: /^$user_unixname\:/{'print $5'} "$passwd_tmp")"
			user_home="$(awk -F: /$user_unixname/{'print $6'} "$passwd_tmp")"
			user_shell="$(awk -F: /$user_unixname/{'print $7'} "$passwd_tmp")"
		fi

		# get the first and last login date & time
		# print the times if verbosity is set
		if [ $isverbose -ge 1 ]; then
			last_login_date="$(date -d "$(last | grep -m 1 $user | \
			   grep -Eo '[a-zA-Z]{3} [a-zA-Z]{3}\ *[0-9]{1,2} [0-9:]{5}')" \
			   +"%Y-%m-%d %T")"
			first_login_date="$(date -d "$(last | grep $user | tail -n 1 | \
			   grep -Eo '[a-zA-Z]{3} [a-zA-Z]{3}\ *[0-9]{1,2} [0-9:]{5}')" \
			   +"%Y-%m-%d %T")"
		else
			last_login_date="$(date -d "$(last | grep -m 1 $user | \
			   grep -Eo '[a-zA-Z]{3} [a-zA-Z]{3}\ *[0-9]{1,2} [0-9:]{5}')" \
			   +"%Y-%m-%d")"
			first_login_date="$(date -d "$(last | grep $user | tail -n 1 | \
			   grep -Eo '[a-zA-Z]{3} [a-zA-Z]{3}\ *[0-9]{1,2} [0-9:]{5}')" \
			   +"%Y-%m-%d")"
		fi

		# get from where the user last logged in
		login_from="$(last 2> /dev/null | grep -m 1 $user )"
		login_from="$(sed 's/[ ]+//g' <<< ${login_from:9:30})"

		# get the login count
		login_count="$(last 2> /dev/null | grep $user | wc -l)"

		# get groups, may only work for local users
		# and takes a lot of time for remote (ldap) users
		groups="$(groups $user_unixname 2> /dev/null | \
				  sed 's/^\ // ; s/ /\n/g ' | uniq | tr -s '\n' ' ')"

		# get the default X session
		# KDE sometimes sets $DESKTOP_SESSION nicely, Gnome doesn't.
		# AnMaster: KDE doesn't set that for me (in konsole at least)
		# ruxpin:   I get this in konsole: DESKTOP_SESSION="kde-7.0"
		#           any ideas where else to look?

		#session_id="$DESKTOP_SESSION"
		#if [ "$session_id" == "default" ]; then
		#	if [ "$GNOME_DESKTOP_SESSION_ID" ]; then
		#		# try to get Gnome version
		#		local gnome_version="$(gnome-about --version | awk {'print $NF'})"
		#		session_id="Gnome $gnome_version"
		#	fi
		#fi
	}

	print_last_user_data() {
		if [ $usexml -eq 1 ]; then
			add_header  "$user_unixname" 'last_login unixname'
			# lanforce gets special treatment
			[ $lanforce -eq 1 ] && add_attribute "Last logged in user" 'last_logged_user'

			[ "$user_realname" ] && \
			add_values       "real name: $user_realname"
			add_values       "uid: $user_uid"
			add_values       "gid: $user_gid"
			add_values       "shell: $user_shell"
			add_values       "home: $user_home"
			add_values       "first login date: $first_login_date"
			add_values       "last login date: $last_login_date"
			add_values       "latest entry: $login_from"
			add_values       "login count: $login_count"
			add_footer  'last_login'

		else

			add_header     "\nLast logged in user"

			add_attribute  "Unix name"         'last_logged_user'
			add_values     "$user_unixname"

			add_attribute  'Real name'         'last_logged_real_name'
			add_values     "$user_realname"

			add_attribute  'First login date'   'first_login_date'
			add_values     "$first_login_date"

			add_attribute  'Last login date'   'last_login_date'
			add_values     "$last_login_date"

			add_attribute  'Login from'        'login_from'
			add_values     "$login_from"

			add_attribute  'Login count'        'login_count'
			add_values     "$login_count"

			add_footer
		fi

		# flush values here so that previous values do not affect future indentation
		[ $usexml -eq 0 ] && flush_values
	}

	print_user_data () {
		if [ $lanforce -eq 1 ]; then
			add_values   "$user_unixname: $user_realname"

		elif [ $usexml -eq 1 ]; then
			add_header  "$user_unixname" 'user unixname'
			[ "$user_realname" ] && \
			add_values       "real name: $user_realname"
			[ "$user_uid" ] && 
			add_values       "uid: $user_uid"
			[ "$user_gid" ] && 
			add_values       "gid: $user_gid"
			add_values       "first login date: $first_login_date"
			add_values       "last login date: $last_login_date"
			add_values       "login count: $login_count"
			add_footer 'user'

		else
			add_values "$user_unixname"
			[ ! "$user_realname" ] && user_realname=" "
			[ ! "$user_uid" ] && user_uid=" "
			[ ! "$user_gid" ] && user_gid=" "
			add_values "$user_uid"
			add_values "$user_realname"
			add_values "$first_login_date"
			add_values "$last_login_date"

			[ $isverbose -ge 1 ] && \
			add_values "$login_from"

			add_values "$login_count\n"
		fi
	}

	print_all_users_header () {
		if [ $lanforce = 1 ]; then
			add_attribute 'All logged in users' "users"
		else
			add_header    "\nAll users"

			if [ $usexml -eq 0 ]; then
				if [ $isverbose -ge 1 ]; then # print only if verbose
					add_nc_header   "Unix name%col%uid%col%real name%col%first login%col%last login%col%at%col%count\n"
					add_nc_header   "---------%col%---%col%---------%col%-----------%col%----------%col%--%col%-----\n"
				else
					add_nc_header   "Unix name%col%uid%col%real name%col%first login%col%last login%col%count\n"
					add_nc_header   "---------%col%---%col%---------%col%-----------%col%----------%col%-----\n"
				fi
			fi
		fi
	}

	unset_user_data () {
		unset user_realname user_uid user_gid user_unixname \
			 last_login_date login_from \
			 first_login_date login_count user_home user_shell
	}

	print_current_user_data () {
		# xml
		if [ $usexml -eq 1 ]; then
			add_header  "$user" 'active_user unixname'
			# lanforce gets special treatment
			[ $lanforce -eq 1 ] && add_attribute    'Active user' "active_user"

			# the process the data ...
			[ "$user_realname" ] && \
			add_values       "real name: $user_realname"
			add_values       "login date: $login_date"
			add_values       "uid: $user_uid"
			add_values       "gid: $user_gid"
			add_values       "groups: $groups"
			#add_values       "X Session: $session_id"
			add_values       "shell: $user_shell"
			add_values       "home: $user_home"
			add_values       "locales: $LC_ALL"
			add_footer 'active_user'

		# standard
		else 
			add_header   "Current user"

			add_attribute  'Real name'          "real_name"
			add_values     "$user_realname"

			add_attribute  "Unix name"    'active_user'
			add_values     "$user_unixname"

			add_attribute  "uid / gid"    'uid_+_gid'
			add_values     "$user_uid / $user_gid"

			add_attribute  'Groups'
			add_values     "$groups\n " # << note that for indentation, the
									  # space at the end of string is important!

			#add_attribute  "User's X11 session"	"users_window_manager"
			#add_values     "$session_id"

			add_attribute  "Logged in since"
			add_values     "$last_login_date"

			add_attribute  "User's shell"
			add_values     "$user_shell"

			add_attribute  "Home directory"     'home'
			add_values     "$user_home"

			add_attribute  "User's locales"
			add_values     "$LC_ALL"

			add_footer
		fi
	}
	#############################################


###########################
# SYSTEM SERVICES (daemons)

# http://linuxhelp.blogspot.com/2006/04/enabling-and-disabling-services-during_01.html

# Gentoo based:
#  rc-status

# Fedora, RedHat, Suse:
#  /sbin/service --status-all
#  chkconfig --list

# Ubuntu, Debian based:
#  sysv-init
#  'runlevel' gives to values: "previous current", grep on the current

# Slackware:
#	There is no sane way to get "running services" from Slackware
#	(at least last time I used Slackware: 9.0 I think).
#	to change what services are started you edit the bootscripts (written in bash).
#	(there are 7 or 8 IIRC, one for each runlevel, 1 for kernel modules to load,
#	1 for local and 1 for system startup)
Module_services() {
	local moduleName="Services"
	module_header "${moduleName}"

	local method

		# these functions handle scanning, they'll echo output
		if [ "$(type -p rc-status)" ]; then
			# Gentoo
			method='rc-status'
			local services="$(scan_services_rc-status)"

		elif [ "$(type -p sysv-rc-conf)" ]; then
			# Debian and Ubuntu, if they've got the package
			method='sysv-rc-conf'
			local services="$(scan_services_sysv)"

		elif [ "$(type -p chkconfig)" ]; then
			# Red Hat, Fedora Core, SuSE
			method='chkconfig'
			local services="$(scan_services_chkconfig)"
		fi


		# attribute only for lanfroce xml, nothing for std xml
		if [ $lanforce = 1 ]; then
			add_attribute 'Services'	'service'
		elif [ $usexml = 0 ]; then
			add_header  "$method"
		fi


		# then report what scan found
		local count=0 columns=5
		for srv in $services; do
			if [ $count -eq $columns ]; then
				add_values    "$srv\n "
				count=0
			else
				add_values    "$srv"
			fi

			((count++))
		done

		#value_footer


	#module_footer
	flush_values
}

	#################################
	### SERVICE MODULE SUBFUNCTIONS
	##
	# this script is used on gentoo
	scan_services_rc-status() {

		echo $(rc-status | awk '/started/{print $1}' | sort)

	}

	# this works on debian-based systems
	scan_services_sysv() {

		local runlevel=$(runlevel | awk {'print $2'})

		echo $(sysv-rc-conf --list 2> /dev/null | \
		       awk '/'$runlevel'\:on/{print $1}' | sort)

	}

	scan_services_chkconfig() {

		# similar to sysv-rc-conf
		# works on rpm-based systems

		local runlevel=$(runlevel | awk {'print $2'})

		echo $(chkconfig --list 2> /dev/null | \
		       awk '/'$runlevel'\:on/{print $1}' | sort)

	}
	#################################


##########
# NETWORK
#
# this module detects the network settings of the computer.
#
# there are at least two methods to pull in information; ifconfig and iproute2.
# ifconfig is used; there are at least two versions of ifconfig being used, and
# all tested Linuxes have used the same, whereas FreeBSD v6 had different
# output. the script should work on both versions.
#
# some changes have been made after testing with FreeBSD, so compitibility
# may not be 100% anymore.
Module_network() {
	local moduleName="Network information"
	module_header	"${moduleName}"

	local specials="UP|BROADCAST|LOOPBACK|NOARP|NOTRAILERS|RUNNING|MULTICAST"
	local nwfile

	# allocate a temp file
	local nw_info="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$nw_info")

	################################
	# DETECT (WIRED) NETWORK DEVICES
	# using ifconfig
	#
	# detect the type of OS. all ifconfigs in tested Linuxes operate
	# more of less similarity, but the one on FreeBSD 6.0 is different.
	if [ "$(type -p ifconfig)" ]; then
		nw_src="ifconfig"

		if [ "$SYSTEM" == "linux" ] ; then
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST -B 3 | \
			grep -Ev '(^ )|(^--)|LOOPBACK' | awk  {'print $1'})"

		else # *BSD ifconfig
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST | grep -v LOOPBACK | \
			awk -F': ' {'print $1'})"
		fi
	fi


	### generic information
	add_header  "$(hostname 2> /dev/null)" 'computer name'

		add_attribute 'NIS domain'
		add_values    "$(hostname -y 2> /dev/null)"
		# hostname produces stderr if no network is available

		add_attribute 'DNS domain'	'domain'
		add_values    "$(hostname -d 2> /dev/null)"

		add_attribute 'FQDN'		"fully_qualified_domain_name"
		add_values    "$(hostname -f 2> /dev/null)"

		local ipv4 ipv6

		# collect the information from detected network devices
		for interface_name in $ETH_DEVICES; do
			ifconfig $interface_name > ${nw_info}

			add_header    $interface_name   'iface name'

			add_attribute 'MAC'		"mac_address"
			add_values    "$(grep -Eo '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}' ${nw_info})"


			add_attribute 'IPv4'		"ip_address"
			ipv4="$(grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' ${nw_info} | \
			        grep -Eo '[0-9\.]+' )"
			add_values    "$ipv4"

			add_attribute 'IPv6'
			ipv6="$(sed "s/  /\n/g" ${nw_info} | grep -i inet6 | \
			        grep -Eio '([0-9a-f]{3,4}(\:){1,2}){4,8}([0-9a-f]{3,4})' )"
			add_values    "$ipv6"

			add_attribute 'IP type'	"ip_type"
			add_values    "$(detect_ip_type)"

			add_attribute 'Gateway'	"default_gateway"
			add_values    "$(route -n | grep $interface_name | \
			              awk '/^0.0.0.0/{print $2}')"

			add_attribute 'Broadcast'
			add_values    "$(sed "s/  /\n/g" ${nw_info} | \
			                 grep -Eio 'cast[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | \
			                 grep -Eo '[0-9\.]+' )"

			add_attribute 'Netmask'	"subnet_mask"
			add_values    "$(sed "s/  /\n/g" ${nw_info} | \
			                 grep -Eio 'mask[A-Za-z: ]*((([0-9]{1,3}\.){3}[0-9]{1,3})|(0x[0-f]{8}))' | \
			                 grep -Eo '[0-9\.fx]+' )"

			add_attribute 'RX bytes'
			add_values    "$(sed "s/  /\n/g" ${nw_info} | \
			                 grep -i 'RX bytes' | awk -F: {'print $2'})"

			add_attribute 'TX bytes'
			add_values    "$(sed "s/  /\n/g" ${nw_info} | \
			                 grep -i 'TX bytes' | awk -F: {'print $2'})"

			add_footer    "iface"
		done
	add_footer    'computer'

	flush_values
}

	function get_hostname() {
		hostname 2> /dev/null
	}

	function get_mac_address() {
		# debug only!
		/sbin/ifconfig eth0 | grep -Eo '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}'
	}

	### network helper functions
	##
	# detects the ip type (static or dynamic) based on some common
	# configuration files. works on Debian, Ubuntu and Gentoo.
	function detect_ip_type () {
			local nw_conf_files="/etc/network/interfaces
			                     /etc/conf.d/net"
			for nwfile in $nw_conf_files; do
				if [ -e $nwfile ]; then

					# grep for the word 'dhcp' and the iface name in the config file
					if [ "$(grep -v ^# $nwfile | grep $interface_name | grep -i dhcp)" ]; then
						echo    'DHCP'

					# grep for the word 'static' or the ip address and the iface
					elif [ "$(grep -v ^# $nwfile | grep $interface_name | \
					          grep -i "static\|$ipv4\|$ipv6")" ]; then
						echo    'static'

					else # give up
						echo    'undetermined'
					fi
				fi
			done
	}
	############################


###################################################
# MODULE WLAN
#
# detects wireless network access points
#
# uses wireless-tools (iwconfig, iwlist)
# Linux only
#
# under developement, does not yet work!
Module_wlan() {
	local moduleName="Wlan information"
	module_header	"${moduleName}"

	iw_src="$(mktemp /tmp/osinfo.XXXXXX)"
	ap_src="$(mktemp /tmp/osinfo.XXXXXX)"
	cell_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$iw_src" "$ap_src" "$cell_tmp")
	#TempFiles=("${TempFiles[@]}" "$cell_tmp")

	if [ ! "$(type -p iwconfig)" ]; then

		info "No wireless extensions found"

	elif [ "$SYSTEM" == "linux" ] ; then

		# get the basic info
		iwconfig 2>/dev/null > $iw_src
		local wlan_devices="$(grep 'IEEE 802' ${iw_src} | awk  {'print $1'})"
		iwlist $wlan_devices scan 2> /dev/null > $ap_src


		# for debugging purposes
		if [ "$fake" == 1 ]; then
			iw_src="debug/wlan-iwconfig-on"
			wlan_devices="eth1"
			ap_src="debug/wlan-stations"
		fi

		local ap_count="$(grep -i cell $ap_src | wc -l)"

		# print status
		if [ "$ap_count" -ge 1 ]; then
			info "$ap_count access points found by device $wlan_devices"
		else
			info "No access points found by device $wlan_devices"
		fi

		# process all access points
		IFS_bak="$IFS"
		IFS=$'\n'

		for access_point in $(grep -i cell ${ap_src}); do

			# this functions extracts each cell into a temp file
			extr_node $access_point $ap_src Cell > $cell_tmp

			add_header    "$(awk -F: '/ESSID/ {print $2}' $cell_tmp | sed 's/\"//g')"

			if [ $accociated ]; then
				#access_points[${access_points[@]}]="$(grep -A 1 -i ${access_point}" \
				#awk -F: '/ESSID/ {print $2}' | sed 's/\"//g' )"


				#add_attribute   'associated ESSID'
				#add_header    "$(grep -Eo 'ESSID[:"A-Za-z/ ]*' "${iw_src}" | \
				#                awk -F: {'print $2'})"

				add_attribute   'device node'
				add_values      "$(grep -Eo '^[a-z0-9]'+ ${iw_src})"
								# the device associated to this AP

				add_attribute   'device'
				#add_values     "some_device_from_mod_devices"
			fi

			add_attribute   'link quality'
			add_values      "$(grep -Eo 'Quality[\=:][a-zA-Z0-9\/]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"
			add_attribute   'address'
			add_values      "$(awk -F"Address:" '{print $2}' $cell_tmp | sed 's/^\ *//')"

			add_attribute   'channel'
			add_values      "$(grep -Eo 'Channel[\=:][a-zA-Z0-9]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"

			add_attribute   'frequency'
			add_attribute   'bit rate'

			add_attribute   'protocol'
			add_values      "$(grep -Eo 'Protocol[\=:][a-zA-Z0-9. ]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"

			add_attribute   'mode'
			add_values      "$(grep -Eo 'Mode[\=:][a-zA-Z]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"

			add_attribute   'encryption key'
			add_values      "$(grep -Eo 'Encryption key[\=:][a-zA-Z]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"
			add_attribute   'encryption type'

			add_attribute   'security mode'

			add_attribute   'signal level'
			add_values      "$(grep -Eo 'Signal level[\=:][-a-zA-Z0-9\/ ]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"


			#value_footer

		done

		IFS="$IFS_bak"

	fi

	#module_footer
	flush_values
}


#######################
# DISTRIBUTION
#
# this module will try to guess which Linux distrobution is installed.
Module_distro() {
	local moduleName="Distribution"
	module_header "${moduleName}"

	# NOTE: do not make distro_* variables local, as they might be used
	# in other modules



	# then call the subfunction
	identify_Linux_distro


	# then output what the was found..

	add_attribute 'Root dir'
	add_values    "$root_dir"

	[ "${distro_id}" ] && \
		add_attribute 'Distro ID'
		add_values    "${distro_id}"

	[ "${distro_release}" ] && \
		add_attribute 'Release'
		add_values    "$distro_release"

	[ "${distro_codename}" ] && \
		add_attribute 'Codename'
		add_values    "$distro_codename"

	[ "${distro_description}" ] && \
		add_attribute 'Description'
		add_values    "$distro_description"

	[ "$SlackwareBase" ] && \
		add_values  'Based on Slackware version' \
		            "$SlackwareBase"

	flush_values
}

	## DISTRIBUTION SUBFUNCTIONS ##################################
	##
	# distro_lsb_release
	#
	# Gets data from lsb_release
	# Parameters:
	#  1  string   what value to get.
	distro_lsb_release() {
		lsb_release -a 2> /dev/null | grep -i "^$1" | awk -F: '{print $2}' | sed -s 's/^\t*//'
	}

	###
	# identify_Linux_distro
	#
	# the default tool to use is the lsb-release (Linux Standard Base
	# version reporting utility)
	#
	# a secondary id source are the unique files in /etc/, and as a last
	# resort the /etc/issue file. this makes it possible to identify
	# a distro which resides in a chroot environment, or from a livecd.
	identify_Linux_distro() {

		# locate and echo the root directory.
		# TODO: Some of this isn't actually needed as we allready fixed so there is at most one endning / (can be zero ending / too).
		[ "$prefix" != '/' ] && \
			root_dir="$(echo $prefix | sed 's/\/*$//')" || \
			root_dir="$prefix"
		[ "$root_dir" != '/' ] && root_dir="${root_dir}/"



		# look for lsb-release if real root is used.
		#set -x
		if [ "$(type -p lsb_release)" ] && [ "$prefix" == '/' ]; then

			distro_id="$(distro_lsb_release 'distributor')"
			distro_release="$(distro_lsb_release 'release')"
			distro_codename="$(distro_lsb_release 'codename')"
			distro_description="$(distro_lsb_release 'description')"

		else

			# Begin searching for distro identifying files
			local found_files="" myfile
			for myfile in ${root_dir}etc/{SuSE-release,fedora-release,redhat-release,slackware-version,Topologilinux-version,gentoo-release,issue}; do
				[ -e $myfile ] && found_files="$found_files $myfile"
			done

			# Now make a list of distros from the $found_files list above
			local found_distros="" distro_ident
			for distro_ident in $found_files; do
				case $distro_ident in
					"${root_dir}etc/SuSE-release")
						found_distros="$found_distros SuSE"
						break
						;;
					"${root_dir}etc/fedora-release")
						found_distros="$found_distros Fedora Core"
						break
						;;
					"${root_dir}etc/redhat-release")
						found_distros="$found_distros Red Hat"
						break
						;;
					"${root_dir}etc/slackware-version")
						found_distros="$found_distros Slackware"
						break
						;;
					"${root_dir}etc/Topologilinux-version")
						found_distros="$found_distros Topologilinux"
						break
						;;
					"${root_dir}etc/gentoo-release")
						found_distros="$found_distros Gentoo"
						break
						;;
					# if nothing previous matches, then use /etc/issue
					# AnMaster: Inform user that this might be very wrong...
					"${root_dir}etc/issue")
						found_distros="$found_distros misc"
						break
						;;
				esac
			done
			# Remove leading spaces.
			found_distros="$(sed 's/^ *//' <<< "${found_distros}")"


			# Get distro name
			# NOTE: have been changed to case-insensitive, although
			# has not been thoroughly tested. the commented code
			# may be removed after verifying the new code works.
			case "$(echo ${found_distros} | tr 'A-Z' 'a-z')" in
				'suse'|'fedora core'|'fedora'|'red hat'|'slackware'|'slackware topologilinux'|'gentoo'|'ubuntu')
				#'SuSE'|'Fedora Core'|'Fedora'|'Red Hat'|'Slackware'|'Slackware Topologilinux'|'Gentoo'|'Ubuntu')

					distro_id="${found_distros}"

					# clear spaces
					#[ "$found_distros" = 'Slackware Topologilinux' ] && \
					#	found_distros='Topologilinux'
					#[ "$found_distros" = 'Red Hat' ] && found_distros='RedHat'
					#[ "$found_distros" = 'Fedora Core' ] && found_distros='Fedora'
					;;

				'topologilinux')
					print_error 1 "This module will abort." "$usekdialog" \
						"Topologilinux is based on Slackware and should" \
						"contain ${root_dir}etc/slackware-version AND " \
						"${root_dir}etc/Topologilinux-version."
					return 1
					;;

				'misc')
					for misc_distro in 'Ubuntu' 'Fedora' 'SuSE'; do
						if [ "$(grep -i ${misc_distro} ${distro_ident})" ]; then
							distro_id="${misc_distro}"
						fi
					done
					;;

				'')
					# Abort if no distro found
					print_error 1 "This module will abort." "$usekdialog" \
								  "You have zero distros installed or use a distro " \
								  "not recognised by ${appname}"
					return 1
					;;

				#*)
					# Abort if more than one distro
					#if [ "$usekdialog" == "1" ]; then
						#kdialog --error  "You have several distros installed at the \
						#same time.\nInstalled distros:\n${found_distros}\n\
						#This module will abort."
					#else
						#echo "${tcRED}ERROR:${tSTD} You have several distros \
							#installed at the same time."
						#echo "${tcRED}ERROR:${tSTD} ${tBOLD}Installed distros:${tSTD}\
							#${found_distros}"
						#echo "${tcRED}This module will abort.${tSTD}"
					#fi
					#return 1
				#;;
				esac


			# Output distro version
			case "${found_distros}" in
				'SuSE')
					distro_release="$(grep -F 'VERSION = ' ${root_dir}etc/SuSE-release          | sed 's/VERSION = //'    )" ;;
				'Red Hat')
					distro_release="$(cat ${root_dir}etc/redhat-release)" ;;
				'Fedora')
					distro_release="$(cat ${root_dir}etc/fedora-release)" ;;
				'Slackware')
					distro_release="$(grep -F 'Slackware ' ${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
				'Topologilinux')
					distro_release="$(grep -F 'Topologilinux ' ${root_dir}etc/Topologilinux-version | sed 's/Topologilinux //')"
					local  SlackwareBase="$(grep -F 'Slackware  '${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
				'Gentoo')
					# AnMaster: Not sure if readlink is POSIX but it exists on Gentoo and we allready know this is Gentoo.
					distro_release="$(readlink /etc/make.profile | grep -Eo '[0-9]{4}\.[0-9]')";;
				'misc')
					# FIXME: AnMaster: . is a wildcard meaning any single char. Isn't grep -F what you want?
					distro_release="$(grep '.' "${root_dir}etc/issue" | grep -Eo '([A-Za-z0-9 ."])+' | head -n 1 )";;
					# TODO: improve the grep
			esac

		fi
	}
	#############################################################


#######################
# APPLICATIONS
#
# version information of standard *nix, dev, and dependency packages.
# probably should take an additional switch like --X, --server, etc.
Module_applications() {
	local moduleName="Applications"
	module_header "${moduleName}"

	local APPLICATIONS app versionstring category cat_print=0
	local missing_ERRMSG="if you want to be able to use all modules of ${appname}"
	

	## Applications to look for..
	if [ "$SYSTEM" == "linux" ] ; then

		APPLICATIONS="Graphical_interface: X kde-config gnome-about xfce4-session \
		              fluxbox fvwm2 enlightenment \
			Shells: bash csh dsh fish pdsh rrs tcsh zsh \
			Compilers: gcc gcj icc \
			System: udevinfo \
			Userspace_tools: make unsermake awk sed grep ls gzip lspci lshw dmidecode smartctl hdparm \
			Languages: perl python java-config ruby php \
			Servers: apache2 mysql ssh smbd cups-config \
			Miscellaneous: x11vnc nagios firefox thunderbird mozilla"

		UNTESTED="Graphical_interface: \
			Compilers: ccc cxx cfal erlang fpc gforth ghc gnat \
		               gnat-gcc gnat-gpl gpc icc ifc open-cobol \
			Tools: mono"

			# Shells: ash ccsh dash esh ksh mksh psh rssh sash shish
			# don't take any version parameters


	elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then

		APPLICATIONS="Graphical_interface: X kde-config gnome-about \
			Shells: bash csh dsh fish pdsh rrs tcsh zsh \
			Compilers: gcc gcj icc \
			Tools: awk grep gzip lshw dmidecode lspci lshw smartctl hdparm \
			Languages: perl python java-config ruby php \
			Servers: apache2 mysql ssh smbd cups-config \
			Miscellaneous: x11vnc"

	fi


	## Write the header for output
	if [ $usexml = 1 ]; then
		add_attribute "Applications" 'software'
	fi


	## Process all categories
	for app in $APPLICATIONS; do
		# if the variable $app is a category definition,
		if [ $(grep \: <<< $app) ] && [ $usexml -eq 0 ]; then

			category="$(sed 's/\:// ; s/_/\ /g' <<< $app)"

			# check verbosity level, do not print shells
			# if verbosity is less than 1
			if [ $isverbose -lt 1 ] && [ "$category" == "Shells" ]; then
				cat_print=0
			else 
				# print the category to stdout
				cat_print=1
				add_header "$category"
			fi

			flush_values

		# use the subfunction to get the version information
		elif [ "$(type -p $app)" ] && [ $cat_print -eq 1 ]; then # it is installed
			versionstring="$(get_version $app)"
			# if the application doesn't tell what it is, echo it
			if [ "$(grep -i ${app} <<< ${versionstring})" ]; then
				add_values	"\t${versionstring}\n"
			else
				add_values	"\t${versionstring} ($app)\n"
			fi
		fi
	done

	flush_values
}

	###########################################
	# helper functions for applications module
	get_version() {
		local app="${1}"
		case "$app" in
			'perl')
				echo  "Perl" $($app --version 2>&1 | grep 'perl, v' | \
							   grep -Eo 'v[ A-Za-z0-9.-]*')
				;;
			'python')
				python -V 2>&1 | head -n 1 
				;;
			'X')
				X -version 2>&1 | grep Revision
				;;
			'kde-config')
				kde-config -version 2>&1 | grep KDE
				;;
			'gnome-about')
				gnome-about --version 2>&1 | sed 's/gnome-about//'
				;;
			'xfce4-session')
				xfce4-session --version | head -n 1 | sed 's/xfce4-session/Xfce4/'
				;;
			'fluxbox')
				fluxbox -version 2> /dev/null | head -n 1
				;;
			'apache2'|'apache')
				$app -V | head -n 1 | awk -F': ' {'print $2'}
				;;
			'cups-config')
				echo  "Cups $($app --version 2>&1 )"
				;;
			'smbd')
				echo  "Samba $($app -V 2>&1 )"
				;;
			'udevinfo')
				$app -V 2>&1 
				;;
			'awk')
				# awk is a bit tricky.. it can go into a captive cmd interpreter mode
				if [ ! "$(awk -V 2> /dev/null)" ]; then
					awk -W version 2>&1 | head -n 1 
				else
					awk -V
				fi
				;;
			'dmidecode')
				echo  "dmidecode $(dmidecode -V 2> /dev/null )"
				;;
			'java-config')
				echo "Java $(java-config -f)"
				;;
			'ssh')
				ssh -V 2>&1 /dev/null
				;;
			'icc')
				icc 2>&1 -V | head -n 1
				;;
			'ls')
				ls --version | head -n 1 | sed 's/ls// ; s#(\|)\|^\ ##g'
				;;
			'pdsh')
				pdsh -V | head -n 1
				;;
			'firefox')
				firefox --version 2>/dev/null | head -n 1
				;;
			*)
				$app --version 2>&1 | grep '\w' | head -n 1
				;;
			'lspci')
				info "please install pciutils ${missing_ERRMSG}"
				;;
			'lshw')
				info "please install lshw ${missing_ERRMSG}"
				;;
			'smartctl')
				info "please install smartmontools ${missing_ERRMSG}"
				;;
			'dmidecode')
				info "please install dmidecode ${missing_ERRMSG}"
				;;
		esac
	}
	###########################################


#######################
# ENVIRONMENT VARIABLES
#
# xml only, stdout is not needed
Module_env() {
	local moduleName="Environment variables"
	module_header "${moduleName}"

	## Write the header for output
	add_attribute   'System enviroment variables\n' \
	                'system_enviroment_variables'
	## Process all variables
	for var in $(env); do

		add_values  "${var}\n"

	done

	#module_footer
	flush_values
}

