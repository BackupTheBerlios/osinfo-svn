################################################################################
################################################################################
## General helper functions                                                   ##
################################################################################
################################################################################

##
# Checks if lshw was already run.
#  if it wasn't then run lshw and export the filename of the temporary file.
#  otherwise just return.
lshw_xml() {
	if [ -z "$lshw_xml_file" ]; then
		export lshw_xml_file="$(mktemp /tmp/osinfo.XXXXXX)"
		lshw -xml > "$lshw_xml_file"
	fi
}

##################################
# extracts a node from input file
# based on indentation, and the begin and end keywords
#
# operation is case-insensitive
#
#	parameters:
#	(1) node id, the begin keyword
#	(2) input file
#	(3) node closer, the end keyword, defaults to 'node id'
extr_node() {
	local node_id="${1}"
	local input_file="${2}"
	local node_closer="${3}"
	local nr node
	local all_nodes=""
	local node_count=0

	input_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$input_tmp" )

	# add line numbers
	grep -n . "${input_file}" > "$input_tmp"

	# if a special node closer is not defined, use the node_id
	[ ! "$node_closer" ] && node_closer="${node_id}"

	# get all matching nodes and node count
	all_nodes="$(grep  -i "${node_id}" "$input_tmp")"
	# NOTE: this uses an extra grep, because '<<<' adds a '\n' and
	# wc counts an empty variable line length as '1'
	node_count="$(grep -i "${node_id}" <<< "${all_nodes}" | wc -l)"

	if [ $node_count -ge 1 ]; then

		# this loop extracts the information between the node begin
		# and end lines, based on indentation level (xml), echoing
		# the results out
		for nr in $(seq 1 1 $node_count); do
			this_node="$(sed -n "$nr{p;q;}" <<< "${all_nodes}")"

			# this gets the line number of the wanted node from lshw
			local begin="$(awk -F: {'print $1'} <<< ${this_node})"
			local node_indent="$(awk -F: {'print $2'} <<< "${this_node}" | \
					     grep -Eo '^[ ]*' | wc -m)"

			# this loop takes care that all subnodes are included, by comparing
			# the indentation level. not very elegant..
			# basically it just searches for $node_closer and gets the line#
			IFS_bak="$IFS"; IFS=$'\n' ;
			for node in $(sed -n "$(($begin+1)),\${p;}" $input_tmp | \
			              grep ${node_closer}); do

				# if the indentation matches...
				if [ "$(awk -F: {'print $2'} <<< ${node} | grep -Eo '\ *' | \
					wc -m)" == "$node_indent" ]; then

					# read the line# to $nigeb (begin backwards)
					# the line number of the closing node
					local nigeb="$(awk -F: {'print $1'} <<< "${node}" )"
					((nigeb--)) # this prevents the closing node to displaying
					            # as sometimes this may not be wanted
					break;

				fi

			done

			# if the closing node wasn't found, read to EOF
			[ ! "$nigeb" ] && nigeb="$"
			IFS="$IFS_bak"

			# then what's between the first node and the closing id
			# is echoed to whichever function called this
			echo "%node $nr%"
			sed -n "$begin,$nigeb{p;}" $input_file

		done
	fi
}

# extracts value from <xml>value</xml>
extr_xml_value() {
	#sed 's/[^>]*>\([^<]*\)<[^.]*/\1/' <<< "${1}"
	sed 's/[^>]*>\([^<]*\)\(<[^.]*\)*/\1/' <<< "${1}"
}


TempFiles=()
##
# Cleans up some temporary files in the TempFiles array.
#
cleanup_temp_files() {
	if [ "$lshw_xml_file" ]; then
		rm -f "$lshw_xml_file"
	fi
	local File
	for File in "${TempFiles[@]}"; do
		rm -f "$File"
	done
}

##
# Keeps track of open headers, and closes them in the correct
# order upon flush_values.
OpenHeaders=()






########
# LVM
# fake module that calls the hdd subfunction
Module_lvm () {
	local moduleName="Logical Volumes"
	module_header "${moduleName}"

	if CheckReq_root; then
		scan_hdd_lvm
	fi

	flush_values
}


######################
# buses
#
Module_bus () {
	module_header "Data buses"
	local sysfs_prepath="/sys/devices/ide"
	local ide_devices="0/0.0 0/0.1 1/0.0 1/0.1"


	# IDE bus
	add_header "IDE bus"
	for ide_path in $ide_devices; do
		if [ -e "$sysfs_prepath$ide_path" ]; then
			add_attribute "IDE $(sed 's/^.\///' <<< $ide_path)"
			add_values    "$(cat $sysfs_prepath$ide_path/media)"
		fi
	done
	add_footer


	flush_values
}



# INFORMATION OF THE TERMINAL IN USE
Module_terminal() {
	local moduleName="Terminal info"
	module_header "${moduleName}"

	add_attribute "Terminal type"
	add_values    "$TERM"

	# TODO
	#add_attribute "Terminal encoding"
	#add_values    "?"

	add_attribute "Terminal speed"
	add_values    "$(stty speed)"

	add_attribute "Rows"
	add_values    "$(stty size | awk '{print $1}')"

	add_attribute "Columns"
	add_values    "$(stty size | awk '{print $2}')"

	flush_values
}


#######################
# PRINTERS AVAILABLE TO THE SYSTEM

# EXPERIMENTAL!

# uses only lpstat (cups) and hasn't been tested on multi-printer
# environments
#
# TODO: add some kind of timeout function
Module_printers() {
	local moduleName="Printers"
	module_header "${moduleName}"

	local lp_nr

	# first of all, check if lpstat is available
	if [ "$(type -p lpstat)" ]; then

		#  if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then

		add_attribute 	'Printer'	'local_printer'

		# as there may be several printers, print info from all
		#for lp_nr in $(seq 1 1 $(lpstat -a | wc -l) ); do
		#	add_values  "$(lpstat -a 2> /dev/null | sed -n "$lp_nr{p;q;}")"
		#done

		add_attribute	'model'
		add_attribute	'location'
		add_attribute	'server'
		add_attribute	'spooler'
		add_attribute	'status'
		add_attribute	'completed jobs'

	fi

	#module_footer
	flush_values
}





#######################
# ENVIRONMENT VARIABLES
#
# xml only, stdout is not needed
Module_env() {
	local moduleName="Environment variables"
	module_header "${moduleName}"

	## Write the header for output
	add_attribute   'System enviroment variables\n' \
	                'system_enviroment_variables'
	## Process all variables
	for var in $(env); do

		add_values  "${var}\n"

	done

	#module_footer
	flush_values
}

