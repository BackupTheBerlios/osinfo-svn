#!/bin/bash
################################################################################
# List System information                                                      #
#   supports currently only Linux, FreeBSD support under development
################################################################################
# Written by Arvid Norlander and Mikael Lammentausta                           #
# Some parts are taken from:                                                   #
#   --Advanced Bash Scripting Guide (ABS)                                      #
################################################################################

MODULES_LINUX='distro applications terminal network devices users processor system lsmod hdd printers oem'
MODULES_REAL_ROOT_ONLY='system terminal applications network devices modprobe hdd printers oem'
MODULES_BSD='system applications terminal network'



################################################################################
################################################################################
## Modules                                                                    ##
################################################################################
################################################################################




Module_hdd() {
	moduleName="Disk information"
	print_module_header "${moduleName}"

	if [ ! "$(whoami)" == "root" ]; then
		add_name_value_pair "OSINFO" "Please run $appname as super-user to collect this information"

	else

	# principle/TODO
	# get as much information as is possible from df, fdisk and the /proc tree; then
	# if hdparm, smartctl, lshw are not available && there are devices for the tools; then
	# print information that the user should install the tools;
	# else print everything in nice format

	# TODO: SCSI is still untested, although works probably as SATA

	#		for DRV in `seq 1 $(fdisk -l | grep -i disk | wc -l)`; do 
	#			drives[$DRV]=$(fdisk -l | grep Disk | grep -Eo '\/(dev)\/\w'+)
	#		done

		drives="$(fdisk -l | grep Disk | grep -Eo '\/(dev)\/\w'+)"
		# the drives variable now holds all drives in the system

		TOTALSIZE=0
		TOTALFREE=0
	
		# then print information of each drive
		#FREEBSD: To check the status of drives, use the following:

		#        ${PREFIX}/sbin/smartctl -a ad0          for first ATA drive
		 #       ${PREFIX}/sbin/smartctl -a da0          for first SCSI drive

		# using the dmesg log file to the fetch drive information. this is based on the
		# standard Linux way of coding device information. therefore it's not very flexible.
		#dmesgtmp="$(mktemp osinfo.XXXXXX)" # mktemp -t isn't portable
		#cat /var/log/dmesg | grep -i disk > $dmesgtmp
		#cat $dmesgtmp | grep '^hda' | awk -F': ' {'print $2'}

	
		#for DRV in `seq 1 ${#drives[@]}`; do
		for DRV in $drives; do

			DRVNAME=$(echo $DRV | awk -F/ {'print $NF'})

			#value_pair_header=${drives[$DRV]}
			#value_pair_header=${DRV}
			value_header ${DRV}


			################# IDE drives
			if [ "$(echo $DRV | grep hd)" ]; then

				if [ -e "/proc/ide/ide0/$DRVNAME" ]; then
					add_values	'Driver'			"$(cat /proc/ide/ide0/$DRVNAME/driver)" 
					add_values	'Manufacturer'		"$(echo n/a)" # /proc/ide/ide0/hda/identify is in binary
					add_values	'Model'				"$(cat /proc/ide/ide0/$DRVNAME/model)"
					#add_values	'Model'				"$(hdparm -i ${DRV} | grep -Eio 'Model=\w+' | awk -F= {'print $2'})"
					#add_values 'Capacity'          "$(echo $(($(cat /proc/ide/ide0/$DRVNAME/capacity)/1024/1024)) GB)" # why this is incorrect?
				fi

				add_values	'Capacity'			"$(fdisk -l ${DRV} | grep ${DRV} | head -n 1 | grep -Eo '[1-9][0-9]+\.[0-9] \w{2}')"

			fi

            ################# SATA/SCSI drives
            if [ "$(echo $DRV | grep sd)" ]; then

				add_values	'Manufacturer'		"$(echo n/a)"
				add_values	'Model'				"$(echo n/a)"
				add_values	'Serial'			"$(echo n/a)"
				#add_values	'Serial'			"$(cat $tmp | grep -Ei '(serial)' | awk {'print $NF'})"
				#add_values 'Serial'            "$(hdparm -i ${drives[$DRV]} | grep -Eio 'serialno=\w+' | awk -F= {'print $2'})"
				#add_values	'Capacity'			"$(fdisk -l ${drives[$DRV]} | grep ${drives[$DRV]} | head -n 1 | grep -Eo '[1-9][0-9]+\.[0-9] \w{2}')"
	
				#add_values	'DMA'				"$()" # enabled/disabled
				#add_values	'SMART'				"$(cat $tmp | grep 'SMART support' | head -n 1 | awk -F': ' {'print $2'})" 
				#add_values	'SMART'				"$(cat $tmp | grep 'SMART support' | tail -n 1 | awk -F': ' {'print $2'})" # is it on?

				#tmp="$(mktemp  osinfo.XXXXXX)"
				#smartctl -a ${drives[$DRV]} > $tmp		# << TODO: fix this not to error if smartctl is unavailable
	
				#if [ -e "$tmp" ]; then
					#add_values	'Lifetime'			"$(cat $tmp | grep -i power_on_hours | awk {'print $NF'}) hours"
					#add_values	'Health Status'		"$(cat $tmp | grep -Ei '(health)+' | awk {'print $NF'})"
					#add_values	''		"$()"
					#add_values	''		"$()"
				#fi

			fi 
			
			flush_values

			##### COMMON for all drive types

			#DISKSIZE="$(fdisk -l ${drives[$DRV]} | grep ${drives[$DRV]} | head -n 1 | grep -Eo '[0-9]{4,}')" # in bytes
			#DISKFREE=0

			# TODO: an array that's like this:
			# [partition ID=83] [size on hda1] [size on hda4]
			# [partition ID=7] [size on hda2] [size on hdb1]

			add_values	'Free'				"$(echo n/a)"


#			for PARTNR in `seq 1 $(fdisk -l ${drives[$DRV]} | grep ^${drives[$DRV]} | wc -l)`; do 

#				PARTITION="$(fdisk -l ${drives[$DRV]} | grep ^${drives[$DRV]} | awk {'print $1'} | sed -n "${PARTNR}{p;q;}" )"
#				if [ "$(df -Plk | grep $PARTITION)" ]; then

#					PARTSIZE="$(df -Plk | grep $PARTITION | awk {'print $2'})"
#					PARTFREE="$(df -Plk | grep $PARTITION | awk {'print $3'})"
#					PERCFREE="$(($PARTFREE/$PARTSIZE))" # <<< rounds off improperly, how to fix????

#					value_pair_header=$PARTITION

#					add_values 'Filesystem'	"$(fdisk -l ${drives[$DRV]} | grep ^$PARTITION | awk {'print $6'})"
#					add_values 'Capacity'		"$(echo $PARTSIZE bytes)"
#					add_values 'Free'			"$(echo $PARTFREE bytes ";" $PERCFREE %) "

#					flush_values

#					DISKFREE=$(($DISKFREE+$PARTFREE))

#				fi

#			done

#			TOTALSIZE=$(($TOTALSIZE+$DISKSIZE))
#			TOTALFREE=$(($TOTALFREE+$DISKFREE))

#			value_pair_footer=${drives[$DRV]}
			value_pair_footer=${DRV}

		done

		value_pair_header="Total disk space"
		add_values	'Capacity'		"$(echo $TOTALSIZE)"
		add_values	'Free'			"$(echo -e $TOTALFREE "; xx%" )" 
		value_pair_footer="Total disk space"


	fi

	flush_values
	print_module_footer "${moduleName}"
}


Module_oem() {
	moduleName="OEM information"
	print_module_header "${moduleName}"

	if [ ! "$(type -p lshw)" ]; then
		add_name_value_pair "OSINFO" "Please install LSHW to collect this information"

	elif [ ! "$(whoami)" == "root" ]; then
		add_name_value_pair "OSINFO" "Please run $appname as super-user to collect this information"

	else

	tmp="$(mktemp osinfo.XXXXXX)"
	lshw > $tmp

	# principle:
	# (1) output of lshw is stripped out of newlines, switched spaces with _ and added ¡ to denote a value pair
	# (2) this is put into hardware array, because bash doesn't support two-dimensional arrays 
	# (3) a for loop then checks each array element for OUTPUT type node ID.
	# (4) another loop checks for DO_NOT_OUTPUT ; if this is satisfied, value_name_pair is added


	OUTPUT="$(hostname)\|cpu\|core\|firmware\|memory\|cdrom\|disk" 
	DO_NOT_OUTPUT="description\|capabilities\|configuration\|resources\|physical\|bus"

	[[ "$isverbose" -eq 1 ]] && 
		OUTPUT=$OUTPUT"\|ide\|pci\|usb"


	HW_ARRAY=1;
	# TODO: fix the sed to cut all whitespaces before first word boundary
	for HW in `seq 1 $(

		cat $tmp | sed 's/  //g' | tr ' ' '_' | sed ':a;N;$!ba;s/\n/¡/g' | awk -F"*" {'print NF'}

	)`; do

		hardware[$HW_ARRAY]="$(

			cat $tmp | sed 's/  //g' | tr ' ' '_' | sed ':a;N;$!ba;s/\n/¡/g' | awk -F"*" {'print $'$HW' '}

		)" ; ((HW_ARRAY++))

	done


	# the hardware array now contains the ' ' separated entries from lsmod. 
	# [1] node type		# [2,3 ; 4,5 ; ....] value pairs
	# ${#hardware[@]} # is the number of node types


	for HW_ARRAY in $(seq 1 ${#hardware[@]}); do

		if [ "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $1'} | grep -i $OUTPUT)" ]; then # we want output

			myELEMENT=2;

			while [ "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print NF'})" -gt "$myELEMENT" ]; do # parse all elements in the array


				if [ ! "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | grep -i $DO_NOT_OUTPUT)" ]; then # not too much information

					add_name_value_pair "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | awk -F":_" {'print $1'} | tr '_' ' ')" \
										"$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | awk -F":_" {'print $2'} | tr '_' ' ')" 


				elif [ "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | grep -i 'description')" ]; then

					[[ "$value_pair_header" ]] && flush_name_value_pair
					value_pair_header="$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | awk -F":_" {'print $2'} | tr '_' ' ')"


				fi

				((myELEMENT++));

			done
		fi
	done
	
	rm $tmp -f

	fi
	flush_name_value_pair
	print_module_footer "${moduleName}"
}


Module_system() {
	moduleName="System"
	print_module_header "${moduleName}"

	add_values $"Operating system"      "$(uname -s)"
	add_values $"Network node hostname" "$(hostname)"
	add_values $"Kernel release"        "$(uname -r)"
	add_values $"Machine hardware name" "$(uname -m)"
	add_values $"System locale"         "$(echo $LC_LANG)"
	add_values $"System uptime"         "$(uptime | awk -F, {'print $1'} | grep -Eo 'up [a-z0-9: ]*')"

	flush_values
	print_module_footer "${moduleName}"
}

Module_processor() {
	moduleName="Processor"
	print_module_header "${moduleName}"

	add_name_value_pair $"Processor model"       "$(cat /proc/cpuinfo | grep 'model name' | awk -F': ' {'print $2'})"
	add_name_value_pair $"Processor frequency"   "$(cat /proc/cpuinfo | grep 'cpu MHz' | awk -F': ' {'print $2" MHz"'})"

	#TODO: fix double-entries with hyper-threading processors:
	#Processor model:      Intel(R) Pentium(R) 4 CPU 2.80GHz Intel(R) Pentium(R) 4 CPU 2.80GHz
	# update this to use lshw

	flush_name_value_pair
	print_module_footer "${moduleName}"
}

Module_terminal() {
	moduleName="Terminal info"
	print_module_header "${moduleName}"

	add_name_value_pair 'Terminal type'         "$TERM"
	add_name_value_pair 'Terminal speed'        "$(stty speed)"
	add_name_value_pair 'Rows'                  "$(stty size | awk '{print $1}')"
	add_name_value_pair 'Columns'               "$(stty size | awk '{print $2}')"

	flush_name_value_pair
	print_module_footer "${moduleName}"
}

Module_printers() {
	# this ugly hack prevents output if no printer is present, although needs debugging
#	if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then	

	moduleName="Printers"
	print_module_header "${moduleName}"

	add_name_value_pair 'printer'		"$(lpstat -a | awk {'print $1'})"
	# TODO: test in a system with many printers

	flush_name_value_pair
	print_module_footer "${moduleName}"

#	fi
}


Module_users() {
    moduleName="Users and processes"
    print_module_header "${moduleName}"

	add_name_value_pair 'Last logged in user' 	"$(last | head -n 1)"
#	add_name_value_pair 'Users' 			"$(ls /home/)"
#	add_name_value_pair 'Groups'  			"$(cat /etc/group | awk -F: {'print $1'} | sed 's/\n/  /g')"

	# perhaps the solution is to ditch out standard linux non-human users, then print the rest
	# AnMaster answers: check by uid. On gentoo normal users got uid > 1000. Some distros use 500.
	# -it has to work with all distros. 

	flush_name_value_pair
	print_module_footer "${moduleName}"
}


Module_lsmod() {
	# rename to 'drivers'
	moduleName="Device drivers"
	print_module_header "${moduleName}"

	# usb
	# ide
	# /proc/ide/drivers
	# scsi
	# etc...
	
#	for MODULE in $(lsmod | awk {'print $1'} | grep -v Module); do
#		add_name_value_pair 'module' "$MODULE"
#	done
	# TODO: needs more work

	flush_name_value_pair
	print_module_footer "${moduleName}"
}



Module_network() {
	moduleName="Network information"
	print_module_header "${moduleName}"

	if [ "$SYSTEM" == "linux" ] ; then
		ETH_DEVICES="$(ifconfig | grep BROADCAST -B 2 | grep -v LOOPBACK | grep -Ev '(^ )|(^--)' | awk  {'print $1'})"

	else
		ETH_DEVICES="$(ifconfig | grep BROADCAST | grep -v LOOPBACK | awk -F': ' {'print $1'})"

	fi


	local specials="UP|BROADCAST|LOOPBACK|NOARP|NOTRAILERS|RUNNING|MULTICAST"
	# what are these needed for?
	
	for interface_name in $ETH_DEVICES; do 

		value_pair_header="$interface_name"
		#	add_values 'Device'	"$interface_name"

		add_values 'MAC'	"$(ifconfig $interface_name | grep -Eo '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}')"
		add_values 'IPv4'	"$(ifconfig $interface_name | \
					grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | grep -Eo '[0-9\.]+' )"

		add_values 'IPv6'	"$(ifconfig $interface_name | sed "s/  /\n/g" | \
					grep -i inet6 | grep -Eio '([0-9a-f]{3,4}(\:){1,2}){4,8}([0-9a-f]{3,4})' )"

		add_values 'Broadcast'	"$(ifconfig $interface_name | sed "s/  /\n/g" | \
					grep -Eio 'cast[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | grep -Eo '[0-9\.]+' )"

		add_values 'Netmask'	"$(ifconfig $interface_name | sed "s/  /\n/g" | \
			grep -Eio 'mask[A-Za-z: ]*((([0-9]{1,3}\.){3}[0-9]{1,3})|(0x[0-f]{8}))' | grep -Eo '[0-9\.fx]+' )"

		add_values 'RX bytes'	"$(ifconfig $interface_name | sed "s/  /\n/g" | \
									grep -i 'RX bytes' | awk -F: {'print $2'})"	

		add_values 'TX bytes'	"$(ifconfig $interface_name | sed "s/  /\n/g" | \
									grep -i 'TX bytes' | awk -F: {'print $2'})"	

		value_pair_footer="$interface_name"
#		flush_name_value_pair
		flush_values

	done

	print_module_footer "${moduleName}"
}



Module_distro() {
	moduleName="Distribution"
	print_module_header "${moduleName}"

	# echo the root directory
	[ "$prefix" != '/' ] && \
		local root_dir="$(echo $prefix | sed 's/\/*$//')" || \
		local root_dir="$prefix"
	add_name_value_pair 'Root dir'  "$root_dir"
	
	# Begin searching for distro identifying files
	local found_files=""
	local fil
	for fil in ${prefix}etc/{SuSE-release,fedora-release,redhat-release,slackware-version,Topologilinux-version,gentoo-release,issue}; do
		[ -e $fil ] && found_files="$found_files $fil"
	done
	
	# Now make a list of distros from the $found_files list above
	local found_distros=""
	local distro_ident
	for distro_ident in $found_files; do
		case $distro_ident in
			"${prefix}etc/SuSE-release")
		    found_distros="$found_distros SuSE"
		    break;
		    ;;
		"${prefix}etc/fedora-release")
		    found_distros="$found_distros Fedora Core"			
		    break;
		    ;;
		"${prefix}etc/redhat-release")
		    found_distros="$found_distros Red Hat"
		    break;
		    ;;
		"${prefix}etc/slackware-version")
		    found_distros="$found_distros Slackware"
		    break;
		    ;;
		"${prefix}etc/Topologilinux-version")
		    found_distros="$found_distros Topologilinux"
		    break;
		    ;;
		"${prefix}etc/gentoo-release")
		    found_distros="$found_distros Gentoo"
		    break;
		    ;;
		# if nothing previous matches, then use issue
		# AnMaster: Inform user that this might be very wrong...
		"${prefix}etc/issue")
			found_distros="$found_distros misc"
			break;
			;;
		esac
	done
	# Remove beginning spaces.
	found_distros="$(echo "$found_distros" | sed "s/^ *//")"

	# Output distro name
	case "$found_distros" in
		'SuSE'|'Fedora Core'|'Red Hat'|'Slackware'|'Slackware Topologilinux'|'Gentoo')
			add_name_value_pair 'Distro name'         "$found_distros"
			[ "$found_distros" = 'Slackware Topologilinux' ] && found_distros='Topologilinux'
			[ "$found_distros" = 'Red Hat' ] && found_distros='RedHat'
			[ "$found_distros" = 'Fedora Core' ] && found_distros='Fedora'
			;;
		'Topologilinux')
		# Abort if found Topologilinux but not Slackware.
			if [ "$usekdialog" == "1" ]; then
				kdialog --error  "Topologilinux is based on Slackware and should contain\n${prefix}etc/slackware-version AND ${prefix}etc/Topologilinux-version.\nThis module will abort."
			else
				echo "${tcRED}ERROR:${tSTD} Topologilinux is based on Slackware and should"
				echo "${tcRED}ERROR:${tSTD} contain ${prefix}etc/slackware-version ${tBOLD}AND${tSTD} ${prefix}etc/Topologilinux-version."
				echo "${tcRED}This module will abort.${tSTD}"
			fi
			return 1
			;;
		'misc')
			for DISTRO in 'Ubuntu' 'Fedora' 'SUSE'; do
				if [ "$(grep -i ${DISTRO} ${distro_ident})" ]; then 
					add_name_value_pair 'Distro name'         "$DISTRO"
				fi
			done
			;;
		'')
			# Abort if no distro found
			if [ "$usekdialog" == "1" ]; then
				kdialog --error  "You have zero distros installed or use a distro not recognised by ${appname}\nThis module will abort."
			else
				echo "${tcRED}ERROR:${tSTD} You have zero distros installed or use a distro not recognised by ${appname}"
				echo "${tcRED}This module will abort.${tSTD}"
			fi
			return 1
			;;
#	*)
#		# Abort if more than one distro
#		if [ "$usekdialog" == "1" ]; then
#			kdialog --error  "You have several distros installed at the same time.\nInstalled distros:\n${found_distros}\nThis module will abort."
#		else
#			echo "${tcRED}ERROR:${tSTD} You have several distros installed at the same time."
#			echo "${tcRED}ERROR:${tSTD} ${tBOLD}Installed distros:${tSTD} ${found_distros}"
#			echo "${tcRED}This module will abort.${tSTD}"
#		fi
#		return 1
#	;;
	esac
	# Output distro version
	case "$found_distros" in
		'SuSE')
			local distro_version="$(fgrep 'VERSION = '     ${prefix}etc/SuSE-release          | sed 's/VERSION = //'    )" ;;
		'RedHat')
#			local distro_version="$(fgrep 'VERSION = '     ${prefix}etc/redhat-release        | sed 's/VERSION = //'    )" ;;
			local distro_version="$(cat ${prefix}etc/redhat-release)" ;;
		'Fedora')
			local distro_version="$(cat ${prefix}etc/fedora-release)" ;;
		'Slackware')
			local distro_version="$(fgrep 'Slackware '     ${prefix}etc/slackware-version     | sed 's/Slackware //'    )" ;;
		'Topologilinux')
			local distro_version="$(fgrep 'Topologilinux ' ${prefix}etc/Topologilinux-version | sed 's/Topologilinux //')"
			local  SlackwareBase="$(fgrep 'Slackware '     ${prefix}etc/slackware-version     | sed 's/Slackware //'    )" ;;
		'Gentoo')
			local distro_version="$(ls -ld /etc/make.profile --color=no | grep -Eo '[0-9]{4}\.[0-9]')";;
		'misc')
			local distro_version="$(grep '.' "${prefix}etc/issue" | grep -Eo '([A-Za-z0-9 ."])+' | head -n 1 )";;
			# TODO: improve the grep 
	esac
	add_name_value_pair 'Distro version' "$distro_version"
	[ "$SlackwareBase" ] && add_name_value_pair 'Based on Slackware version' "$SlackwareBase"
	# echo the whole table
	flush_name_value_pair
	print_module_footer "${moduleName}"
}

Module_applications() {
	moduleName="Applications"
	print_module_header "${moduleName}"

	if [ "$SYSTEM" == "linux" ] ; then

		APPLICATIONS="X kde-config x11vnc \
			bash csh ls \
			gcc make \
			awk sed grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			udevinfo lspci lshw smartctl hdparm"

	elif [ "$(echo $SYSTEM | grep bsd)" ]; then

		APPLICATIONS="X kde-config x11vnc \
			csh bash ksh \
			gcc grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			lspci lshw smartctl hdparm"

	fi


	for APP in $APPLICATIONS; do

		if [ "$(type -p $APP)" ]; then # it is installed
			if [ "$APP" == "perl" ]; then
				add_name_value_pair $APP 		"$($APP --version 2>&1 | grep 'perl, v')" 
			elif [ "$APP" == "python" ]; then
				add_name_value_pair $APP 		"$($APP -V 2>&1 | head -n 1 )" 
			elif [ "$APP" == "X" ]; then
				add_name_value_pair 'X11' 		"$($APP -version 2>&1 | grep Revision)"
			elif [ "$APP" == "kde-config" ]; then
				add_name_value_pair 'KDE' 		"$($APP -version 2>&1 | grep KDE)"
			elif [ "$APP" == "gconftool" ]; then
				add_name_value_pair 'Gnome' 		"$($APP --version 2>&1 )"
			elif [ "$APP" == "apache2" ]; then
				add_name_value_pair '$APP' 		"$($APP -V | head -n 1 | awk -F': ' {'print $2'})"
			elif [ "$APP" == "cups-config" ]; then
				add_name_value_pair 'cups' 		"$($APP --version 2>&1 )"
			elif [ "$APP" == "smbd" ]; then
				add_name_value_pair 'samba' 		"$($APP -V 2>&1 )"
			elif [ "$APP" == "udevinfo" ]; then
				add_name_value_pair 'udev' 		"$($APP -V 2>&1 )"
			elif [ "$APP" == "awk" ]; then
				add_name_value_pair $APP 		"$($APP -W version 2>&1 | head -n 1 )"
			else
				add_name_value_pair $APP 		"$($APP --version 2>&1 | grep '\w' | head -n 1)" 
									#grep  -P '[0-9]+\.[0-9]+' | sed 's/^tune2fs //')"
			fi
		else
			if [ "$APP" == "lspci" ]; then
				add_name_value_pair 'lspci' 		"PLEASE INSTALL PCIUTILS!"
			elif [ "$APP" == "lshw" ]; then
				add_name_value_pair 'lshw' 		"PLEASE INSTALL LSHW!"
			elif [ "$APP" == "smartctl" ]; then
				add_name_value_pair 'smartctl' 		"PLEASE INSTALL SMARTMONTOOLS!"
			fi
		fi
	done
	flush_name_value_pair
	print_module_footer "${moduleName}"
}


Module_devices() {
	moduleName="Devices"
	print_module_header "${moduleName}"

	DEV_ARRAY=1;
	for DEVICE in $(lspci | awk {'$1="\b" ; print $0'} | tr ' ' '_' ); do

		devices[$DEV_ARRAY]="$(

			echo $DEVICE | sed -r 's/:_/:/g' | sed -r 's/(^_)//g' | tr ':' ' ' )"

			# with lspci 2.2 and later, the -m switch works fine
			#	for DEVICE in $(lspci -m | tr ' ' '_'); do 
			#		devices_dbg[$DEV_ARRAY]="$(	echo $DEVICE | grep -Eo '"[^"]+"' | awk -F\" {'print $2'} )";

		((DEV_ARRAY++))
	done

	# the devices array now contains the ' ' separated entries from lsmod. 
	# [1] device type		# [2] manufacturer		# [3] device name	etc
	# ${#devices[@]} # is the number of devices in the array

	DO_NOT_OUTPUT="pci\|usb\|smb\|bridge\|ide"
	for DEV_ARRAY in $(seq 1 ${#devices[@]}); do
		if [ ! "$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | grep -i $DO_NOT_OUTPUT)" ]; then 

			add_name_value_pair "$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | tr '_' ' ' | sed 's/^.//')" \
								"$(echo ${devices[$DEV_ARRAY]} | awk {'print $2" "$3'} | tr '_' ' ')" 

		fi
	done

	flush_name_value_pair
	print_module_footer "${moduleName}"
}


