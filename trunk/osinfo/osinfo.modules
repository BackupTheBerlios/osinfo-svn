#!/bin/bash
################################################################################
# List System information                                                      #
################################################################################
# Written by Arvid Norlander and Mikael Lammentausta                           #
# Some parts are taken from:                                                   #
#   --Advanced Bash Scripting Guide (ABS)                                      #
################################################################################

MODULES='distro applications terminal network devices users processor system lsmod hdd printers oem'
MODULES_REAL_ROOT_ONLY='system terminal applications network devices modprobe hdd printers oem'

# TODO: Use a parameter 
ETH_DEVICE="eth0"


################################################################################
################################################################################
## Modules                                                                    ##
################################################################################
################################################################################

Module_hdd() {
	moduleName="Disk information"
	print_module_header "${moduleName}"

	if [ "$(whoami)" == "root" ]; then

	# principle/TODO
	# use fdisk to get data of what drives are connected to the system

		for DRV in `seq 1 2`; do # <<<< TODO: get the # of drives
			drives[$DRV]=$(fdisk -l | grep Disk | fdisk -l | grep Disk | grep -Eo '\/(dev)\/\w'+)
		done

	# then print information of each drive

		for drive in `seq 1 ${#drives[@]}`; do

			add_name_value_pair	'$drive'		"-"
#			add_name_value_pair

		done



	# free space on /dev/hda:
	# free space on /dev/sda:
	# free space on /dev/sdb:
	# total free space

	# TODO: use smartctl / hdparm to sniff drive ID/SERIAL/FIRMWARE
	# is there a way to get the model? a database? read firmware?

	fi

	flush_name_value_pair
	print_module_footer "${moduleName}"
}

Module_oem() {
	moduleName="OEM information"
        print_module_header "${moduleName}"

	tmp="osinfo.tmp"
	lshw > $tmp

	# principle:
	# (1) output of lshw is stripped out of newlines, switched spaces with _ and added ¡ to denote a value pair
	# (2) this is put into hardware array, because bash doesn't support two-dimensional arrays 
	# (3) a for loop then checks each array element for OUTPUT type node ID.
	# (4) another loop checks for DO_NOT_OUTPUT ; if this is satisfied, value_name_pair is added


	OUTPUT="$(hostname)\|cpu\|core\|firmware\|memory\|cdrom\|disk" 
	DO_NOT_OUTPUT="description\|capabilities\|configuration\|resources\|physical\|bus"

	[[ "$isverbose" -eq 1 ]] && 
		OUTPUT=$OUTPUT"\|ide\|pci\|usb"


	HW_ARRAY=1;
	# TODO: fix the sed to cut all whitespaces before first word boundary
	for HW in `seq 1 $(

		cat $tmp | sed 's/  //g' | tr ' ' '_' | sed ':a;N;$!ba;s/\n/¡/g' | awk -F"*-" {'print NF'}

	)`; do

		hardware[$HW_ARRAY]="$(

			cat $tmp | sed 's/  //g' | tr ' ' '_' | sed ':a;N;$!ba;s/\n/¡/g' | awk -F"*-" {'print $'$HW' '}

		)" ; ((HW_ARRAY++))

	done


	# the hardware array now contains the ' ' separated entries from lsmod. 
	# [1] node type		# [2,3 ; 4,5 ; ....] value pairs
	# ${#hardware[@]} # is the number of node types


	for HW_ARRAY in $(seq 1 ${#hardware[@]}); do

		if [ "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $1'} | grep -i $OUTPUT)" ]; then # we want output

			myELEMENT=2;

			while [ "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print NF'})" -gt "$myELEMENT" ]; do # parse all elements in the array

				if [ ! "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | grep -i $DO_NOT_OUTPUT)" ]; then # not too much information

					add_name_value_pair "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | awk -F":_" {'print $1'} | tr '_' ' ')" \
										"$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | awk -F":_" {'print $2'} | tr '_' ' ')" 

				elif [ "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | grep -i 'description')" ]; then

					add_name_value_pair "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | awk -F":_" {'print $2'} | tr '_' ' ')" "-"

				fi

				((myELEMENT++));

			done
		fi
	done
	
	rm $tmp -f
	flush_name_value_pair
	print_module_footer "${moduleName}"
}


Module_system() {
	moduleName="System"
	print_module_header "${moduleName}"
	add_name_value_pair $"Operating system"      "$(uname --operating-system)"
	add_name_value_pair $"Network node hostname" "$(uname --nodename)"
	add_name_value_pair $"Kernel release"        "$(uname --kernel-release)"
	add_name_value_pair $"Machine hardware name" "$(uname --machine)"
	add_name_value_pair $"Kernel version"        "$(uname --kernel-version)" # doesn't work on all distros
	add_name_value_pair $"System locale"         "$(echo $LC_LANG)"
	add_name_value_pair $"System uptime"         "$(uptime | awk -F, {'print $1'})"
	# NOTE: uptime isn't accurate, as it cuts from the first ',' 
	# TODO: find a way to cut from 'up' to 'min'

	flush_name_value_pair
	print_module_footer "${moduleName}"
}

Module_processor() {
	moduleName="Processor"
	print_module_header "${moduleName}"

	add_name_value_pair $"Processor model"       "$(cat /proc/cpuinfo | grep 'model name' | awk -F': ' {'print $2'})"
	add_name_value_pair $"Processor frequency"   "$(cat /proc/cpuinfo | grep 'cpu MHz' | awk -F': ' {'print $2" MHz"'})"

	#TODO: fix double-entries with hyper-threading processors:
	#Processor model:      Intel(R) Pentium(R) 4 CPU 2.80GHz Intel(R) Pentium(R) 4 CPU 2.80GHz
	# update this to use lshw

	flush_name_value_pair
	print_module_footer "${moduleName}"
}

Module_terminal() {
	moduleName="Terminal info"
	print_module_header "${moduleName}"

	add_name_value_pair 'Terminal type'         "$TERM"
	add_name_value_pair 'Terminal speed'        "$(stty speed)"
	add_name_value_pair 'Rows'                  "$(stty size | awk '{print $1}')"
	add_name_value_pair 'Columns'               "$(stty size | awk '{print $2}')"

	flush_name_value_pair
	print_module_footer "${moduleName}"
}

Module_printers() {
	# this ugly hack prevents output if no printer is present, although needs debugging
#	if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then	

	moduleName="Printers"
	print_module_header "${moduleName}"

	add_name_value_pair 'printer'		"$(lpstat -a | awk {'print $1'})"
	# TODO: test in a system with many printers

	flush_name_value_pair
	print_module_footer "${moduleName}"

#	fi
}

Module_applications() {
	moduleName="Applications"
	print_module_header "${moduleName}"

	for APP in 'X' 'kde-config' 'gconftool' 'gcc' 'make' 'bash' 'find' \
			'awk' 'sed' 'grep' 'cups-config' 'udevinfo' 'lspci' 'lshw' \
			'gzip' 'ls' 'perl' 'python' 'php' 'mysql' 'smbd'; do

		if [ "$(type -p $APP)" ]; then # it is installed
			if [ "$APP" == "perl" ]; then
				add_name_value_pair $APP 		"$($APP --version 2>&1 | head -n 2 | grep '\w')" 
			elif [ "$APP" == "python" ]; then
				add_name_value_pair $APP 		"$($APP -V 2>&1 | head -n 1 )" 
			elif [ "$APP" == "X" ]; then
				add_name_value_pair 'X11' 		"$($APP -version 2>&1 | grep Revision)"
			elif [ "$APP" == "kde-config" ]; then
				add_name_value_pair 'KDE' 		"$($APP -version 2>&1 | grep KDE)"
#			elif [ "$APP" == "gconftool" ]; then
#				add_name_value_pair 'Gnome' 		"$($APP --version 2>&1 )"
			elif [ "$APP" == "cups-config" ]; then
				add_name_value_pair 'cups' 		"$($APP --version 2>&1 )"
			elif [ "$APP" == "smbd" ]; then
				add_name_value_pair 'samba' 		"$($APP -V 2>&1 )"
			elif [ "$APP" == "udevinfo" ]; then
				add_name_value_pair 'udev' 		"$($APP -V 2>&1 )"
			elif [ "$APP" == "awk" ]; then
				add_name_value_pair $APP 		"$($APP -W version 2>&1 | head -n 1 )"
			else
				add_name_value_pair $APP 		"$($APP --version 2>&1 | head -n 1)" 
									#grep  -P '[0-9]+\.[0-9]+' | sed 's/^tune2fs //')"
			fi
		else
			if [ "$APP" == "lspci" ]; then
				add_name_value_pair 'lspci' 		"PLEASE INSTALL PCIUTILS!"
			elif [ "$APP" == "lshw" ]; then
				add_name_value_pair 'lshw' 		"PLEASE INSTALL LSHW!"
			fi
		fi
	done
	flush_name_value_pair
	print_module_footer "${moduleName}"
}

Module_users() {
    moduleName="Users and processes"
    print_module_header "${moduleName}"

	add_name_value_pair 'Last logged in user' 	"$(last | head -n 1)"
#	add_name_value_pair 'Users' 			"$(ls /home/)"
#	add_name_value_pair 'Groups'  			"$(cat /etc/group | awk -F: {'print $1'} | sed 's/\n/  /g')"

	# perhaps the solution is to ditch out standard linux non-human users, then print the rest
	# AnMaster answers: check by uid. On gentoo normal users got uid > 1000. Some distros use 500.
	# -it has to work with all distros. 

	flush_name_value_pair
	print_module_footer "${moduleName}"
}


Module_lsmod() {
	moduleName="Kernel modules"
	print_module_header "${moduleName}"
	
	for MODULE in $(lsmod | awk {'print $1'} | grep -v Module); do
		add_name_value_pair 'module' "$MODULE"
	done
	# TODO: needs more work

	flush_name_value_pair
	print_module_footer "${moduleName}"
}



Module_network() {
	moduleName="Network information"
	print_module_header "${moduleName}"
	
	local specials="UP|BROADCAST|LOOPBACK|NOARP|NOTRAILERS|RUNNING|MULTICAST"
	# what are these needed for?
	
	local interface_name="$ETH_DEVICE" 
	# TODO: grep this from lspci

	add_name_value_pair 'Device'	"$interface_name"
	add_name_value_pair 'MAC'	"$(ifconfig $ETH_DEVICE | grep -Eo '([0-9A-F]{2}:){5}[0-9A-F]{2}')"
	add_name_value_pair 'IP'	"$(ifconfig $ETH_DEVICE | sed "s/  /\n/g" | grep -i inet | grep '\w' | grep -Eo '([0-9].{1,3}){4}')"
	add_name_value_pair 'Broadcast'	"$(ifconfig $ETH_DEVICE | sed "s/  /\n/g" | grep -i Bcast | grep '\w' | grep -Eo '([0-9].{1,3}){4}')"
	add_name_value_pair 'Netmask'	"$(ifconfig $ETH_DEVICE | sed "s/  /\n/g" | grep -i Mask | grep '\w' | grep -Eo '([0-9].{1,3}){4}')"
	add_name_value_pair 'RX bytes'	"$(ifconfig $ETH_DEVICE | sed "s/  /\n/g" | grep -i 'RX bytes' | awk -F: {'print $2'})"	
	add_name_value_pair 'TX bytes'	"$(ifconfig $ETH_DEVICE | sed "s/  /\n/g" | grep -i 'TX bytes' | awk -F: {'print $2'})"	

	
	flush_name_value_pair
	print_module_footer "${moduleName}"
}


Module_devices() {
	moduleName="Devices"
	print_module_header "${moduleName}"

	DEV_ARRAY=1;
	for DEVICE in $(lspci -m | tr ' ' '_'); do 

		devices[$DEV_ARRAY]="$(
			echo $DEVICE | grep -Eo '"[^"]+"' | awk -F\" {'print $2'} 
		)";

		((DEV_ARRAY++))
	done

	# the devices array now contains the ' ' separated entries from lsmod. 
	# [1] device type		# [2] manufacturer		# [3] device name	etc
	# ${#devices[@]} # is the number of devices in the array

	DO_NOT_OUTPUT="pci\|usb\|smb\|bridge\|ide"
	for DEV_ARRAY in $(seq 1 ${#devices[@]}); do
		if [ ! $(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | grep -i $DO_NOT_OUTPUT) ]; then 

			add_name_value_pair "$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | tr '_' ' ')" \
								"$(echo ${devices[$DEV_ARRAY]} | awk {'print $2" "$3'} | tr '_' ' ')" 

		fi
	done

	flush_name_value_pair
	print_module_footer "${moduleName}"
}


Module_distro() {
	moduleName="Distribution"
	print_module_header "${moduleName}"

	# echo the root directory
	[ "$prefix" != '/' ] && \
		local root_dir="$(echo $prefix | sed 's/\/*$//')" || \
		local root_dir="$prefix"
	add_name_value_pair 'Root dir'  "$root_dir"
	
	# Begin searching for distro identifying files
	local found_files=""
	local fil
	for fil in ${prefix}etc/{SuSE-release,redhat-release,slackware-version,Topologilinux-version,gentoo-release,issue}; do
		[ -e $fil ] && found_files="$found_files $fil"
	done
	
	# Now make a list of distros from the $found_files list above
	local found_distros=""
	local distro_ident
	for distro_ident in $found_files; do
		case $distro_ident in
			"${prefix}etc/SuSE-release")
		    found_distros="$found_distros SuSE"
		    break;
		    ;;
		"${prefix}etc/redhat-release")
		    found_distros="$found_distros Red Hat"
		    break;
		    ;;
		"${prefix}etc/slackware-version")
		    found_distros="$found_distros Slackware"
		    break;
		    ;;
		"${prefix}etc/Topologilinux-version")
		    found_distros="$found_distros Topologilinux"
		    break;
		    ;;
		"${prefix}etc/gentoo-release")
		    found_distros="$found_distros Gentoo"
		    break;
		    ;;
		# if nothing previous matches, then use issue
		# AnMaster: Inform user that this might be very wrong...
		"${prefix}etc/issue")
			found_distros="$found_distros misc"
			break;
			;;
		esac
	done
	# Remove beginning spaces.
	found_distros="$(echo "$found_distros" | sed "s/^ *//")"

	# Output distro name
	case "$found_distros" in
		'SuSE'|'Red Hat'|'Slackware'|'Slackware Topologilinux'|'Gentoo')
			[ "$found_distros" = 'Slackware Topologilinux' ] && found_distros='Topologilinux'
			[ "$found_distros" = 'Red Hat' ] && found_distros='RedHat'
			add_name_value_pair 'Distro name'         "$found_distros"
			;;
		'Topologilinux')
		# Abort if found Topologilinux but not Slackware.
			if [ "$usekdialog" == "1" ]; then
				kdialog --error  "Topologilinux is based on Slackware and should contain\n${prefix}etc/slackware-version AND ${prefix}etc/Topologilinux-version.\nThis module will abort."
			else
				echo "${tcRED}ERROR:${tSTD} Topologilinux is based on Slackware and should"
				echo "${tcRED}ERROR:${tSTD} contain ${prefix}etc/slackware-version ${tBOLD}AND${tSTD} ${prefix}etc/Topologilinux-version."
				echo "${tcRED}This module will abort.${tSTD}"
			fi
			return 1
			;;
		'misc')
			for DISTRO in 'Ubuntu' 'Fedora' 'SUSE'; do
				if [ "$(grep -i ${DISTRO} ${distro_ident})" ]; then 
					add_name_value_pair 'Distro name'         "$DISTRO"
				fi
			done
			;;
		'')
			# Abort if no distro found
			if [ "$usekdialog" == "1" ]; then
				kdialog --error  "You have zero distros installed or use a distro not recognised by ${appname}\nThis module will abort."
			else
				echo "${tcRED}ERROR:${tSTD} You have zero distros installed or use a distro not recognised by ${appname}"
				echo "${tcRED}This module will abort.${tSTD}"
			fi
			return 1
			;;
#	*)
#		# Abort if more than one distro
#		if [ "$usekdialog" == "1" ]; then
#			kdialog --error  "You have several distros installed at the same time.\nInstalled distros:\n${found_distros}\nThis module will abort."
#		else
#			echo "${tcRED}ERROR:${tSTD} You have several distros installed at the same time."
#			echo "${tcRED}ERROR:${tSTD} ${tBOLD}Installed distros:${tSTD} ${found_distros}"
#			echo "${tcRED}This module will abort.${tSTD}"
#		fi
#		return 1
#	;;
	esac
	# Output distro version
	case "$found_distros" in
		'SuSE')
			local distro_version="$(fgrep 'VERSION = '     ${prefix}etc/SuSE-release          | sed 's/VERSION = //'    )" ;;
		'RedHat')
#			local distro_version="$(fgrep 'VERSION = '     ${prefix}etc/redhat-release        | sed 's/VERSION = //'    )" ;;
			local distro_version="$(cat ${prefix}etc/redhat-release)" ;;
		'Slackware')
			local distro_version="$(fgrep 'Slackware '     ${prefix}etc/slackware-version     | sed 's/Slackware //'    )" ;;
		'Topologilinux')
			local distro_version="$(fgrep 'Topologilinux ' ${prefix}etc/Topologilinux-version | sed 's/Topologilinux //')"
			local  SlackwareBase="$(fgrep 'Slackware '     ${prefix}etc/slackware-version     | sed 's/Slackware //'    )" ;;
		'Gentoo')
			local distro_version="$(ls -ld /etc/make.profile --color=no | grep -Eo '[0-9]{4}\.[0-9]')";;
		'misc')
			local distro_version="$(grep '.' "${prefix}etc/issue" | grep -m 1 '\w'  )";;
			# TODO: fix the grep 
	esac
	add_name_value_pair 'Distro version' "$distro_version"
	[ "$SlackwareBase" ] && add_name_value_pair 'Based on Slackware version' "$SlackwareBase"
	# echo the whole table
	flush_name_value_pair
	print_module_footer "${moduleName}"
}

