#!/bin/bash
################################################################################
# List System information                                                      #
#   supports currently only Linux, FreeBSD support under development           #
################################################################################
# Written by Arvid Norlander and Mikael Lammentausta                           #
# Some parts are taken from:                                                   #
#   --Advanced Bash Scripting Guide (ABS)                                      #
################################################################################

MODULES_LINUX='distro applications terminal network devices processor system hdd oem'
MODULES_BSD='system applications terminal network'
MODULES_BROKEN='printers lsmod users'
MODULES_REAL_ROOT_ONLY='system terminal applications network devices modprobe hdd printers oem'



################################################################################
################################################################################
## Modules                                                                    ##
################################################################################
################################################################################


### Comments
# value_header
# add_attribute takes two parameters: common name and xml code tag.
# add_values can take several values.
# flush_values prints the values to xml file or to stdout.



Module_hdd() {
	moduleName="Disk information"
	module_header "${moduleName}"

	# this module collects data of the hard disk drives attached to the system. some information
	# is unaccesible unless the partitions are mounted. everything is collected honoring the requirement
	# of minimum dependencies; ie. using standard *nix tools. some information is unavailable
	# without special (but quite common) packages, and S-ATA/P-ATA drives do now display everything
	# as nicely as IDE drives, due to missing support in smartmontools (06/2006).

	# used tools:
	# fdisk, df, /proc tree (Linux only), bc, lshw, smartmontools, hdparm

	# developement status:
	# -------------------
	# IDE/PATA is tested
	# SATA is tested
	# USBhdd is tested	
	# SCSI is untested, although works probably as SATA
	# RAID is untested 
	# Logical Volume Management is untested

	# notes:
	# -----
	# FREEBSD: To check the status of drives, use the following:
	# ${PREFIX}/sbin/smartctl -a ad0          for first ATA drive
	# ${PREFIX}/sbin/smartctl -a da0          for first SCSI drive
	# 
	# there are at least two methods to parse an alphabetical seq number:
	# awk '{ ind=index("ABCDEFGHIJKLMNOPQRSTUVWXYZ", toupper($0)); print ind; }' <<< $'b\no\ns\na\ni'
	# NUM=$(( $(echo -n 'A' | tr 'a-z' 'A-Z' | od -A n -t u1) - 64)); echo $NUM
	# the latter works by subtracting the ASCII offset (64) from the uppercase character.
	#
	# to use tab as a field separator in awk:
	# awk $'-F\t' {}

	# begin
	# -----
	# this module depends heavily on root access, so prevent other users of running this module
	if [ "$(whoami)" != "root" ]; then
		add_attribute	"$appname notification"
		add_values		"Run $appname as super-user to collect this information"
	else

		# declare variables
		totalsize=0; totalfree=0

		# detect all drives in the system
		drives="$(fdisk -l | grep Disk | grep -Eo '\/(dev)\/\w'+)"		

		# loop all detected drives
		for drvdev in $drives; do
		
			value_header	 ${drvdev}
			
			# $drvdev is the whole device address, eg "/dev/hda"
			# $drvnode is just the device node, eg "hda"
			# $drvnr is the drive number for this type of driver; eg. for sdc $drvnr=3
			drvnode=$(echo $drvdev | awk -F/ {'print $NF'})
			drvnr=$(( $(echo -n ${drvnode: -1:1} | tr 'a-z' 'A-Z' | od -A n -t u1) - 64));

			if [ "$(echo $drvdev | grep hd)" ]; then

				scan_hdd_ide

			elif [ "$(echo $drvdev | grep sd)" ]; then
			
				scan_hdd_sg

			else
			
				add_attribute	"Description"			
				add_values		"Unknown device type"

			fi 
			
			#################################
			# common data for all drive types:
			# drive geometry and capacity

			add_attribute	'Geometry'
			add_values		"$(fdisk -l | grep /dev/sda -A 1 | sed -n "2{p;q}")"

			add_attribute	'Capacity (reported)'
			add_values		"$(fdisk -l ${drvdev} | grep ${drvdev} | \
							head -n 1 | grep -Eo '[1-9][0-9]+[\.0-9]* \w{2}' | head -n 1)"
			
			add_attribute	'Capacity (actual)'
			# fdisk gives drive capacity in bytes
			DISKSIZE="$(fdisk -l $drvdev | head -n 2 | grep -Eo '[0-9]{4,}')"
			[[ $DISKSIZE -lt 1073741824 ]] && \
				DZ="$(echo $DISKSIZE/1024/1024 | bc -l)"
				DZ="${DZ:0:5} MB"
			[[ $DISKSIZE -gt 1073741824 ]] && \
				DZ="$(echo $DISKSIZE/1024/1024/1024 | bc -l)" && \
				DZ="${DZ:0:5} GB"
			add_values		"$DZ"


			#####################
			# scan the partitions
			
			scan_hdd_partitions
			

			###############################
			# calculate total disk capacity
							
			[[ $DISKSIZE -lt 1048576 ]] && \
				#diskfr="$(($DISKFREE/1024)) MB"
				diskfr="$(echo $DISKFREE/1024 | bc -l)" && \
				diskfr="${diskfr:0:4} MB"
			[[ $DISKSIZE -gt 1048576 ]] && \
				#diskfr="$(($DISKFREE/1024/1024)) GB"
				diskfr="$(echo $DISKFREE/1024/1024 | bc -l)" && \
				diskfr="${diskfr:0:4} GB"

			#diskpercfree="$(($DISKFREE*1024*100/$DISKSIZE))" # rounds off improperly
			diskpercfree="$(echo $DISKFREE*1024*100/$DISKSIZE | bc -l)" 
			diskpercfree="${diskpercfree:0:4}"
			
			add_attribute	'Free (mounted)'
			add_values		"${diskfr} ; ${diskpercfree}%"

			totalsize=$(($totalsize+$DISKSIZE))
			totalfree=$(($totalfree+$DISKFREE))


			unset DISKSIZE
			unset DISKFREE
			
		done



		######################################
		# calculate total system disk capacity
		# report data of the whole system
		
		totalpercfree=0
		
		#add_attribute	"Total disk space"
		#add_values		"Capacity: $(echo $totalsize)"
		#add_values		"Free: $(echo -e $totalfree ; $totalpercfree %)"

	fi

	# finalize
	module_footer
	flush_values
}

function scan_hdd_smart() {
	#########################
	# S.M.A.R.T. scanning
	#
	# smartmontools are handy in getting the extended parameters
	# of hard drives. only version 5.36 and onward support SATA drives
	# and the version may be a bit uncommon, as it was released in April 2006.
	# all major distros should begin to include it in their packages,
	# so this should be relatively common in late 2006.
	# for ide drives this is not a problem.
	#
	# this function takes one parameter, the driver to use. default is ata.
	
	if [ "$1" ]; then dev_type=$1
	else dev_type=ata;
	fi

	# allocate a temp file
	tmp="$(mktemp  osinfo.XXXXXX)"

	### check the smartctl version >5.36
	version="$(smartctl --version | grep -Eo 'version [0-9.]+' | \
		grep -Eo '[0-9]\.[0-9]+')";
	diff="$(echo $version-5.36 | bc -l)"
	if [ ! "${diff:0:1}" = "-" ]; then # this is a newer version
		smart="sata-ok"
	else
		smart=$version					
	fi
	unset version

	smartctl -a -d $dev_type ${drvdev} > $tmp
	add_attribute	'S.M.A.R.T.'
	add_values		"$(cat ${tmp} | grep 'SMART support' | \
					head -n 1 | awk -F': ' {'print $2'})"

	add_attribute	'Lifetime'
	add_values		"$(cat $tmp | grep -i power_on | awk {'print $NF'})"

	add_attribute	'Temperature (C)'
	add_values		"$(cat $tmp | grep -i temperature_celsius | \
					awk '{for (i=10; i<=NF; i++) printf("%s ",$i);printf ("\n")}')"
 
	add_attribute	'Health Status'
	add_values		"$(cat $tmp | grep -Ei '(health)+' | awk {'print $NF'})"
	
}

function scan_hdd_partitions() {
	####################
	# PARTITIONS
	# 
	# this loop extracts information of partitions
	# 
	# TODO: an array that stores data of how much is allocated for each FS
	# [partition ID=83] [size on hda1] [size on hda4]
	# [partition ID=7] [size on hda2] [size on hdb1]
	
	DISKFREE=0
	partitions_on_drive="$(fdisk -l $drvdev | grep ^$drvdev | wc -l)"

	value_header		"  Partition\t\tcapacity\tfree\tmountpoint\tfilesystem"

	for PARTNR in $(seq 1 1 $partitions_on_drive); do 
		partition="$(fdisk -l $drvdev | grep ^$drvdev | awk {'print $1'} | \
			sed -n "${PARTNR}{p;q;}" )"
				
		# partition
		add_attribute	"  ${partition}"

		# capacity; if partition is mounted (=is in mtab)
		# BUG: submounted (=system for automounting usb sticks) partitions
		# are considered unmounted, while they are not!
		if [ "$(df -Plk | grep $partition)" ]; then
		
			# the partition size is calculated from the value given by df,
			# and the float division is computed by bc.
			# the output of bc is then concatenated by parameter expansion.
		
			# df reports in kb
			# small partitions are reported in MB, larger in GB
			partsize="$(df -Plk | grep $partition | awk {'print $2'})"
			partfree="$(df -Plk | grep $partition | awk {'print $4'})"
	
			[[ $partsize -lt 1048576 ]] && \
				pz="$(echo $partfree/1024 | bc -l)" && \
				pz="${pf:0:4} MB"
			[[ $partsize -gt 1048576 ]] && \
				pf="$(echo $partfree/1024/1024 | bc -l)" && \
				pf="${pf:0:4} GB"
				
			#partpercfree="$(($partfree*100/$partsize))" # rounds off improperly
			partpercfree="$(echo $partfree*100/$partsize | bc -l)"
			partpercfree="${partpercfree:0:4}"
			
			DISKFREE=$(($DISKFREE+$partfree))


			# capacity
			add_values		"$pz\t"
			
			# free space
			add_values		"$partpercfree%"
		
			# mountpoint			
			add_values		"$(df -PT $partition | grep ^$partition | awk {'print $NF'})"
		
		else
			
			# capacity
			add_values		"-\t"
			
			# free space
			add_values		"-"
		
			# mountpoint			
			add_values		"unmounted"

		fi
	
		# filesystem
		# because fdisk adds a '*' character for bootable partitions, awk gets
		# messed up. that is why numbers are removed from the beginning of string.
		add_values		"$(fdisk -l | grep ^${partition} | \
						awk '{for (i=6; i<=NF; i++) printf("%s ",$i);printf ("\n")}' | \
						sed 's/^[0-9 ]*//')"
						#(read Disk foo bar foobar something partition; echo "$partition"))"
			
	done
}

function scan_hdd_ide() {
	#################
	# IDE drives
	#
	# this function collects information of IDE drives in the system.

	ide_info="/proc/ide/"
	serial="$(udevinfo -q all -n ${drvdev} | grep SERIAL | awk -F= {'print $NF'})"

	add_attribute	'Description'
	add_values		'IDE drive'
	
	add_attribute	'Vendor'
	if [ "$(type -p smartctl)" ]; then	
		# this smart scan is not included into the scan_hdd_smart()
		# because it would break the correct order of the report.
		add_values		"$(smartctl -i ${drvdev} | grep '^Model' | \
						awk -F: {'print $2'} | sed 's/^ *//')"						
	else
		add_values		"$(udevinfo -q all -n ${drvdev} | grep VENDOR | \
						awk -F_ {'print $NF'})"
	fi

	if [ -e "/proc/ide/$drvnode" ]; then
	
		add_attribute	'Model'
		add_values		"$(cat ${ide_info}${drvnode}/model)"
						#"$(hdparm -i $drvdev | grep -Eio 'Model=\w+' | \
						#awk -F= {'print $2'})"

	fi	

	add_attribute	'Serial'
	add_values		${serial}
					#"$(hdparm -i ${drives[$drvdev]} | grep -Eio 'serialno=\w+' | \
					#awk -F= {'print $2'})"
	
	if [ -e "/proc/ide/$drvnode" ]; then
	
		add_attribute	'Driver'
		add_values		"$(cat ${ide_info}${drvnode}/driver)"
		
	fi
	
	add_attribute	'DMA'
	add_values		"$(hdparm /dev/hda | grep dma | grep -Eo '\([onf]+\)')"	
		
	if [ "$(type -p smartctl)" ]; then
		
		scan_hdd_smart ata
			
	fi		
}

function scan_hdd_sg() {

	################# 
	# SATA/SCSI/USB drives (sg driver)
	# 
	# this function servers to detect properties of SATA/SCSI/USB drives,
	# because under Linux they all use the same SCSI drivers.
	# usb drives, when properly detected by the Linux kernel,
	# are added to /proc/scsi/scsi info sheet, and the assigned scsi number
	# which can be found both in the beforementioned location and also
	# in /proc/scsi/sg/devices, can be used to identify the device 
	# in /proc/scsi/usb-storage/*.
	#
	# as the devices are (hopefully) linearily, the devices catalogue
	# can be used to identify which /dev/sd* node is a certain scsi#.
	# 
	# this is not true in the case of custom udev rules. although
	# a good practise is to let kernel do its magic and create a
	# link node to that device, so this is unlikely to be a problem.
	#
	# smartmontools support SATA drives from version 5.36 on
	# (released April 2006). this function is written in June 2006,
	# and for that the version of smartctl is checked before trying
	# to access SATA drives.

	scsi_info="/proc/scsi/scsi"
	scsi_devices="/proc/scsi/sg/devices"
	scsi_devstrings="/proc/scsi/sg/device_strs"					
	usb_devstrings="/proc/scsi/usb-storage/"
	sg_version="/proc/scsi/sg/version"

	serial="$(udevinfo -q all -n ${drvdev} | grep SERIAL | awk -F= {'print $NF'})"
	scsi_nr="$(sed -n "$drvnr{p;q;}" ${scsi_devices} | awk {'print $1'})"

	# test if the scsi_nr is found in /proc/scsi/usb-storage/
	if [ -e "${usb_devstrings}${scsi_nr}" ]; then				
	###
	# USB drive
	
		usb_info="${usb_devstrings}/${scsi_nr}"
	
		add_attribute	'Description'
		add_values		'USB drive'

	else
	###
	# SATA/SCSI drive
	
		add_attribute	'Description'
		add_values		'SATA/SCSI drive'
	fi

	### 
	# common sg driver
	
	add_attribute	'Vendor'
	if [ "$smart" = "sata-ok" ]; then
		# this smart scan is not included into the scan_hdd_smart()
		# because it would break the correct order of the report.
		add_values		"$(smartctl -i -d ata ${drvdev} | grep '^Model' | \
						awk -F: {'print $2'} | sed 's/^ *//')"
	else
		add_values		"$(sed -n "$drvnr{p;q;}" "${scsi_devstrings}" | awk {'print $1'})"
						#"$(grep -i vendor ${usb_info} | awk -F': ' {'print $2'})"
	fi
	
	add_attribute	'Model'
	add_values		"$(sed -n "$drvnr{p;q;}" "${scsi_devstrings}" | awk {'print $2" "$3'})"
	
	add_attribute	'Serial'
	add_values		${serial}
					#"$(cat $tmp | grep ${drvdev}$ -A 2 | grep -Ei 'serial' | \
					#awk {'print $NF'})"
					
	add_attribute	'Driver'
	add_values		"Linux SCSI Generic (sg) v.$(cat ${sg_version})"			
	
	#add_attribute	'DMA'
	#add_values		"n/a" #enabled/disabled

	if [ "$smart" = "sata-ok" ]; then

		scan_hdd_smart ata
			
	fi
}


#Module_memory() {}
#Module_cdrom() {}


Module_oem() {
	moduleName="OEM information"
	module_header "${moduleName}"

	if [ ! "$(type -p lshw)" ]; then
		add_attribute	"$appname notification" 
		add_values		"Please install LSHW to collect this information"

	elif [ ! "$(whoami)" == "root" ]; then
		add_attribute	"$appname notification" 
		add_values		"Please run $appname as super-user to collect this information"

	else

	tmp="$(mktemp osinfo.XXXXXX)"
	lshw > $tmp

	# principle:
	# (1) output of lshw is stripped out of newlines, switched spaces with _ and added ¡ to denote a value pair
	# (2) this is put into hardware array, because bash doesn't support two-dimensional arrays 
	# (3) a for loop then checks each array element for OUTPUT type node ID.
	# (4) another loop checks for DO_NOT_OUTPUT ; if this is satisfied, value_name_pair is added


	OUTPUT="$(hostname)\|cpu\|core\|firmware\|memory\|cdrom\|disk" 
	DO_NOT_OUTPUT="description\|capabilities\|configuration\|resources\|physical\|bus"

	[[ "$isverbose" -eq 1 ]] && 
		OUTPUT=$OUTPUT"\|ide\|pci\|usb"


	HW_ARRAY=1;
	# TODO: fix the sed to cut all whitespaces before first word boundary
	# this loop fills the $hardware[] array with entries from lshw.
	for HW in $(seq 1 $(

		cat $tmp | sed 's/  //g' | tr ' ' '_' | sed ':a;N;$!ba;s/\n/¡/g' | awk -F"*" {'print NF'}

	)); do

		hardware[$HW_ARRAY]="$(

			cat $tmp | sed 's/  //g' | tr ' ' '_' | sed ':a;N;$!ba;s/\n/%%/g' | awk -F"*" {'print $'$HW' '}

		)" ; ((HW_ARRAY++))

	done

	echo "this module is broken, will be fixed soon - ruxpin"
#	echo ${hardware[1]}
	exit 0


	for HW_ARRAY in $(seq 1 ${#hardware[@]}); do
		if [ "$)" ]; then # we want output
		
			myELEMENT=2;

			# then parse all elements in the array
			while [ "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print NF'})" -gt "$myELEMENT" ]; do  

				# this 'if' test prunes out the devices we're not interested in
				if [ ! "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | \
						grep -i $DO_NOT_OUTPUT)" ]; then 

					myHW="$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '})"

					#add_values	"$(echo ${myHW} | awk -F":_" {'print $1'} | tr '_' ' ')" \
					#			"$(echo ${myHW} | awk -F":_" {'print $2'} | tr '_' ' ')" 


				elif [ "$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | \
						grep -i 'description')" ]; then

					flush_values
#					[[ "$value_pair_header" ]] && flush_values
					value_pair_header="$(echo ${hardware[$HW_ARRAY]} | awk -F¡ {'print $'$myELEMENT' '} | awk -F":_" {'print $2'} | tr '_' ' ')"


				fi

				((myELEMENT++));

			done
		fi
	done
	
	rm $tmp -f

	fi
	flush_name_value_pair
	module_footer "${moduleName}"
}


Module_system() {
	moduleName="System"
	module_header "${moduleName}"

	add_attribute	$"Operating system"			"os"
	add_values		"$(uname -s)"
	
	add_attribute	 $"Kernel release"			"kernel_release"
	add_values		"$(uname -r)"
	
	kernel_makefile="/usr/src/linux/Makefile"
	if [ -e "${kernel_makefile}" ]; then
		add_attribute	$"Kernel name"			"kernel_name"
		add_values		"$(head ${kernel_makefile} | grep NAME | awk -F= {'print $2'})"
	fi

	add_attribute	$"Network node hostname"	"host_name"
	add_values		"$(hostname)"
		
	add_attribute	$"Machine hardware name"	"system_type"
	add_values		"$(uname -m)"
	
	add_attribute	$"System locale"
	add_values		"$(echo $LC_LANG)"
	
	add_attribute	$"System uptime"
	add_values		"$(uptime | awk -F, {'print $1'} | grep -Eo 'up [a-z0-9: ]*')"

	module_footer
	flush_values
}

Module_processor() {
	moduleName="Processor"
	module_header "${moduleName}"

	add_attribute	"Vendor"		"processor_vendor"
	add_values		"$(cat /proc/cpuinfo | grep 'vendor' | \
					awk -F': ' {'print $2'})"

	add_attribute	"Model"			"processor_model"
	add_values		"$(cat /proc/cpuinfo | grep 'model name' | \
					awk -F': ' {'print $2'})"

	add_attribute	"Frequency"		"processor_speed"
	add_values		"$(cat /proc/cpuinfo | grep 'cpu MHz' | \
					awk -F': ' {'print $2" MHz"'})"
	
	add_attribute	"Count"			"processor_count"
	# TODO
	
	#TODO: fix double-entries with hyper-threading processors:
	#Processor model:      Intel(R) Pentium(R) 4 CPU 2.80GHz Intel(R) Pentium(R) 4 CPU 2.80GHz

	module_footer
	flush_values
}

Module_terminal() {
	moduleName="Terminal info"
	module_header "${moduleName}"

	add_attribute	"Terminal type"
	add_values		"$TERM"
	
	add_attribute	"Terminal speed"        
	add_values		"$(stty speed)"
	
	add_attribute	"Rows"
	add_values		"$(stty size | awk '{print $1}')"
	
	add_attribute	"Columns"
	add_values		"$(stty size | awk '{print $2}')"

	module_footer 
	flush_values
}

Module_printers() {
	# this ugly hack prevents output if no printer is present, although needs debugging
	#	if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then	

	moduleName="Printers"
	module_header "${moduleName}"

	add_name_value_pair 'printer'		"$(lpstat -a | awk {'print $1'})"
	# TODO: test in a system with many printers

	flush_name_value_pair
	module_footer "${moduleName}"

#	fi
}


Module_users() {
    moduleName="Users and processes"
    module_header "${moduleName}"

	add_name_value_pair 'Last logged in user' 	"$(last | head -n 1)"
#	add_name_value_pair 'Users' 			"$(ls /home/)"
#	add_name_value_pair 'Groups'  			"$(cat /etc/group | awk -F: {'print $1'} | sed 's/\n/  /g')"

	# perhaps the solution is to ditch out standard linux non-human users, then print the rest
	# AnMaster answers: check by uid. On gentoo normal users got uid > 1000. Some distros use 500.
	# -it has to work with all distros. 

	flush_name_value_pair
	module_footer "${moduleName}"
}


Module_lsmod() {
	# rename to 'drivers'
	moduleName="Device drivers"
	module_header "${moduleName}"

	# usb
	# ide
	# /proc/ide/drivers
	# scsi
	# etc...
	
#	for MODULE in $(lsmod | awk {'print $1'} | grep -v Module); do
#		add_name_value_pair 'module' "$MODULE"
#	done
	# TODO: needs more work

	flush_name_value_pair
	module_footer "${moduleName}"
}



Module_network() {
	moduleName="Network information"
	module_header "${moduleName}"

	local specials="UP|BROADCAST|LOOPBACK|NOARP|NOTRAILERS|RUNNING|MULTICAST"
	# what are these needed for?

	if [ "$SYSTEM" == "linux" ] ; then
		ETH_DEVICES="$(ifconfig -a | grep BROADCAST -B 2 | grep -v LOOPBACK | grep -Ev '(^ )|(^--)' | awk  {'print $1'})"

	else
		ETH_DEVICES="$(ifconfig -a | grep BROADCAST | grep -v LOOPBACK | awk -F': ' {'print $1'})"

	fi

	for interface_name in $ETH_DEVICES; do

		value_header	$interface_name
		
		add_attribute	'MAC'		"mac_address"
		add_values		"$(ifconfig $interface_name | grep -Eo '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}')"
		
		add_attribute	'IPv4'		"ip_address"
		add_values		"$(ifconfig $interface_name | \
								grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | grep -Eo '[0-9\.]+' )"

		add_attribute	'IPv6'
		add_values		"$(ifconfig $interface_name | sed "s/  /\n/g" | \
								grep -i inet6 | grep -Eio '([0-9a-f]{3,4}(\:){1,2}){4,8}([0-9a-f]{3,4})' )"

		add_attribute	'Gateway'	"default_gateway"
		add_values		"$(route -n | awk '/^0.0.0.0/{print $2}')"

		add_attribute	'Broadcast'
		add_values		"$(ifconfig $interface_name | sed "s/  /\n/g" | \
								grep -Eio 'cast[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | grep -Eo '[0-9\.]+' )"

		add_attribute	'Netmask'	"subnet_mask"
		add_values		"$(ifconfig $interface_name | sed "s/  /\n/g" | \
								grep -Eio 'mask[A-Za-z: ]*((([0-9]{1,3}\.){3}[0-9]{1,3})|(0x[0-f]{8}))' | \
								grep -Eo '[0-9\.fx]+' )"

		add_attribute	'RX bytes'
		add_values		"$(ifconfig $interface_name | sed "s/  /\n/g" | \
								grep -i 'RX bytes' | awk -F: {'print $2'})"	

		add_attribute	'TX bytes'
		add_values		"$(ifconfig $interface_name | sed "s/  /\n/g" | \
								grep -i 'TX bytes' | awk -F: {'print $2'})"	
		value_footer

	done

	module_footer 
	flush_values
}



Module_distro() {
	moduleName="Distribution"
	module_header "${moduleName}"

	# echo the root directory
	[ "$prefix" != '/' ] && \
		local root_dir="$(echo $prefix | sed 's/\/*$//')" || \
		local root_dir="$prefix"
	add_name_value_pair 'Root dir'  "$root_dir"
	
	# Begin searching for distro identifying files
	local found_files=""
	local fil
	for fil in ${prefix}etc/{SuSE-release,fedora-release,redhat-release,slackware-version,Topologilinux-version,gentoo-release,issue}; do
		[ -e $fil ] && found_files="$found_files $fil"
	done
	
	# Now make a list of distros from the $found_files list above
	local found_distros=""
	local distro_ident
	for distro_ident in $found_files; do
		case $distro_ident in
			"${prefix}etc/SuSE-release")
		    found_distros="$found_distros SuSE"
		    break;
		    ;;
		"${prefix}etc/fedora-release")
		    found_distros="$found_distros Fedora Core"			
		    break;
		    ;;
		"${prefix}etc/redhat-release")
		    found_distros="$found_distros Red Hat"
		    break;
		    ;;
		"${prefix}etc/slackware-version")
		    found_distros="$found_distros Slackware"
		    break;
		    ;;
		"${prefix}etc/Topologilinux-version")
		    found_distros="$found_distros Topologilinux"
		    break;
		    ;;
		"${prefix}etc/gentoo-release")
		    found_distros="$found_distros Gentoo"
		    break;
		    ;;
		# if nothing previous matches, then use issue
		# AnMaster: Inform user that this might be very wrong...
		"${prefix}etc/issue")
			found_distros="$found_distros misc"
			break;
			;;
		esac
	done
	# Remove beginning spaces.
	found_distros="$(echo "$found_distros" | sed "s/^ *//")"

	# Output distro name
	case "$found_distros" in
		'SuSE'|'Fedora Core'|'Red Hat'|'Slackware'|'Slackware Topologilinux'|'Gentoo')
			add_name_value_pair 'Distro name'         "$found_distros"
			[ "$found_distros" = 'Slackware Topologilinux' ] && found_distros='Topologilinux'
			[ "$found_distros" = 'Red Hat' ] && found_distros='RedHat'
			[ "$found_distros" = 'Fedora Core' ] && found_distros='Fedora'
			;;
		'Topologilinux')
		# Abort if found Topologilinux but not Slackware.
			if [ "$usekdialog" == "1" ]; then
				kdialog --error  "Topologilinux is based on Slackware and should contain\n${prefix}etc/slackware-version AND ${prefix}etc/Topologilinux-version.\nThis module will abort."
			else
				echo "${tcRED}ERROR:${tSTD} Topologilinux is based on Slackware and should"
				echo "${tcRED}ERROR:${tSTD} contain ${prefix}etc/slackware-version ${tBOLD}AND${tSTD} ${prefix}etc/Topologilinux-version."
				echo "${tcRED}This module will abort.${tSTD}"
			fi
			return 1
			;;
		'misc')
			for DISTRO in 'Ubuntu' 'Fedora' 'SUSE'; do
				if [ "$(grep -i ${DISTRO} ${distro_ident})" ]; then 
					add_name_value_pair 'Distro name'         "$DISTRO"
				fi
			done
			;;
		'')
			# Abort if no distro found
			if [ "$usekdialog" == "1" ]; then
				kdialog --error  "You have zero distros installed or use a distro not recognised by ${appname}\nThis module will abort."
			else
				echo "${tcRED}ERROR:${tSTD} You have zero distros installed or use a distro not recognised by ${appname}"
				echo "${tcRED}This module will abort.${tSTD}"
			fi
			return 1
			;;
#	*)
#		# Abort if more than one distro
#		if [ "$usekdialog" == "1" ]; then
#			kdialog --error  "You have several distros installed at the same time.\nInstalled distros:\n${found_distros}\nThis module will abort."
#		else
#			echo "${tcRED}ERROR:${tSTD} You have several distros installed at the same time."
#			echo "${tcRED}ERROR:${tSTD} ${tBOLD}Installed distros:${tSTD} ${found_distros}"
#			echo "${tcRED}This module will abort.${tSTD}"
#		fi
#		return 1
#	;;
	esac
	# Output distro version
	case "$found_distros" in
		'SuSE')
			local distro_version="$(fgrep 'VERSION = '     ${prefix}etc/SuSE-release          | sed 's/VERSION = //'    )" ;;
		'RedHat')
#			local distro_version="$(fgrep 'VERSION = '     ${prefix}etc/redhat-release        | sed 's/VERSION = //'    )" ;;
			local distro_version="$(cat ${prefix}etc/redhat-release)" ;;
		'Fedora')
			local distro_version="$(cat ${prefix}etc/fedora-release)" ;;
		'Slackware')
			local distro_version="$(fgrep 'Slackware '     ${prefix}etc/slackware-version     | sed 's/Slackware //'    )" ;;
		'Topologilinux')
			local distro_version="$(fgrep 'Topologilinux ' ${prefix}etc/Topologilinux-version | sed 's/Topologilinux //')"
			local  SlackwareBase="$(fgrep 'Slackware '     ${prefix}etc/slackware-version     | sed 's/Slackware //'    )" ;;
		'Gentoo')
			local distro_version="$(ls -ld /etc/make.profile --color=no | grep -Eo '[0-9]{4}\.[0-9]')";;
		'misc')
			local distro_version="$(grep '.' "${prefix}etc/issue" | grep -Eo '([A-Za-z0-9 ."])+' | head -n 1 )";;
			# TODO: improve the grep 
	esac
	add_name_value_pair 'Distro version' "$distro_version"
	[ "$SlackwareBase" ] && add_name_value_pair 'Based on Slackware version' "$SlackwareBase"
	# echo the whole table
	flush_name_value_pair
	module_footer "${moduleName}"
}

Module_applications() {
	moduleName="Applications"
	module_header "${moduleName}"

	## Applications to look for..
	if [ "$SYSTEM" == "linux" ] ; then

		APPLICATIONS="X kde-config x11vnc \
			bash csh ls \
			gcc make \
			awk sed grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			udevinfo lspci lshw smartctl hdparm"

	elif [ "$(echo $SYSTEM | grep bsd)" ]; then

		APPLICATIONS="X kde-config x11vnc \
			csh bash ksh \
			gcc grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			lspci lshw smartctl hdparm"

	fi

	## Write the header for output
	add_attribute	$"Applications"		'software'


	## Process all applications
	for app in ${APPLICATIONS}; do


		if [ "$(type -p $app)" ]; then # it is installed
			case "$app" in 
				'perl')
					add_values		"Perl $($app --version 2>&1 | grep 'perl, v' | grep -Eo 'v[ A-Za-z0-9.-]*')" 
					;;
				'python')
					add_values		"$($app -V 2>&1 | head -n 1 )" 
					;;
				'X')
					add_values		"$($app -version 2>&1 | grep Revision)"
					;;
				'kde-config')
					add_values 		"$($app -version 2>&1 | grep KDE)"
					;;
				'gconftool')
					add_values  	"$($app --version 2>&1 )"
					;;
				'apache2'|'apache')
					add_values		"$($app -V | head -n 1 | awk -F': ' {'print $2'})"
					;;
				'cups-config')
					add_values		"Cups $($app --version 2>&1 )"
					;;
				'smbd')
					add_values		"Samba $($app -V 2>&1 )"
					;;
				'udevinfo')
					add_values		"$($app -V 2>&1 )"
					;;
				'awk')
					add_values		"$($app -W version 2>&1 | head -n 1 )"
					;;
				*)
					add_values		"$($app --version 2>&1 | grep '\w' | head -n 1)" 
					;;
										#grep  -P '[0-9]+\.[0-9]+' | sed 's/^tune2fs //')"
			esac
		else
			case "$app" in
				'lspci')
					add_values 'lspci' 		"PLEASE INSTALL PCIUTILS!"
					;;
				'lshw')
					add_values 'lshw' 		"PLEASE INSTALL LSHW!"
					;;
				'smartctl')
					add_values 'smartctl'	"PLEASE INSTALL SMARTMONTOOLS!"
					;;
			esac
		fi
	done
	module_footer 
	flush_values
}


Module_devices() {
	moduleName="Devices"
	module_header "${moduleName}"

	DEV_ARRAY=1;
	for DEVICE in $(lspci | awk {'$1="\b" ; print $0'} | tr ' ' '_' ); do

		devices[$DEV_ARRAY]="$(

			echo $DEVICE | sed -r 's/:_/:/g' | sed -r 's/(^_)//g' | tr ':' ' ' )"

			# with lspci 2.2 and later, the -m switch works fine
			#	for DEVICE in $(lspci -m | tr ' ' '_'); do 
			#		devices_dbg[$DEV_ARRAY]="$(	echo $DEVICE | grep -Eo '"[^"]+"' | awk -F\" {'print $2'} )";

		((DEV_ARRAY++))
	done

	# the devices array now contains the ' ' separated entries from lsmod. 
	# [1] device type		# [2] manufacturer		# [3] device name	etc
	# ${#devices[@]} # is the number of devices in the array

	DO_NOT_OUTPUT="pci\|usb\|smb\|bridge\|ide"
	for DEV_ARRAY in $(seq 1 ${#devices[@]}); do
		if [ ! "$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | grep -i $DO_NOT_OUTPUT)" ]; then 
	
			add_attribute	"$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | \
							tr '_' ' ' | sed 's/^.//')" 
			add_values		 "$(echo ${devices[$DEV_ARRAY]} | \
							awk {'print $2" "$3'} | tr '_' ' ')" 

		fi
	done
	
	module_footer
	flush_values
}


