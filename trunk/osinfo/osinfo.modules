#!/bin/bash
#################################################################################
# OSINFO MODULES
#
# osinfo lists system information available to the OS.
# this file contains the osinfo modules and module subfunctions.
# modules can be freely added; the data processing and outputting is taken
# care of by other functions. these are accessed by the following functions,
# and here they are presented in the order in which they should appear in
# the modules.
#
# module_header	"Module name"
#  each module should begin with this line.
#  it will be printed in colour at stdout and as a tag to xml.
#  it may contain spaces; in the xml tag they will be replaced by '_'
#
# value_header	"Header"
#  the argument is printed on a single line in bold to stdout,
#  and as a <header> tag to the xml.
#  each module may contain several calls of this type
#
# add_attribute "Common Name"	"xml_code"
#  the first argument is printed at the first field to stdout,
#  and the xml output is formulated as:
#  <xml_code>
#   <value>foo</value>
#  </xml_code>
#  each module may contain several calls of this type.
#  the previous attribute tag is automatically closed when a new
#  one is introduced.
#
# add_values "value 1" "value 2" "value n"
#  several values can be given;
#  all of them will be separated with tab at stdout,
#  and they will each get their own <value>foo</value> line at xml output.
#  special characters as '\n' and '\t' can be used;
#  they will not affect the xml output.
#  each module may contain several calls of this type.
#
# value_footer
#  this call should follow a block of values, if the value_header
#  function is called before them. this closes open header tags.
#
# module_footer
#  this call should immediately precede the flush_values call.
#  this takes care of closing an open attribute tag.
#
# flush_values
#  prints the values to xml file or to stdout.
#  this should be the final command in a module.
#
#################################################################################
# Written by Mikael Lammentausta and Arvid Norlander
#
# Some parts are taken from:
#   --Advanced Bash Scripting Guide (ABS)
#################################################################################

MODULES_LINUX='distro system kernel processor network applications terminal devices hdd dmi cdrom memory users'
MODULES_BSD='distro system applications terminal network'
MODULES_LANFORCE='distro system processor network dmi devices users applications env'
MODULES_BROKEN='printers services users cdrom memory'
MODULES_REAL_ROOT_ONLY='system terminal applications network devices services hdd printers dmi'
MODULES_SU_ONLY='cdrom hdd dmi memory oem'
# MUST contain a list of all modules. This is used to find any invalid modules.
MODULES_ALL='applications cdrom devices distro dmi env hdd kernel memory network oem printers processor services system terminal users'
################################################################################
################################################################################
## General helper functions                                                   ##
################################################################################
################################################################################

CheckReq_lshw() {
	if [ ! "$(type -p lshw)" ]; then
		add_attribute	"$appname notification"
		add_values		"Please install lshw to collect this information"
		return 1
	else
		return 0
	fi
}

CheckReq_dmidecode() {
	if [ ! "$(type -p dmidecode)" ]; then
		add_attribute	"$appname notification"
		add_values		"Please install dmidecode to collect this information"
		return 1
	else
		return 0
	fi
}

CheckReq_root() {
	if [ ! "$(whoami)" == "root" ]; then
		add_attribute	"$appname notification"
		add_values		"Please run $appname as super-user to collect this information"
		return 1
	else
		return 0
	fi
}


# TODO: Remove the temp file after all modules has run.
lshw_xml() {
	if [ -z "$lshw_xml_file" ]; then
		export lshw_xml_file="$(mktemp /tmp/osinfo.XXXXXX)"
		lshw -xml > $lshw_xml_file
	fi
}

################################################################################
################################################################################
## Modules                                                                    ##
################################################################################
################################################################################




Module_hdd() {
# HARD DISK DRIVES

# this module collects data of the hard disk drives attached to the system.
# some information is unaccesible unless the partitions are mounted.

# S-ATA drives now display everything as nicely as IDE drives,
# due to support in recent smartmontools (version 5.36).

# used tools:
# fdisk, df, udev, /proc (deprecated), smartmontools, hdparm, bc

	moduleName="Disk information"
	module_header "${moduleName}"

	# developement status:
	# -------------------
	# IDE/PATA is tested
	# SATA is tested
	# USBhdd is tested
	# SCSI is untested, although works probably as SATA
	# RAID is untested
	# Logical Volume Management is untested

	# notes:
	# -----
	# FREEBSD: To check the status of drives, use the following:
	# ${PREFIX}/sbin/smartctl -a ad0          for first ATA drive
	# ${PREFIX}/sbin/smartctl -a da0          for first SCSI drive
	#
	# there are at least two methods to parse an alphabetical seq number:
	# awk '{ ind=index("ABCDEFGHIJKLMNOPQRSTUVWXYZ", toupper($0)); print ind; }' <<< $'b\no\ns\na\ni'
	# NUM=$(( $(echo -n 'A' | tr 'a-z' 'A-Z' | od -A n -t u1) - 64)); echo $NUM
	# the latter works by subtracting the ASCII offset (64) from the uppercase character.
	#
	# to use tab as a field separator in awk:
	# awk $'-F\t' {}


	# this module depends heavily on root access, so prevent other users
	# of running this module
	if CheckReq_root; then
		# declare variables
		local totalsize=0 totalfree=0

		# detect all drives in the system
		local drives="$(fdisk -l | grep Disk | grep -Eo '\/(dev)\/\w'+)"

		# loop all detected drives
		for drvdev in $drives; do

			value_header	 ${drvdev}

			# $drvdev is the whole device address, eg "/dev/hda"
			# $drvnode is just the device node, eg "hda"
			# $drvnr is the drive number for this type; eg. for sdc $drvnr=3
			drvnode=$(echo $drvdev | awk -F/ {'print $NF'})
			drvnr=$(( $(echo -n ${drvnode: -1:1} | \
				tr 'a-z' 'A-Z' | od -A n -t u1) - 64));

			if [ "$(echo $drvdev | grep hd)" ]; then

				scan_hdd_ide

			elif [ "$(echo $drvdev | grep sd)" ]; then

				scan_hdd_sg

			elif  [ "$(echo $drvdev | grep md)" ]; then

				scan_hdd_md		# software RAID devices

			else

				add_attribute	"Description"
				add_values		"Unknown device type"

			fi

			#################################
			# common data for all drive types:
			# drive geometry and capacity

			add_attribute	'Geometry'
			add_values		"$(fdisk -l | grep /dev/sda -A 1 | sed -n "2{p;q}")"

			add_attribute	'Capacity (reported)'
			add_values		"$(fdisk -l ${drvdev} | grep ${drvdev} | \
							head -n 1 | grep -Eo '[1-9][0-9]+[\.0-9]* \w{2}' | head -n 1)"

			add_attribute	'Capacity (actual)'

			# fdisk gives drive capacity in mega|gigabytes and bytes.			
			# this is really quirky, since fdisk outputs two numbers,
			# and the last grep here picks the one with FIVE or more
			# numbers, so this might be a problem in some situations,
			# but since the less precise value is rounded, it never
			# should be more than four numbers, like '1032 MB'
			DISKSIZE="$(fdisk -l $drvdev | head -n 2 | grep -Eo '[0-9]{5,}')"
			if [ $DISKSIZE -lt 1073741824 ]; then 
				DZ="$(echo $DISKSIZE/1024/1024 | bc -l)"
				DZ="${DZ:0:5} MB"
			else
				DZ="$(echo $DISKSIZE/1024/1024/1024 | bc -l)" 
				DZ="${DZ:0:5} GB"
			fi
			add_values		"$DZ"


			#####################
			# scan the partitions

			scan_hdd_partitions


			###############################
			# calculate total disk capacity

			[[ $DISKSIZE -lt 1048576 ]] && \
				#diskfr="$(($DISKFREE/1024)) MB"
				diskfr="$(echo $DISKFREE/1024 | bc -l)" && \
				diskfr="${diskfr:0:4} MB"
			[[ $DISKSIZE -gt 1048576 ]] && \
				#diskfr="$(($DISKFREE/1024/1024)) GB"
				diskfr="$(echo $DISKFREE/1024/1024 | bc -l)" && \
				diskfr="${diskfr:0:4} GB"

			#diskpercfree="$(($DISKFREE*1024*100/$DISKSIZE))" # rounds off improperly
			diskpercfree="$(echo $DISKFREE*1024*100/$DISKSIZE | bc -l)"
			diskpercfree="${diskpercfree:0:4}"

			add_attribute	'Free (mounted)'
			add_values		"${diskfr} ; ${diskpercfree}%"

			totalsize=$(($totalsize+$DISKSIZE))
			totalfree=$(($totalfree+$DISKFREE))


			unset DISKSIZE
			unset DISKFREE

		done



		######################################
		# calculate total system disk capacity
		# report data of the whole system

		totalpercfree=0

		#add_attribute	"Total disk space"
		#add_values		"Capacity: $(echo $totalsize)"
		#add_values		"Free: $(echo -e $totalfree ; $totalpercfree %)"

	fi

	# finalize
	module_footer
	flush_values
}

scan_hdd_smart() {
#########################
# S.M.A.R.T. scanning
#
# smartmontools are handy in getting the extended parameters
# of hard drives. only version 5.36 and onward support SATA drives
# and the version may be a bit uncommon, as it was released in April 2006.
# all major distros should begin to include it in their packages,
# so this should be relatively common in late 2006.
# for ide drives this is not a problem.
#
# this function takes one parameter, the driver to use. default is ata.

	local dev_type smart_info
	if [ "$1" ]; then
		dev_type="$1"
	else
		dev_type=ata
	fi

	# allocate a temp file
	smart_info="$(mktemp /tmp/osinfo.XXXXXX)"

	### check the smartctl version >5.36
	version="$(smartctl --version | grep -Eo 'version [0-9.]+' | \
		grep -Eo '[0-9]\.[0-9]+')";
	diff="$(echo $version-5.36 | bc -l)"
	if [ ! "${diff:0:1}" = "-" ]; then # this is a newer version
		smart="sata-ok"
	else
		smart=$version
	fi
	unset version

	smartctl -a -d $dev_type ${drvdev} > $smart_info
	add_attribute	'S.M.A.R.T.'
	add_values		"$(grep 'SMART support' ${smart_info} | \
					head -n 1 | awk -F': ' {'print $2'})"

	add_attribute	'Lifetime'
	add_values		"$(grep -i power_on $smart_info | awk {'print $NF'})"

	add_attribute	'Temperature (C)'
	add_values		"$(grep -i temperature_celsius $smart_info | \
					awk '{for (i=10; i<=NF; i++) printf("%s ",$i);printf ("\n")}')"

	add_attribute	'Health Status'
	add_values		"$( grep -Ei '(health)+' $smart_info | awk {'print $NF'})"

	# cleanup
	rm -f "$smart_info"

}

scan_hdd_partitions() {
####################
# PARTITIONS
#
# function extracts information of hard drive partitions.
#
#
# TODO: an array that stores data of how much is allocated for each FS
# [partition ID=83] [size on hda1] [size on hda4]
# [partition ID=7] [size on hda2] [size on hdb1]

	DISKFREE=0
	partitions_on_drive="$(fdisk -l $drvdev | grep ^$drvdev | wc -l)"

	value_header		"  Partition\t\tcapacity\tfree\tmountpoint\tfilesystem"


	# loop all partitions detected by fdisk

	for PARTNR in $(seq 1 1 $partitions_on_drive); do
		partition="$(fdisk -l $drvdev | grep ^$drvdev | awk {'print $1'} | \
			sed -n "${PARTNR}{p;q;}" )"

		add_attribute	"  ${partition}"


		# CAPACITY; if partition is mounted (=is in mtab)
		#
		# BUG: submounted (=system for automounting usb sticks) partitions
		# are considered unmounted, while they are not!

		if [ "$(df -Plk | grep $partition)" ]; then

			# the partition size is calculated from the value given by df,
			# and the float division is computed by bc.
			# the output of bc is then concatenated by parameter expansion.

			# df reports in kb
			# small partitions are reported in MB, larger in GB
			partsize="$(df -Plk | grep $partition | awk {'print $2'})"
			partfree="$(df -Plk | grep $partition | awk {'print $4'})"

			[[ $partsize -lt 1048576 ]] && \
				pz="$(echo $partsize/1024 | bc -l)" && \
				pz="${pz:0:4} MB"
			[[ $partsize -gt 1048576 ]] && \
				pz="$(echo $partsize/1024/1024 | bc -l)" && \
				pz="${pz:0:4} GB"

			#partpercfree="$(($partfree*100/$partsize))" # rounds off improperly
			partpercfree="$(echo $partfree*100/$partsize | bc -l)"
			partpercfree="${partpercfree:0:4}"

			DISKFREE=$(($DISKFREE+$partfree))


			# capacity
			add_values		"$pz\t"

			# free space
			add_values		"$partpercfree%"

			# mountpoint
			local mp="$(df -PT $partition | grep ^$partition | \
						awk {'print $NF'})"
			# check the number of tabs to add for stdout indent
			if [ ${#mp} -lt 8 ]; then
				mp="${mp}\t"
			fi
			add_values		"${mp}"

		else	# detect capacity of an unmounted partition

			# capacity
			add_values		"-\t"

			# free space
			add_values		"-"

			# mountpoint
			add_values		"unmounted"

		fi

		# filesystem
		# because fdisk adds a '*' character for bootable partitions, awk gets
		# messed up. that is why numbers are removed from the beginning of string.
		add_values		"$(fdisk -l | grep ^${partition} | \
						awk '{for (i=6; i<=NF; i++) printf("%s ",$i);printf ("\n")}' | \
						sed 's/^[0-9 ]*//')"
						#(read Disk foo bar foobar something partition; echo "$partition"))"

	done
}

scan_hdd_ide() {
#################
# IDE drives
#
# this function collects information of IDE drives in the system.
#
# udevinfo, /proc/ide/, smartmontools and hdparm are used as the data source.

	# detect the available data sources
	if [ "$(type -p udevinfo)" ]; then
		# allocate a temp file
		local udev_info="$(mktemp /tmp/osinfo.XXXXXX)"
		udevinfo -q all -n ${drvdev} > $udev_info
	fi
	if [ -e "/proc/ide/" ]; then
		local proc_info="/proc/ide/${drvnode}"
	fi
	# hdparm output is not read into a temp file, as
	# it is unlikely to be used, and that would unnecessarily
	# slow down this function.



	########
	# Vendor
	if [ "$(type -p smartctl)" ]; then

		# because smartctl uses its own database to report the HDD vendor,
		# it is preferred over udev.
		#
		# this smart scan is not included into the scan_hdd_smart()
		# because it would break the correct order of the report.

		local vendor="$(smartctl -i ${drvdev} | grep '^Model' | \
						awk -F: {'print $2'} | sed 's/^ *//') "

	elif [ "${udev_info}" ]; then

		local vendor="$(udevinfo -q all -n ${drvdev} | grep -i vendor | \
						awk -F_ {'print $NF'}) "
	fi


	#######
	# Model
	if  [ "${udev_info}" ]; then

		local model="$(udevinfo -q all -n ${drvdev} | grep -i model | \
						awk -F= {'print $NF'})"

	elif [ -e "${proc_info}" ]; then

		local model="$(cat ${proc_info}/model)"

	elif [ "$(type -p hdparm)" ]; then

		local model="$(hdparm -i ${drvdev} | grep -Eio 'Model=\w+' | \
						awk -F= {'print $2'})"
	fi


	# report both vendor and model on one line
	add_attribute	'IDE drive'	'hard_disk'
	add_values		"$vendor$model"


	###############
	# Serial number
	add_attribute	'Serial number'

	if  [ "${udev_info}" ]; then

		add_values		"$(grep SERIAL ${udev_info} | awk -F= {'print $NF'})"

	elif [ "$(type -p hdparm)" ]; then

		add_values  "$(hdparm -i ${drvdev} | grep -Eio 'serialno=\w+' | \
		             awk -F= {'print $2'})"
	fi


	########
	# Driver
	if [ -e "/proc/ide/$drvnode" ]; then
		add_attribute	'Driver'
		add_values		"$(cat ${proc_info}/driver)"
	fi


	#####
	# DMA
	if [ "$(type -p hdparm)" ]; then
		add_attribute	'DMA'
		add_values		"$(hdparm ${drvdev} | grep dma | grep -Eo '\([onf]+\)')"
	fi


	############
	# SMART info
	if [ "$(type -p smartctl)" ]; then
		scan_hdd_smart ata
	fi


	# cleanup
	rm -f "$udev_info"

}

scan_hdd_sg() {
#################
# SATA/SCSI/USB drives (sg driver)
#
# this function collects information of SATA/SCSI/USB drives,
# because under Linux they all use the same SCSI drivers.
#
# the information in stored into two or three locations, depending
# on the kernel and whether the system uses devfs or udev.
# since devfs is deprecated, it is not used at all.
# the /proc/scsi/ system is deprecated from 2.6 on, but it is left
# here for legacy support.
#
# usb drives, when properly detected by the Linux kernel,
# are added to /proc/scsi/scsi info sheet, and the assigned scsi number
# which can be found both in the beforementioned location and also
# in /proc/scsi/sg/devices, can be used to identify the device
# in /proc/scsi/usb-storage/*.
#
# as the devices are (hopefully) linearily, the devices catalogue
# can be used to identify which /dev/sd* node is a certain scsi#.
#
# this is not true in the case of custom udev rules. although
# a good practise is to let kernel do its magic and create a
# link node to that device, so this is unlikely to be a problem.
#
# smartmontools support SATA drives from version 5.36 on
# (released April 2006). this function is written in June 2006,
# and for that the version of smartctl is checked before trying
# to access SATA drives.

	# detect the available data sources
	if [ "$(type -p udevinfo)" ]; then
		# allocate a temp file
		local udev_info="$(mktemp /tmp/osinfo.XXXXXX)"
		udevinfo -q all -n ${drvdev} > ${udev_info}
	fi
	if [ -e "/proc/scsi/" ]; then
		local proc_info="/proc/scsi/scsi"
		local scsi_devices="/proc/scsi/sg/devices"
		local scsi_devstrings="/proc/scsi/sg/device_strs"
		local usb_devstrings="/proc/scsi/usb-storage/"
		local sg_version="/proc/scsi/sg/version"

		local scsi_nr="$(sed -n "$drvnr{p;q;}" ${scsi_devices} | awk {'print $1'})"
	fi
	# hdparm output is not read into a temp file, as
	# it is unlikely to be used, and that would unnecessarily
	# slow down this function.



	if [ "${udev_info}" ]; then

		local bus="$(grep -i ID_BUS ${udev_info} | awk -F= {'print $NF'})"
		if [ "$(echo $bus | grep usb)" ]; then
			# USB drive detected

			local drive_type='USB drive'

		fi

		# test if the scsi_nr is found in /proc/scsi/usb-storage/
	elif [ -e "${proc_info}" ]; then

		if [ -e "${usb_devstrings}${scsi_nr}" ]; then
			local usb_info="${usb_devstrings}/${scsi_nr}"
			local drive_type='USB drive'
		fi

	else
	# SATA/SCSI drive

		local drive_type='SATA/SCSI drive'

	fi


	########
	# Vendor
	if [ "$smart" = "sata-ok" ]; then

		# because smartctl uses its own database to report the HDD vendor,
		# it is preferred over udev.
		#
		# this smart scan is not included into the scan_hdd_smart()
		# because it would break the correct order of the report.

		local vendor="$(smartctl -i -d ata ${drvdev} | grep '^Model' | \
						awk -F: {'print $2'} | sed 's/^ *//') "

	elif [ "${udev_info}" ]; then

		local vendor="$(grep -i vendor ${udev_info}  | \
						awk -F= {'print $NF'}) "

	elif [ -e "${proc_info}" ]; then

		local vendor="$(sed -n "$drvnr{p;q;}" "${scsi_devstrings}" | \
						awk {'print $1'}) "
						#"$(grep -i vendor ${usb_info} | awk -F': ' {'print $2'})"
	fi


	#######
	# Model
	if  [ "${udev_info}" ]; then

		local model="$(grep -i model ${udev_info} | \
						awk -F= {'print $NF'})"

	elif [ -e "${proc_info}" ]; then

		local model="$(sed -n "$drvnr{p;q;}" "${scsi_devstrings}" | \
						awk {'print $2" "$3'})"

	elif [ "$(type -p hdparm)" ]; then

		local model="$(hdparm -i ${drvdev} | grep -Eio 'Model=\w+' | \
						awk -F= {'print $2'})"
	fi


	# report both vendor and model on one line
	add_attribute	"$drive_type"		'hard_disk'
	add_values		"$vendor$model"



	###############
	# Serial number
	add_attribute	'Serial number'

	if  [ "${udev_info}" ]; then

		add_values		"$(grep SERIAL ${udev_info} | awk -F= {'print $NF'})"

	elif [ "$(type -p hdparm)" ]; then

		add_values		"$(hdparm -i ${drvdev} | grep -Eio 'serialno=\w+' | \
						awk -F= {'print $2'})"
	fi


	########
	# Driver
	if [ -e "${proc_info}" ]; then
		add_attribute	'Driver'
		add_values		"Linux SCSI Generic (sg) v.$(cat ${sg_version})"
	fi

	#add_attribute	'DMA'
	#add_values		"n/a" #enabled/disabled

	if [ "$smart" = "sata-ok" ]; then
		scan_hdd_smart ata
	fi

	# cleanup
	rm -f $udev_info

}

scan_hdd_md() {
#######################
# SOFTWARE RAID ARRAYS

	value_header	"todo"

}

Module_memory() {
# MEMORY

# this module tells complete information of the memory
# installed on the system.
#
# only RAM at the moment and the solution is really dirty because
# it uses lshw. 'free' and '/proc/meminfo' would also report
# free RAM, but slightly incorrect number because it's the total
# ram after kernel has allocated some for system services.
#
#
# requires root access

	moduleName="System memory"
	module_header "${moduleName}"

	if CheckReq_lshw && CheckReq_root; then


		# TODO: add support for memory type/speed detection thru lshw
		# FIXME: if there's an open lshw.tmp, then it should be used
		lshw_xml
		local lshw_tmp="$lshw_xml_file"

		# for some odd reason meminfo or free don't give a proper value

		meminfo="/proc/meminfo"

		#totalram="$(cat ${meminfo} | grep -i memtotal | grep -Eo [0-9]+)"
		totalram="$(grep 'id="memory' -A 20 ${lshw_tmp} | grep size | \
			grep -Eo '[0-9]+')"

		totalram="$(echo "$totalram/1024/1024" | bc -l | grep -Eo '[0-9]+\.[0-9]{1}')"

		add_attribute	'RAM total'	'ram'
		add_values		"$totalram MB"

	fi

	module_footer
	flush_values

}


Module_cdrom() {
# INFORMATION OF CD/DVD DEVICES

	moduleName="CD/DVD drives"
	module_header "${moduleName}"

	if CheckReq_lshw && CheckReq_root; then
		# TODO: use a common lshw temp file
		lshw_xml
		local lshw_tmp="$lshw_xml_file"
		cdrom_tmp="$(mktemp /tmp/osinfo.XXXXXX)"

		# this gets the line number of the wanted node from lshw '$this'
		# and the line number of the next node '$next'
		# then what's between those lines is printed to another tmp file
		this="$(grep -n "node id=\"cdrom" $lshw_tmp | \
			awk -F: {'print $1'})"
		next="$(grep -n 'node id' $lshw_tmp | grep -A 1 cdrom | \
			awk -F: {'print $1'} | sed -n "2{p;q}")"
		((this++)) # this prevents the 'node' lines from printing
		((next--))

		# use a temp file to store cdrom information
		sed -n "$this,$next{p;}" ${lshw_tmp} > ${cdrom_tmp}

		#cat $cdrom_tmp
		#exit 0


		add_attribute	'Model'	'cdrom'
		add_values		"$(grep -i product ${cdrom_tmp} | \
						sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		add_attribute	'Drive type'
		add_values		"$(grep -i description ${cdrom_tmp} | \
						sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		add_attribute	'Device node'
		add_values		"$(grep -i 'logicalname' ${cdrom_tmp} | \
						sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		add_attribute	'Serial number'
		add_values		"$(grep -i serial ${cdrom_tmp} | \
						sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		#add_attribute	'Capabilities'
		#add_values		"$(grep -i capabilities ${cdrom_tmp} | \
		#				sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		#value_footer


	fi

	module_footer
	flush_values

}


Module_dmi() {
# DMI / OEM INFORMATION

# this module works as a replacement for module_oem. this is faster,
# as it doesn't scan hardware. look below for excerpt from 'man dmidecode':
#
# dmidecode  is  a  tool  for dumping a computer's DMI (some say SMBIOS) table
# contents in a human-readable format.
# This table contains a description of the system's hardware components,
# as well as other useful pieces of information  such  as  serial
# numbers and BIOS revision. Thanks to this table, you can retrieve this
# information without having to probe for the actual hardware.  While this
# is a good point in terms of report speed and safeness,  this also makes
# the presented information possibly unreliable.

	moduleName="DMI information"
	module_header "${moduleName}"

	if CheckReq_dmidecode && CheckReq_root; then
		# allocate the temp files
		dmi_info="$(mktemp /tmp/osinfo.XXXXXX)"
		dmi_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		dmidecode > $dmi_info


		# the interesting handles:
		# 0x0000 'BIOS Information'
		# 0x0001 'System Information'
		# 0x0002 'Base Board Information'
		# 0x0003 'Chassis Information'

		local HANDLES="0x0000 0x0001 0x0002 0x0003"

		# following loop extracts the data under the nodes variable.

		# (1) get the line number where the 'node id=$HANDLES'
		# (2) get the line number of the next 'node id'
		# (3) everything in between those lines contains interesting data

		for myHANDLE in $HANDLES; do

			this="$(grep -n "Handle ${myHANDLE}" ${dmi_info} | \
				awk -F: {'print $1'})"
			next="$(grep -n Handle ${dmi_info} | grep -A 1 ${myHANDLE} | \
				awk -F: {'print $1'} | sed -n "2{p;q}")"
			((this++)) # this prevents the 'handle' lines from printing
			((next--))

			# use a temp file to store handle information
			sed -n "$this,$next{p;}" ${dmi_info} > ${dmi_tmp}


			# here the data is processed
			case $myHANDLE in

				"0x0001")	# System Information

					value_header	"System info"


					add_attribute	'Manufacturer' \
									'system_manufacturer'
					add_values		"$(grep -i manufacturer ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Product name'	'system_model'
					add_values		"$(grep -i product ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'System version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'OEM serial number' \
									'computer_product_serial'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'UUID' 	'uuid'
					add_values		"$(grep -i uuid ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;

				"0x0002")	# Base Board Information

					value_header	"Motherboard"


					add_attribute	'Manufacturer' \
									'mother_board_manufacturer'
					add_values		"$(grep -i manufacturer ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Model' \
									'mother_board_model'
					add_values		"$(grep -i product ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Version' \
									'mother_board_version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Serial number' \
									'mother_board_serial_number'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;

				"0x0000")	# BIOS Information

					value_header	"BIOS"

					add_attribute	'Vendor'
					add_values		"$(grep -i vendor ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Revision'	'bios_version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Date'	'bios_date'
					add_values		"$(grep -i date ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Serial number'	'bios_serial_number'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;


				"0x0003")	# Chassis Information

					value_header	'Chassis'

					add_attribute	'Manufacturer' 	'chassis_manufacturer'
					add_values		"$(grep -i manufacturer ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Type' 	'chassis_type'
					add_values		"$(grep -i type ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Version' 	'chassis_version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Serial number' \
									'chassis_serial_number'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Lock' 	'chassis_lock'
					add_values		"$(grep -i lock ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Asset tag' 'chassis_asset_tag'
					add_values		"$(grep -i asset ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;

			esac

		done

	fi

	# cleanup
	rm -f $dmi_info $dmi_tmp

	module_footer
	flush_values

}


Module_oem() {
# OEM INFORMATION (rewrite)
# this module is deprecated in favor of module_dmi

# this module collects information from lshw, a somewhat rare package, which
# tells a lot of interesting information of the system hardware.  it also seems
# to be the only way to get the serial number of a branded computer, thus 'oem
# info'. below is an excerpt from 'man lshw'
#
# lshw  is a small tool to extract detailed information on the hardware
# configuration of the machine. It can report exact memory configuration,
# firmware version, mainboard configuration, CPU version and  speed,  cache
# configuration,  bus  speed, etc. on DMI-capable x86 or IA-64 systems and on
# some PowerPC machines (PowerMac G4 is known to work).  It currently supports
# DMI (x86 and IA-64 only), OpenFirmware device tree (PowerPC only),  PCI/AGP,
# CPUID  (x86),IDE/ATA/ATAPI, PCMCIA (only tested on x86), SCSI and USB.

	local moduleName="OEM information"
	module_header "${moduleName}"


	if CheckReq_lshw && CheckReq_root; then
		lshw_xml
		local lshw_tmp="$lshw_xml_file"

		# the interesting entries:
		# $hostname
		# core
		# firmware

		local NODES="$(hostname) core firmware"

		# following loop extracts the data under the nodes variable.

		# (1) get the line number where the 'node id=$NODES'
		# (2) get the line number of the next 'node id'
		# (3) everything in between those lines contains interesting data

		for myNODE in $NODES; do

			this="$(grep -n "node id=\""${myNODE}"\"" $lshw_tmp | \
				awk -F: {'print $1'})"
			next="$(grep -n 'node id' $lshw_tmp | grep -A 1 ${myNODE} | \
				awk -F: {'print $1'} | sed -n "2{p;q}")"
			((this++)) # this prevents the 'node' lines from printing
			((next--))

			local IFSbk="$IFS"
			IFS="
"; # a literal newline, do not indent!

			for info in $(sed -n "$this,$next{p;}" $lshw_tmp); do

				# the data is avaiable here, printed line by line.
				# usually the fields are:

				# <description>
				# <product>
				# <vendor>
				# <version>
				# <serial>

				# then there special fields. see 'lshw -xml'

				# parse standard <foo> tags
				# TODO: add support for capabilities tags
				local tag="$(grep -o '<[a-z]*>' <<< ${info} | \
							sed 's/<\([^>]*\)>/\1/')"
							# matched everything between '<' and '>'

				[ "$tag" ] && \
				local value="$(grep ${tag} <<< ${info} | \
							awk -F'<|>' {'print $3'})"

				# here the data is processed
				case $myNODE in

					"$(hostname)")	# OEM info

						if [ "$printed" != "oem" ]; then
							value_header	"OEM info"
							local printed="oem"
						fi

						case $tag in

							'description')

								add_attribute 'System model' \
								              'system_model'
								add_values    "$value"
								;;

							'vendor')

								add_attribute 'System manufacturer' \
								              'system_manufacturer'
								add_values    "$value"
								;;

							'product')

								add_attribute	'System name'
								add_values		"$value"
								;;

							'version')

								add_attribute	'System version'
								add_values		"$value"
								;;

							'serial')

								add_attribute 'OEM serial number' \
								              'computer_product_serial'
								add_values    "$value"
								;;

							#*)

								#add_attribute	"$tag"
								#add_values		"$value"
								#;;

						esac

						value_footer
						;;

					'core')			# mobo info

						if [ "$printed" != "mobo" ]; then
							value_header	"Motherboard"
							local printed="mobo"
						fi

						case $tag in

							'vendor')

								add_attribute 'Make'
								add_values    "$value"
								;;

							'product')

								add_attribute 'Model'
								add_values    "$value"
								;;

							'version')

								add_attribute 'Revision'
								add_values    "$value"
								;;

							'serial')
								add_attribute 'Serial number' \
								              'mother_board_serial_number'
								add_values    "$value"
								;;

						esac

						value_footer
						;;

					'firmware')		# BIOS info

						if [ "$printed" != "bios" ]; then
							value_header	"BIOS"
							local printed="bios"
						fi

						case $tag in

							'vendor')

								add_attribute	'Vendor'
								add_values		"$value"
								;;

							'version')

								add_attribute	'Revision'	'bios_version'
								add_values		"$value"

								# trying to extract date from version
								add_attribute	'Date'	'bios_date'
								add_values		"$(echo $value | \
									grep -Eo '([0-9]{2,4}[-./][0-9]{2}[-./][0-9]{2,4})+')"
								;;

							'date')

								add_attribute	'Date'	'bios_date'
								add_values		"$value"

								;;

							'serial')
								add_attribute 'Serial number' \
								              'bios_serial_number'
								add_values    "$value"
								;;

						esac

						#value_footer
						# this produces an eternal loop
						;;

				esac

			done

			IFS="$IFSbk"

		done
	fi

	module_footer
	flush_values

}


Module_oem_old() {
# OEM INFORMATION
# deprecated, as this module has been rewritten. left here for reference.
#AnMaster: why? you can just look at an older revision in svn. If this is not used anywhere it should be deleted before a release.

	moduleName="OEM information"
	module_header "${moduleName}"
	error_deprecated Module_oem_old

	if CheckReq_lshw && CheckReq_root; then

		lshw_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		lshw > $lshw_tmp

		# principle:
		# (1) output of lshw is stripped out of newlines, switched spaces with _ and
		#     added %newline% to denote a value pair
		# (2) this is put into hardware array, because bash doesn't support
		#     two-dimensional arrays
		# (3) a for loop then checks each array element for OUTPUT type node ID.
		# (4) another loop checks for DO_NOT_OUTPUT ; if this is satisfied,
		#     values are sent with add_values()


		# the verbosity of this module can be controlled by modifying the
		# OUTPUT and DO_NOT_OUTPUT strings. the example below should be clear.

		OUTPUT="$(hostname)\|cpu\|core\|firmware\|memory\|cdrom\|disk"
		DO_NOT_OUTPUT="description\|capabilities\|configuration\|resources\|physical\|bus"

		[[ "$isverbose" -eq 1 ]] &&
		OUTPUT=$OUTPUT"\|ide\|pci\|usb"


		# this loop fills the $hardware[] array with entries from lshw.
		#
		# 1) the leading spaces are removed
		# 2) whitespaces are converted to underscores
		# 3) newlines are replaced by '%newline%'
		# 4) the '*' character is the node identifier in lshw.
		#
		# the product of this is an array, where an item contains
		# all information of the node parsed to a single string.
		for node in $(seq 0 1 $(

				cat ${lshw_tmp} | grep '\*' | wc -l

				#cat ${lshw_tmp} | sed 's/^ *//' | tr ' ' '_' | \
				#sed ':a;N;$!ba;s/\n/%node%/g' | awk -F"*" {'print NF'}

				));	do

		 #hardware_debug[$HW]="foo"
		 #echo $HW
		 #echo ${#hardware[@]}
		 oem_str[$node]="$(

			cat ${lshw_tmp} | sed 's/^ *//g' | tr ' ' '_' | \
			sed ':a;N;$!ba;s/\n/%newline%/g' | awk -F"*" {'print $('$node'+1) '}

		)"

		done

	# then fix the first node so that the hostname isn't printed
		oem_str[0]="-${oem_str[0]}"


		# parse the string in a loop
		for node in $(seq 0 1 ${#oem_str[@]}); do

		# if the oem_string contains an interesting node...
			if [ "$(echo ${oem_str[$node]} | awk -F'%newline%' {'print $1'} | \
			grep -i $OUTPUT)" ]; then # we want output

			myELEMENT=1;

			# then parse all elements in the array
			while [ "$(echo ${oem_str[$node]} | \
				awk -F'%newline%' {'print NF'})" -gt "$myELEMENT" ]; do


			 # if the node doesn't contain info we don't want..
				if [ ! "$(echo ${oem_str[$node]} | \
					awk -F'%newline%' {'print $'$myELEMENT' '} | \
					grep -i $DO_NOT_OUTPUT)" ]; then

					# the oem_string is extracted into a variable
					oem_node="$(echo ${oem_str[$node]} | \
						awk -F'%newline%' {'print $'$myELEMENT' '})"

					# then prune out the *-foo nodes
					# and send the data to add_values()
					if [ ! "$(echo ${oem_node} | grep '^-')" ]; then

						add_attribute	"  $(echo ${oem_node} | \
							awk -F":_" {'print $1'} | tr '_' ' ')"

						add_values		"  $(echo ${oem_node} | \
							awk -F":_" {'print $2'} | tr '_' ' ')"

					fi

					# 'description' values are printed as headers
				elif [ "$(echo ${oem_str[$node]} | \
					awk -F'%newline%' {'print $'$myELEMENT' '} | \
					grep -i 'description')" ]; then

					value_header	"$(echo ${oem_str[$node]} | \
						awk -F'%newline%' {'print $'$myELEMENT' '} | \
						awk -F":_" {'print $2'} | tr '_' ' ')"

				fi

				((myELEMENT++));
			done
			fi
		done


	fi

	# cleanup
	#rm $lshw_tmp -f

	module_footer
	flush_values
}


Module_system() {
# GENERAL INFORMATION OF THE SYSTEM

	moduleName="System"
	module_header "${moduleName}"

	add_attribute	"Operating system"			"os"
	add_values		"$distro_id $(uname -s) $distro_release"

	add_attribute	$"Operating system kernel"	"os_build"
	add_values		"$(uname -sr)"

	add_attribute	$"Network node hostname"	"host_name"
	add_values		"$(hostname)"

	add_attribute	$"Machine hardware name"	"system_type"
	add_values		"$(uname -m)"

	add_attribute	$"System locale"
	add_values		"$(echo $LC_ALL)"

	add_attribute	$"System uptime"			"uptime"
	add_values		"$(uptime | awk -F, {'print $1'} | \
					grep -Eo 'up [a-z0-9: ]*' | sed 's/^[up ]*//')"

	module_footer
	flush_values
}

Module_kernel() {
# OPERATING SYSTEM KERNEL

	moduleName="Kernel"
	module_header "${moduleName}"

	add_attribute	$"Operating system"
	add_values		"$(uname -o)"

	add_attribute	 $"Kernel release"
	add_values		"$(uname -r)"

	# Unique kernel name
	if [ -e "/usr/src/linux" ]; then
		kernel_makefile="/usr/src/linux/Makefile"
	elif [ "$(ls /usr/src/ | grep linux)" ]; then
		kernel_makefile="/usr/src/linux*/Makefile"
	fi
	if [ -e "${kernel_makefile}" ]; then
		add_attribute	$"Kernel name"
		add_values		"$(head ${kernel_makefile} | grep NAME | \
						head -n 1 | awk -F= {'print $2'})"
	fi

	module_footer
	flush_values
}

Module_processor() {
# INFORMATION OF THE CPU

	moduleName="Processor"
	module_header "${moduleName}"

	# AnMaster: Why this line? Would it ever be anything else?
	local cpuinfo="/proc/cpuinfo"
	cpu_count="$(grep 'cpu cores' ${cpuinfo} | head -n 1 | awk {'print $NF'})"

	# test if /proc/cpuinfo gives a number for cpu cores.
	# if it is does not, the kernel probebly lacks SMP support so assume 1 cpu.
	if [ ! "$cpu_count" ]; then
		local cpu_count=1
	fi

	add_attribute	"Count"			"processor_count"
	add_values		$cpu_count

	for cpunr in $(seq 1 1 $cpu_count); do

		if [ $cpu_count -gt 1 ]; then
			value_header	"Processor $cpunr"
		fi

		add_attribute	"Vendor"		"processor_vendor"
		add_values		"$(grep 'vendor' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2'})"

		add_attribute	"Model"			"processor_model"
		add_values		"$(grep 'model name' ${cpuinfo} | \
						sed -n "$cpunr{p;q}" | awk -F': ' {'print $2'})"

		add_attribute	"Frequency"		"processor_speed"
		add_values		"$(grep 'cpu MHz' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2" MHz"'})"

		add_attribute	"Cache"
		add_values		"$(grep 'cache' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2'})"

		add_attribute	"Stepping"
		add_values		"$(grep 'stepping' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2'})"


	done

	module_footer
	flush_values
}

Module_terminal() {
# INFORMATION OF THE TERMINAL IN USE

	moduleName="Terminal info"
	module_header "${moduleName}"

	add_attribute	"Terminal type"
	add_values		"$TERM"

	add_attribute	"Terminal speed"
	add_values		"$(stty speed)"

	add_attribute	"Rows"
	add_values		"$(stty size | awk '{print $1}')"

	add_attribute	"Columns"
	add_values		"$(stty size | awk '{print $2}')"

	module_footer
	flush_values
}


Module_printers() {
# PRINTERS AVAILABLE TO THE SYSTEM

# uses only lpstat (cups) and hasn't been tested on multi-printer
# environments

	moduleName="Printers"
	module_header "${moduleName}"

	# first of all, check if lpstat is available
	if [ "$(type -p lpstat)" ]; then

		#	if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then

		add_attribute		'Printer'	'local_printer'

		# as there may be several printers, print info from all
		for lp_nr in $(seq 1 1 $(lpstat -a | wc -l) ); do

			add_values	"$(lpstat -a 2> /dev/null | sed -n "$lp_nr{p;q;}")"

		done

	fi


	module_footer
	flush_values

}


Module_users() {
# USERS

# reports the current user, the user's X11 session manager + shell
# the last logged user, and other users that have logged in 
# (that last can see).

	moduleName="Users"
	module_header "${moduleName}"


	add_attribute	'Current user'			"current_user"
	add_values		"$(whoami)"


	add_attribute	'Real name'				"real_name"
	add_values		"$(grep $(whoami) /etc/passwd | awk -F: {'print $5'})"


	add_attribute	"User's X11 session"	"users_window_manager"
	# KDE sets $DESKTOP_SESSION nicely, but Gnome doesn't.
	local session_id="$(echo $DESKTOP_SESSION)"
	if [ "$session_id" == "default" ]; then
		if [ "$GNOME_DESKTOP_SESSION_ID" ]; then
			# try to get Gnome version
			local gnome_version="$(gnome-about --version | awk {'print $NF'})"
			session_id="Gnome $gnome_version"
		fi
	fi
	add_values		"$session_id"

	
	add_attribute	"User's shell"
	add_values		"$(echo $SHELL)"


	add_attribute	'Last logged in user'	"last_logged_user"
	add_values		"$(last -1 | head -n 1 | awk {'print $1'})"


	add_attribute	'All users'				"users"
	# because 'last' command, part of sysvinit core package,
	# interprets the binary file /var/log/wtmp, but chomps off
	# the loginname at 9 characters, we need to find the full names
	# from the source file. a dirty hack...

	local users="$(last | awk {'print $1'} | sort | uniq | \
	               grep -v 'reboot\|wtmp' | grep '^[a-zA-Z]')"
	               # removes users 'reboot' and 'wtmp'
	local user
	local wtmp_file="/var/log/wtmp"
	for user in $users; do

		if [ ${#user} -ge 8 ]; then
			# parse special chars to meta-chars
			user="$(echo $user | sed 's/[[:punct:]]/\\&/g' )"
			add_values	"$(grep -Eoa "$user[a-zA-Z+]*" ${wtmp_file} | uniq)\n"
		else
			add_values	"$user\n"
		fi
	done

	module_footer
	flush_values
}


Module_services() {
# INFORMATION OF SYSTEM SERVICES

# Gentoo: rc-status

# Fedora: /sbin/service --status-all
#		  chkconfig --list

# Ubuntu:

	moduleName="Services"
	module_header "${moduleName}"


	module_footer
	flush_values


}



Module_network() {
# NETWORK

# this module detects the network settings of the computer.
#
# there are at least two methods to pull in information; ifconfig and iproute2.
# ifconfig is used; there are at least two versions of ifconfig being used, and
# all tested Linuxes have used the same, whereas FreeBSD v6 had different
# output. the script should work on both versions.

# some changes have been made after testing with FreeBSD, so compitibility
# may not be 100% anymore.

# wireless support is in the works

	moduleName="Network information"
	module_header	"${moduleName}"

	local specials="UP|BROADCAST|LOOPBACK|NOARP|NOTRAILERS|RUNNING|MULTICAST"
	# what are these needed for?

	# allocate the temp file
	nw_info="$(mktemp /tmp/osinfo.XXXXXX)"


	################################
	# DETECT (WIRED) NETWORK DEVICES
	# using ifconfig
	#
	# detect the type of OS (and ifconfig available); there may other
	# versions, but these two OSes were tested. all ifconfigs in Linux operate
	# more of less similarity, but the one on FreeBSD is different.
	if [ "$(type -p ifconfig)" ]; then
		nw_src="ifconfig"

		if [ "$SYSTEM" == "linux" ] ; then
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST -B 3 | \
			grep -Ev '(^ )|(^--)|LOOPBACK' | awk  {'print $1'})"

		else # *BSD ifconfig
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST | grep -v LOOPBACK | \
			awk -F': ' {'print $1'})"
		fi
	fi


	# collect the information from detected network devices
	for interface_name in $ETH_DEVICES; do
		ifconfig $interface_name > ${nw_info}

		value_header	$interface_name

		add_attribute	'MAC'		"mac_address"
		add_values		"$(cat ${nw_info} | \
						grep -Eo '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}')"

		# TODO: IP type (static or dynamic)
		#add_attribute	'IP type'	"ip_type"

		add_attribute 'IPv4'		"ip_address"
		add_values    "$(grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' ${nw_info} | \
		                 grep -Eo '[0-9\.]+' )"

		add_attribute 'IPv6'
		add_values    "$(sed "s/  /\n/g" ${nw_info} | grep -i inet6 | \
		                 grep -Eio '([0-9a-f]{3,4}(\:){1,2}){4,8}([0-9a-f]{3,4})' )"

		add_attribute	'NIS domain'
		add_values		"$(hostname -y 2> /dev/null)"
		# hostname produces stderr if no network is available

		add_attribute	'DNS domain'	'domain'
		add_values		"$(hostname -d 2> /dev/null)"

		add_attribute	'FQDN'		"fully_qualified_domain_name"
		add_values		"$(hostname -f 2> /dev/null)"

		add_attribute	'Gateway'	"default_gateway"
		add_values		"$(route -n | awk '/^0.0.0.0/{print $2}')"

		add_attribute	'Broadcast'
		add_values		"$(sed "s/  /\n/g" ${nw_info} | \
						grep -Eio 'cast[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | \
						grep -Eo '[0-9\.]+' )"

		add_attribute	'Netmask'	"subnet_mask"
		add_values		"$(sed "s/  /\n/g" ${nw_info} | \
						grep -Eio 'mask[A-Za-z: ]*((([0-9]{1,3}\.){3}[0-9]{1,3})|(0x[0-f]{8}))' | \
						grep -Eo '[0-9\.fx]+' )"

		add_attribute	'RX bytes'
		add_values		"$(sed "s/  /\n/g" ${nw_info} | \
						grep -i 'RX bytes' | awk -F: {'print $2'})"

		add_attribute	'TX bytes'
		add_values		"$(sed "s/  /\n/g" ${nw_info} | \
						grep -i 'TX bytes' | awk -F: {'print $2'})"

		value_footer

	done


	###################################################
	# DETECT WIRELESS NETWORK DEVICES AND ACCESS POINTS
	# with iwconfig, Linux only
	#
	# under developement, does not yet work!

	# FIXME: This odd debug usage sucks... Better add a --debug if you realy need this.
	# note: for debugging, these variables are set here
	iw_src="debug/wlan-iwconfig-on"
	WLAN_DEVICES="eth1"
	ap_src="debug/wlan-stations"

	if [ "$(type -p iwconfig)" ]; then

		iw_src="iwconfig"

		# not tested yet
		if [ "$SYSTEM" == "linux" ] ; then

		# FIXME: on my system w/ wireless-tools,
		# but no wlan network (no working drivers)
		#  iwconfig -a
		#  -a        No such device

			ETH_DEVICES="$(iwconfig -a | grep BROADCAST -B 3 | \
			grep -Ev '(^ )|(^--)|LOOPBACK' | \
			awk  {'print $1'})"
		fi

	fi
	
	# info from access points (AP)
	if [ "$(type -p iwlist)" ]; then
		# tweak this a bit
		ap_src="iwlist $WLAN_DEVICES scan"
	fi

	value_header	'wlan'

	add_attribute	"associated ESSID"
	add_values		"$(grep -Eo 'ESSID[:"A-Za-z/ ]*' "${iw_src}" | \
					awk -F: {'print $2'})"

	value_footer




	# cleanup
	rm -f ${nw_info}

	module_footer
	flush_values
}


##
# Gets data from lsb_release
# Parameters:
#  1  string   what value to get.
distro_lsb_release() {
	lsb_release -a 2> /dev/null | grep -i "^$1" | awk -F: '{print $2}' | sed -s 's/^\t*//'
}

Module_distro() {
# DISTRIBUTION

# this module will try to guess which Linux distrobution is installed.
# the default tool to use is the lsb-release (Linux Standard Base
# version reporting utility)

# a secondary id source are the unique files in /etc/, and as a last
# resort the /etc/issue file. this makes it possible to identify
# a distro which resides in a chroot environment, or from a livecd.

	moduleName="Distribution"
	module_header "${moduleName}"

	# TODO
	# the extracted information is stored into these variables,
	# defined by lsb_release and at the end of the function printed.
	# distro_id distro_release 
	local distro_codename distro_description

	# locate and echo the root directory.
	# TODO: Some of this isn't actually needed as we allready fixed so there is at most one endning / (can be zero ending / too).
	[ "$prefix" != '/' ] && \
		local root_dir="$(echo $prefix | sed 's/\/*$//')" || \
		local root_dir="$prefix"
	add_attribute		'Root dir'
	add_values			"$root_dir"

	[ "$root_dir" != '/' ] && root_dir="${root_dir}/"

	# look for lsb-release if real root is used.
	if [ "$(type -p lsb_release)" ] && [ "$prefix" == '/' ]; then

		distro_id="$(distro_lsb_release 'distributor')"
		distro_release="$(distro_lsb_release 'distributor')"
		distro_codename="$(distro_lsb_release 'codename')"
		distro_description="$(distro_lsb_release 'codename')"

	else

		# Begin searching for distro identifying files
		local found_files="" myfile
		for myfile in ${root_dir}etc/{SuSE-release,fedora-release,redhat-release,slackware-version,Topologilinux-version,gentoo-release,issue}; do
			[ -e $myfile ] && found_files="$found_files $myfile"
		done

		# Now make a list of distros from the $found_files list above
		local found_distros="" distro_ident
		for distro_ident in $found_files; do
			case $distro_ident in
				"${root_dir}etc/SuSE-release")
					found_distros="$found_distros SuSE"
					break;
					;;
				"${root_dir}etc/fedora-release")
					found_distros="$found_distros Fedora Core"
					break;
					;;
				"${root_dir}etc/redhat-release")
					found_distros="$found_distros Red Hat"
					break;
					;;
				"${root_dir}etc/slackware-version")
					found_distros="$found_distros Slackware"
					break;
					;;
				"${root_dir}etc/Topologilinux-version")
					found_distros="$found_distros Topologilinux"
					break;
					;;
				"${root_dir}etc/gentoo-release")
					found_distros="$found_distros Gentoo"
					break;
					;;
				# if nothing previous matches, then use /etc/issue
				# AnMaster: Inform user that this might be very wrong...
				"${root_dir}etc/issue")
					found_distros="$found_distros misc"
					break;
					;;
			esac
		done
		# Remove leading spaces.
		found_distros="$(sed 's/^ *//' <<< "${found_distros}")"


		# Get distro name
		# NOTE: have been changed to case-insensitive, although
		# has not been thoroughly tested. the commented code
		# may be removed after verifying the new code works.
		case "$(echo ${found_distros} | tr 'A-Z' 'a-z')" in
			'suse'|'fedora core'|'fedora'|'red hat'|'slackware'|'slackware topologilinux'|'gentoo'|'ubuntu')
			#'SuSE'|'Fedora Core'|'Fedora'|'Red Hat'|'Slackware'|'Slackware Topologilinux'|'Gentoo'|'Ubuntu')

				distro_id="${found_distros}"

				# clear spaces
				#[ "$found_distros" = 'Slackware Topologilinux' ] && \
				#	found_distros='Topologilinux'
				#[ "$found_distros" = 'Red Hat' ] && found_distros='RedHat'
				#[ "$found_distros" = 'Fedora Core' ] && found_distros='Fedora'
				;;

			'topologilinux')
				print_error 1 "This module will abort." "$usekdialog" \
					"Topologilinux is based on Slackware and should" \
					"contain ${root_dir}etc/slackware-version AND " \
					"${root_dir}etc/Topologilinux-version."
				return 1
				;;

			'misc')
				for misc_distro in 'Ubuntu' 'Fedora' 'SuSE'; do
					if [ "$(grep -i ${misc_distro} ${distro_ident})" ]; then
						
						distro_id="${misc_distro}"
					fi
				done
				;;

			'')
				# Abort if no distro found
				print_error 1 "This module will abort." "$usekdialog" \
					"You have zero distros installed or use a distro " \
					"not recognised by ${appname}"
				return 1
				;;

			#*)
				# Abort if more than one distro
				#if [ "$usekdialog" == "1" ]; then
					#kdialog --error  "You have several distros installed at the \
					#same time.\nInstalled distros:\n${found_distros}\n\
					#This module will abort."
				#else
					#echo "${tcRED}ERROR:${tSTD} You have several distros \
						#installed at the same time."
					#echo "${tcRED}ERROR:${tSTD} ${tBOLD}Installed distros:${tSTD}\
						#${found_distros}"
					#echo "${tcRED}This module will abort.${tSTD}"
				#fi
				#return 1
			#;;
			esac


		# Output distro version
		case "${found_distros}" in
			'SuSE')
				distro_release="$(grep -F 'VERSION = ' ${root_dir}etc/SuSE-release          | sed 's/VERSION = //'    )" ;;
			'Red Hat')
				distro_release="$(cat ${root_dir}etc/redhat-release)" ;;
			'Fedora')
				distro_release="$(cat ${root_dir}etc/fedora-release)" ;;
			'Slackware')
				distro_release="$(grep -F 'Slackware ' ${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
			'Topologilinux')
				distro_release="$(grep -F 'Topologilinux ' ${root_dir}etc/Topologilinux-version | sed 's/Topologilinux //')"
				local  SlackwareBase="$(grep -F 'Slackware  '${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
			'Gentoo')
				distro_release="$(ls -ld /etc/make.profile --color=no | grep -Eo '[0-9]{4}\.[0-9]')";;
			'misc')
				# FIXME: AnMaster: . is a wildcard meaning any single char. Isn't grep -F what you want?
				distro_release="$(grep '.' "${root_dir}etc/issue" | grep -Eo '([A-Za-z0-9 ."])+' | head -n 1 )";;
				# TODO: improve the grep
		esac

	fi


	# then output what we found..
	
	[ "${distro_id}" ] && \
		add_attribute	'Distro ID'
		add_values		"${distro_id}"

	[ "${distro_release}" ] && \
		add_attribute	'Release'
		add_values		"$distro_release"

	[ "${distro_codename}" ] && \
		add_attribute	'Codename'
		add_values		"$distro_codename"

	[ "${distro_description}" ] && \
		add_attribute	'Description'
		add_values		"$distro_description"

	[ "$SlackwareBase" ] && \
		add_values	'Based on Slackware version' \
					"$SlackwareBase"


	module_footer
	flush_values
}

Module_applications() {
# APPLICATIONS

# version information of standard *nix, dev, and dependency packages.
# probably should take an additional switch like --X, --server, etc.

	moduleName="Applications"
	module_header "${moduleName}"

	local APPLICATIONS app
	## Applications to look for..
	if [ "$SYSTEM" == "linux" ] ; then

		APPLICATIONS="X kde-config x11vnc \
			bash csh ls \
			gcc make \
			awk sed grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			udevinfo lspci lshw dmidecode smartctl hdparm"

	elif [ "$(grep bsd <<< "$SYSTEM")" ]; then

		APPLICATIONS="X kde-config x11vnc \
			csh bash ksh \
			gcc grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			lspci lshw smartctl hdparm"

	fi

	## Write the header for output
	add_attribute $"Applications\n" 'software'

	local missing_ERRMSG="if you want to be able to use all modules of osinfo"
	## Process all applications
	for app in ${APPLICATIONS}; do

		if [ "$(type -p $app)" ]; then # it is installed
			case "$app" in
				'perl')
					add_values 	"Perl $($app --version 2>&1 | grep 'perl, v' | \
								grep -Eo 'v[ A-Za-z0-9.-]*')\n"
					;;
				'python')
					add_values	"$($app -V 2>&1 | head -n 1 )\n"
					;;
				'X')
					add_values	"$($app -version 2>&1 | grep Revision)\n"
					;;
				'kde-config')
					add_values	"$($app -version 2>&1 | grep KDE)\n"
					;;
				'gconftool')
					add_values	"$($app --version 2>&1 )\n"
					;;
				'apache2'|'apache')
					add_values	"$($app -V | head -n 1 | awk -F': ' {'print $2'})\n"
					;;
				'cups-config')
					add_values	"Cups $($app --version 2>&1 )\n"
					;;
				'smbd')
					add_values	"Samba $($app -V 2>&1 )\n"
					;;
				'udevinfo')
					add_values	"$($app -V 2>&1 )\n"
					;;
				'awk')
					add_values	"$($app -W version 2>&1 | head -n 1 )\n"
					;;
				'dmidecode')
					add_values	"dmidecode $(dmidecode -V)\n"
					;;
				*)
					add_values	"$($app --version 2>&1 | grep '\w' | head -n 1)\n"
					;;
										#grep  -P '[0-9]+\.[0-9]+' | sed 's/^tune2fs //')"
			esac
		else
			case "$app" in
				'lspci')
					add_values 'lspci'      "please install pciutils ${missing_ERRMSG}\n"
					;;
				'lshw')
					add_values 'lshw'       "please install lshw ${missing_ERRMSG}\n"
					;;
				'smartctl')
					add_values 'smartctl'   "please install smartmontools ${missing_ERRMSG}\n"
					;;
				'dmidecode')
					add_values 'demidecode' "please install dmidecode ${missing_ERRMSG}\n"
					;;
			esac
		fi
	done
	module_footer
	flush_values
}


Module_devices() {
# hardware devices of the system
#
# this function parses the physical devices in the computer from lspci.
# depends on pciutils.
#
# the output verbosity can be increased to include devices in the
# DO_NOT_OUTPUT string to include standard motherboard controllers
# which are suppressed in the normal level of verbosity.

	moduleName="Devices"
	module_header "${moduleName}"

	DEV_ARRAY=1;
	for DEVICE in $(lspci | awk {'$1="\b" ; print $0'} | tr ' ' '_' ); do

		devices[$DEV_ARRAY]="$(

			echo $DEVICE | sed -r 's/:_/:/g;s/(^_)//g' | tr ':' ' ' )"

			# with lspci 2.2 and later, the -m switch works fine
			#	for DEVICE in $(lspci -m | tr ' ' '_'); do
			#		devices_dbg[$DEV_ARRAY]="$(	echo $DEVICE | grep -Eo '"[^"]+"' | awk -F\" {'print $2'} )";

		((DEV_ARRAY++))
	done

	# the devices array now contains the ' ' separated entries from lsmod.
	# [1] device type		# [2] manufacturer		# [3] device name	etc
	# ${#devices[@]} # is the number of devices in the array

	# by default output all, but
	DO_NOT_OUTPUT="pci\|usb\|smb\|bridge\|ide"

	[[ "$isverbose" -eq 1 ]] && \
		DO_NOT_OUTPUT="smb\|bridge"


	for DEV_ARRAY in $(seq 1 ${#devices[@]}); do
		if [ ! "$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | \
			grep -i $DO_NOT_OUTPUT)" ]; then

			local description="$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | \
					tr '_' ' ' | sed 's/^.//;s/^ *//')"
			local device="$(echo ${devices[$DEV_ARRAY]} | \
					awk {'print $2" "$3'} | tr '_' ' ')"


			# make an exception for display and ethernet adapters
			# (lanforce) requires this
			# make sure that if several adapters are found, they don't
			# get individual attributes
			# AnMaster: Could you please tell me what you (ruxpin) mean with this? 
			#           As there is nothing about network in lspci...
			#           And Display adapter(s) seems broken.
			#               01:00.0 VGA compatible controller: ATI Technologies Inc RV280 [Radeon 9200 PRO] (rev 01)
			#               01:00.1 Display controller: ATI Technologies Inc RV280 [Radeon 9200 PRO] (Secondary) (rev 01)
			#           And there is only one in osinfo. In osinfo --xml there is one normal and one empty for it.
			#               <value>ATI Technologies Inc RV280 [Radeon 9200 PRO] (rev 01) </value>
			#               <value></value>
			#           Same in the lanforce output.


			if [ "$(grep -i 'network\|ethernet' <<< "$description")" ]; then

				local eth_adapter[${#eth_adapter}]="$device"

			elif [ "$(grep -i 'vga\|display' <<< "$description")" ]; then

				local video_adapter[${#video_adapter}]="$device"

			else
				add_attribute	"$description"
				add_values		"$device"
			fi

		fi

	done

	#finally report the eth and video adapters
	if [ "$eth_adapter" ]; then
		add_attribute	'Ethernet controller(s)'	"network_adapter"
		for i in $(seq 0 1 $((${#eth_adapter[@]}-1)) ); do
			add_values		"${eth_adapter[$i]}\n"
		done
	fi

	if [ "$video_adapter" ]; then
		add_attribute	'Display adapter(s)'		"display_adapter"
		for i in $(seq 0 1 $((${#video_adapter[@]}-1)) ); do
			add_values		"${video_adapter[$i]}\n"
		done
	fi

	#12:04 < LinuxNIT> is there a way to check and see how much ram my video card actually has available/is using? not just what i set in the xorg.conf
	#12:04 < Kevin`> lspci -vv
	#12:06 < LinuxNIT> IRegion 0: Memory at e8000000 (32-bit, prefetchable) [size=128M]

	module_footer
	flush_values
}

Module_env() {
# ENVIRONMENT VARIABLES
#
# xml only
# FIXME: Shouldn't be xml only...

	moduleName="Environment variables"
	module_header "${moduleName}"

	## Write the header for output
	add_attribute   $"System enviroment variables\n" \
	                'system_enviroment_variables'
	## Process all variables
	for var in $(env); do

		add_values	"${var}\n"

	done

	module_footer
	flush_values
}

