#!/bin/bash
#################################################################################
# OSINFO MODULES
#
# osinfo lists system information available to the OS.
#
# this file contains the osinfo modules and module subfunctions.
# modules can be freely added; the data processing and outputting is taken
# care of by other functions. these are accessed by the following functions,
# and here they are presented in the order in which they should appear in
# the modules.
#
# module_header	"Module name"
#  each module should begin with this line.
#  it will be printed in colour at stdout and as a tag to xml.
#  it may contain spaces; in the xml tag they will be replaced by '_'
#
# value_header	"Header"
#  the argument is printed on a single line in bold to stdout,
#  and as a <header> tag to the xml.
#  each module may contain several calls of this type
#
# add_attribute "Common Name"	"xml_code"
#  the first argument is printed at the first field to stdout,
#  and the xml output is formulated as:
#  <xml_code>
#   <value>foo</value>
#  </xml_code>
#  each module may contain several calls of this type.
#  the previous attribute tag is automatically closed when a new
#  one is introduced.
#
# add_values "value 1" "value 2" "value n"
#  several values can be given;
#  all of them will be separated with tab at stdout,
#  and they will each get their own <value>foo</value> line at xml output.
#  special characters as '\n' and '\t' can be used;
#  they will not affect the xml output.
#  each module may contain several calls of this type.
#
# value_footer
#  this call should follow a block of values, if the value_header
#  function is called before them. this closes open header tags.
#
# module_footer
#  this call should immediately precede the flush_values call.
#  this takes care of closing an open attribute tag.
#
# flush_values
#  prints the values to xml file or to stdout.
#  this should be the final command in a module.
#
#################################################################################
# Written by Mikael Lammentausta and Arvid Norlander
#
# Some parts are taken from:
#   --Advanced Bash Scripting Guide (ABS)
#################################################################################


## META-MODULES
#
# the order of modules inside this varibale here is important,
# because some global variables are collected by some modules and used by others.
#
# mod_system should come after mod_distro
MODULES_LINUX='distro system kernel processor network applications terminal devices hdd dmi cdrom memory users'
MODULES_BSD='distro system applications terminal network'
MODULES_LANFORCE='distro system processor network dmi devices users applications env'
MODULES_BROKEN='printers services users cdrom memory'
MODULES_REAL_ROOT_ONLY='system terminal applications network devices services hdd printers dmi'
MODULES_SU_ONLY='cdrom hdd dmi memory oem'
# MUST contain a list of all modules. This is used to find any invalid modules.
MODULES_ALL='applications cdrom devices distro dmi env hdd kernel memory network oem printers processor services system terminal users'


################################################################################
################################################################################
## General helper functions                                                   ##
################################################################################
################################################################################

##
# Checks for lshw and print a message if it doesn't exist
# Returns 0 if lshw eixsts and 1 if it is missing.
CheckReq_lshw() {
	if [ ! "$(type -p lshw)" ]; then
		add_attribute	"$appname notification"
		add_values		"Please install lshw to collect this information"
		return 1
	else
		return 0
	fi
}

##
# Checks for dmidecode and print a message if it doesn't exist
# Returns 0 if dmidecode eixsts and 1 if it is missing.
CheckReq_dmidecode() {
	if [ ! "$(type -p dmidecode)" ]; then
		add_attribute	"$appname notification"
		add_values		"Please install dmidecode to collect this information"
		return 1
	else
		return 0
	fi
}

##
# Checks if we are run as root and print a message if we are not.
# Returns 0 if we are root and 1 if we are not.
# TODO: Any reasons to base this on username and not $EUID?
CheckReq_root() {
	if [ "$EUID" != 0 ]; then
		add_attribute	"$appname notification"
		add_values		"Please run $appname as super-user to collect this information"
		return 1
	else
		return 0
	fi
}


##
# Checks if lshw was already run.
#  if it wasn't then run lshw and export the filename of the temporary file.
#  otherwise just return.
lshw_xml() {
	if [ -z "$lshw_xml_file" ]; then
		export lshw_xml_file="$(mktemp /tmp/osinfo.XXXXXX)"
		lshw -xml > "$lshw_xml_file"
	fi
}

TempFiles=()
##
# Cleans up some temporary files.
#  Currently this is only $lshw_xml_file
#
# ruxpin: shouldn't this be 'rm -f osinfo.??????' ?
# AnMaster: Um... We should store a list of temporary files we created in an array maybe?
cleanup_temp_files() {
	if [ "$lshw_xml_file" ]; then
		rm -f "$lshw_xml_file"
	fi
	local fil
	for fil in "${TempFiles[@]}"; do
		rm -f "$fil"
	done
}

################################################################################
################################################################################
## Modules                                                                    ##
################################################################################
################################################################################


#######################
# HARD DISK DRIVES
#
# this module collects data of the hard disk drives attached to the system.
# some information is unaccesible unless the partitions are mounted.
#
# S-ATA drives now display everything as nicely as IDE drives,
# due to support in recent smartmontools (version 5.36).
#
# used tools:
# fdisk, df, udev, /proc (deprecated), smartmontools, hdparm, bc
Module_hdd() {
	local moduleName="Disk information"
	module_header "${moduleName}"

	# developement status:
	# -------------------
	# IDE/PATA is tested
	# SATA is tested
	# USBhdd is tested
	# SCSI is untested, although works probably as SATA
	# RAID is untested
	# Logical Volume Management is untested

	# notes:
	# -----
	# FREEBSD: To check the status of drives, use the following:
	# ${PREFIX}/sbin/smartctl -a ad0          for first ATA drive
	# ${PREFIX}/sbin/smartctl -a da0          for first SCSI drive


	# this module depends heavily on root access, so prevent other users
	# of running this module
	if CheckReq_root; then
		# declare variables
		local totalsize=0 totalfree=0

		# detect all drives in the system
		local drives="$(fdisk -l | grep Disk | grep -Eo '\/(dev)\/\w'+)"

		# loop all detected drives
		for drvdev in $drives; do

			value_header	 ${drvdev}


			# $drvdev is the whole device address, eg "/dev/hda"
			# $drvnode is just the device node, eg "hda"
			# $drvnr is the drive number for this type; eg. for sdc $drvnr=3
			drvnode=$(echo $drvdev | awk -F/ {'print $NF'})
			drvnr=$(( $(echo -n ${drvnode: -1:1} | \
				tr 'a-z' 'A-Z' | od -A n -t u1) - 64));

			if [ "$(echo $drvdev | grep hd)" ]; then

				drive_type='IDE drive'
				scan_hdd_ide

			elif [ "$(echo $drvdev | grep sd)" ]; then

				scan_hdd_sg

			elif  [ "$(echo $drvdev | grep md)" ]; then

				scan_hdd_md		# software RAID devices

			else

				drive_type="Unknown drive type"

			fi



			#####################
			# scan the partitions
			scan_hdd_partitions



			###############################
			# scan common attributes
			scan_hdd_common



			###############################
			# calculate total disk capacity
			[[ $drive_capacity -lt 1048576 ]] && \
				#diskfr="$(($DISKFREE/1024)) MB"
				diskfr="$(echo $DISKFREE/1024 | bc -l)" && \
				diskfr="${diskfr:0:4} MB"
			[[ $drive_capacity -gt 1048576 ]] && \
				#diskfr="$(($DISKFREE/1024/1024)) GB"
				diskfr="$(echo $DISKFREE/1024/1024 | bc -l)" && \
				diskfr="${diskfr:0:4} GB"

			#diskpercfree="$(($DISKFREE*1024*100/$drive_capacity))" # rounds off improperly
			diskpercfree="$(echo $DISKFREE*1024*100/$drive_capacity | bc -l)"
			diskpercfree="${diskpercfree:0:4}"



			add_attribute	'Free (mounted)'
			add_values		"${diskfr} ; ${diskpercfree}%"

			totalsize=$(($totalsize+$drive_capacity))
			totalfree=$(($totalfree+$DISKFREE))



			##################
			# clear varibles
			unset drive_capacity_real DISKFREE



			######################################
			# calculate total system disk capacity
			# report data of the whole system

			totalpercfree=0

			#add_attribute	"Total disk space"
			#add_values		"Capacity: $(echo $totalsize)"
			#add_values		"Free: $(echo -e $totalfree ; $totalpercfree %)"


			############
			# OUTPUT
			if [ $usexml -eq 0 ]; then
				add_attribute	"$drive_type"
					add_values	"$drive_vendor $drive_model"
				add_attribute	'Serial number'
					add_values	"$drive_serial"
				add_attribute	'Driver'
					add_values	"$drive_driver"
				add_attribute	'DMA'
					add_values	"$drive_dma"
				add_attribute	'Geometry'
					add_values	"$drive_geometry"
				add_attribute	'Capacity (reported)'
					add_values	"$drive_capacity_label"
				add_attribute	'Capacity (actual)'
					add_values	"$drive_capacity_real"

				add_attribute	'S.M.A.R.T.'
					add_values	"$drive_smart"
				add_attribute	'Lifetime'
					add_values	"$drive_lifetime"
				add_attribute	'Temperature (C)'
					add_values	"$drive_tempC"
				add_attribute	'Health Status'
					add_values	"$drive_health"

			else # formulate this a bit different for xml output
				add_attribute	"$drive_type"	'hard_disk'
				add_values		"$drive_type $vendor $model ($serial) \
									$drive_capacity_label"

			fi

		done

	fi

	# finalize
	module_footer
	flush_values
}


###### BEGIN HDD SUBFUNCTIONS #############
#
# these functions are called from mod_hdd and they generate no output,
# all data is stored into global variables:
#
# TODO: update all variable to reflect:
# drive_type, drive_vendor, drive_model, drive_serial, drive_driver, drive_dma
# drive_geometry, drive_capacity_label, drive_capacity_real

	#################################################
	# SCAN COMMON ATTRIBUTES OF ALL HARD DRIVE TYPES
	#
	# drive geometry and capacity
	scan_hdd_common() {

		drive_geometry="$(fdisk -l | grep /dev/sda -A 1 | sed -n "2{p;q}")"

		drive_capacity_label="$(fdisk -l ${drvdev} | grep ${drvdev} | \
			head -n 1 | grep -Eo '[1-9][0-9]+[\.0-9]* \w{2}' | head -n 1)"

		# fdisk gives drive capacity in mega|gigabytes and bytes.

		# this solution is really quirky, since fdisk outputs two numbers,
		# and the last grep here picks the one with FIVE or more
		# numbers, so this might be a problem in some situations,
		# but since the less precise value (first) is rounded, it never
		# should be more than four numbers, like '1032 MB'
		drive_capacity="$(fdisk -l $drvdev | \
			head -n 2 | grep -Eo '[0-9]{5,}')"


		# show precision if 1 decimal number (scale=1 to bc)
		# and round to proper unit
		if [ $drive_capacity -lt 1073741824 ]; then
			drive_capacity_real="$(bc -l <<< scale=1\;" \
				"$drive_capacity/1024/1024 ) MB"
		else
			drive_capacity_real="$(bc -l <<< scale=1\;" \
				"$drive_capacity/1024/1024/1024 ) GB"
		fi

	}

	#########################
	# S.M.A.R.T. scanning
	#
	# smartmontools are handy in getting the extended parameters
	# of hard drives. only version 5.36 and onward support SATA drives
	# and the version may be a bit uncommon, as it was released in April 2006.
	# all major distros should begin to include it in their packages,
	# so this should be relatively common in late 2006.
	# for ide drives this is not a problem.
	#
	# this function takes one parameter, the driver to use. default is ata.
	scan_hdd_smart() {

		local dev_type smart_info version
		if [ "$1" ]; then
			dev_type="$1"
		else
			dev_type=ata
		fi

		# allocate a temp file
		smart_info="$(mktemp /tmp/osinfo.XXXXXX)"
		TempFiles=("${TempFiles[@]}" "$smart_info")

		### check the smartctl version >5.36
		version="$(smartctl --version | grep -Eo 'version [0-9.]+' | \
			grep -Eo '[0-9]\.[0-9]+')";
		if [ ! "$smart" ]; then
			diff="$(bc -s <<< $version-5.36 )"
			if [ ! "${diff:0:1}" = "-" ]; then # this is a newer version
				smart="sata-ok"
			else
				smart=$version
			fi
		fi

		smartctl -a -d $dev_type ${drvdev} > $smart_info

		drive_smart="$(grep 'SMART support' ${smart_info} | \
						head -n 1 | awk -F': ' {'print $2'})"

		drive=lifetime="$(grep -i power_on $smart_info | awk {'print $NF'})"

		drive_tempC="$(grep -i temperature_celsius $smart_info | \
						awk '{for (i=10; i<=NF; i++) printf("%s ",$i);printf ("\n")}')"

		drive_health="$( grep -Ei '(health)+' $smart_info | awk {'print $NF'})"

	}


	####################
	# PARTITIONS
	#
	# NOTE: under construction. output is disabled.
	#
	# function extracts information of hard drive partitions.
	#
	# TODO: an array that stores data of how much is allocated for each FS
	# [partition ID=83] [size on hda1] [size on hda4]
	# [partition ID=7] [size on hda2] [size on hdb1]
	scan_hdd_partitions() {
		DISKFREE=0
		partitions_on_drive="$(fdisk -l $drvdev | grep ^$drvdev | wc -l)"

		#value_header		"  Partition\t\tcapacity\tfree\tmountpoint\tfilesystem"


		# loop all partitions detected by fdisk

		for PARTNR in $(seq 1 1 $partitions_on_drive); do
			partition="$(fdisk -l $drvdev | grep ^$drvdev | awk {'print $1'} | \
				sed -n "${PARTNR}{p;q;}" )"

			#add_attribute	"  ${partition}"


			# CAPACITY; if partition is mounted (=is in mtab)
			#
			# BUG: submounted (=system for automounting usb sticks) partitions
			# are considered unmounted, while they are not!

			if [ "$(df -Plk | grep $partition)" ]; then

				# the partition size is calculated from the value given by df,
				# and the float division is computed by bc.
				# the output of bc is then concatenated by parameter expansion.

				# df reports in kb
				# small partitions are reported in MB, larger in GB
				partsize="$(df -Plk | grep $partition | awk {'print $2'})"
				partfree="$(df -Plk | grep $partition | awk {'print $4'})"

				[[ $partsize -lt 1048576 ]] && \
					pz="$(echo $partsize/1024 | bc -l)" && \
					pz="${pz:0:4} MB"
				[[ $partsize -gt 1048576 ]] && \
					pz="$(echo $partsize/1024/1024 | bc -l)" && \
					pz="${pz:0:4} GB"

				#partpercfree="$(($partfree*100/$partsize))" # rounds off improperly
				partpercfree="$(echo $partfree*100/$partsize | bc -l)"
				partpercfree="${partpercfree:0:4}"

				DISKFREE=$(($DISKFREE+$partfree))


				# capacity
				#add_values		"$pz\t"

				# free space
				#add_values		"$partpercfree%"

				# mountpoint
				local mp="$(df -PT $partition | grep ^$partition | \
							awk {'print $NF'})"
				# check the number of tabs to add for stdout indent
				if [ ${#mp} -lt 8 ]; then
					mp="${mp}\t"
				fi
				#add_values		"${mp}"

			else	# detect capacity of an unmounted partition

				# capacity
				#add_values		"-\t"

				# free space
				add_values		"-"

				# mountpoint
				#add_values		"unmounted"

			fi

			# filesystem
			# because fdisk adds a '*' character for bootable partitions, awk gets
			# messed up. that is why numbers are removed from the beginning of string.
			#add_values		"$(fdisk -l | grep ^${partition} | \
			#				awk '{for (i=6; i<=NF; i++) printf("%s ",$i);printf ("\n")}' | \
			#				sed 's/^[0-9 ]*//')"
							#(read Disk foo bar foobar something partition; echo "$partition"))"

		done
	}


	#################
	# IDE drives
	#
	# this function collects information of IDE drives in the system
	#
	# udevinfo, /proc/ide/, smartmontools and hdparm are used as the data source.
	scan_hdd_ide() {

		# detect the available data sources
		if [ "$(type -p udevinfo)" ]; then
			# allocate a temp file
			local udev_info="$(mktemp /tmp/osinfo.XXXXXX)"
			TempFiles=("${TempFiles[@]}" "$udev_info")
			udevinfo -q all -n ${drvdev} > $udev_info
		fi
		if [ -e "/proc/ide/" ]; then
			local proc_info="/proc/ide/${drvnode}"
		fi
		# hdparm output is not read into a temp file, as
		# it is unlikely to be used, and that would unnecessarily
		# slow down this function.


		########
		# Vendor
		if [ "$(type -p smartctl)" ]; then

			# because smartctl uses its own database to report the HDD vendor,
			# it is preferred over udev.
			#
			# this smart scan is not included into the scan_hdd_smart()
			# because it would break the correct order of the report.
			drive_vendor="$(smartctl -i ${drvdev} | grep '^Model' | \
							awk -F: {'print $2'} | sed 's/^ *//')"

		elif [ "${udev_info}" ]; then
			drive_vendor="$(udevinfo -q all -n ${drvdev} | grep -i vendor | \
							awk -F_ {'print $NF'})"
		fi

		# check whether we got anything else than empty $vendor string
		if [  "$(grep  '^\ *' <<< $vendor )" ]; then
			drive_vendor="Unknown vendor"
		fi


		#######
		# Model
		if  [ "${udev_info}" ]; then
			drive_model="$(udevinfo -q all -n ${drvdev} | grep -i model | \
							awk -F= {'print $NF'})"

		elif [ -e "${proc_info}" ]; then
			drive_model="$(cat ${proc_info}/model)"

		elif [ "$(type -p hdparm)" ]; then
			drive_model="$(hdparm -i ${drvdev} | grep -Eio 'Model=\w+' | \
							awk -F= {'print $2'})"

		fi


		###############
		# Serial number
		if  [ "${udev_info}" ]; then
			drive_serial="$(grep SERIAL ${udev_info} | awk -F= {'print $NF'})"

		elif [ "$(type -p hdparm)" ]; then
			drive_serial="$(hdparm -i ${drvdev} | grep -Eio 'serialno=\w+' | \
						 awk -F= {'print $2'})"
		fi


		########
		# Driver
		if [ -e "/proc/ide/$drvnode" ]; then
			drive_driver="$(cat ${proc_info}/driver)"
		fi


		############
		# DMA STATUS
		if [ "$(type -p hdparm)" ]; then
			drive_dma="$(hdparm ${drvdev} | grep dma | grep -Eo '\([onf]+\)')"
		fi


		############
		# SMART info
		if [ "$(type -p smartctl)" ]; then
			scan_hdd_smart ata
		fi

	}


	#################
	# SATA/SCSI/USB drives (sg driver)
	#
	# this function collects information of SATA/SCSI/USB drives,
	# because under Linux they all use the same SCSI drivers.
	#
	# the information in stored into two or three locations, depending
	# on the kernel and whether the system uses devfs or udev.
	# since devfs is deprecated, it is not used at all.
	# the /proc/scsi/ system is deprecated from 2.6 on, but it is left
	# here for legacy support.
	#
	# usb drives, when properly detected by the Linux kernel,
	# are added to /proc/scsi/scsi info sheet, and the assigned scsi number
	# which can be found both in the beforementioned location and also
	# in /proc/scsi/sg/devices, can be used to identify the device
	# in /proc/scsi/usb-storage/*.
	#
	# as the devices are (hopefully) linearily, the devices catalogue
	# can be used to identify which /dev/sd* node is a certain scsi#.
	#
	# this is not true in the case of custom udev rules. although
	# a good practise is to let kernel do its magic and create a
	# link node to that device, so this is unlikely to be a problem.
	#
	# smartmontools support SATA drives from version 5.36 on
	# (released April 2006). this function is written in June 2006,
	# and for that the version of smartctl is checked before trying
	# to access SATA drives.
	scan_hdd_sg() {
		# detect the available data sources
		if [ "$(type -p udevinfo)" ]; then
			# allocate a temp file
			local udev_info="$(mktemp /tmp/osinfo.XXXXXX)"
			TempFiles=("${TempFiles[@]}" "$udev_info")
			udevinfo -q all -n ${drvdev} > ${udev_info}
		fi
		if [ -e "/proc/scsi/" ]; then
			local proc_info="/proc/scsi/scsi"
			local scsi_devices="/proc/scsi/sg/devices"
			local scsi_devstrings="/proc/scsi/sg/device_strs"
			local usb_devstrings="/proc/scsi/usb-storage/"
			local sg_version="/proc/scsi/sg/version"

			local scsi_nr="$(sed -n "$drvnr{p;q;}" ${scsi_devices} | awk {'print $1'})"
		fi
		# hdparm output is not read into a temp file, as
		# it is unlikely to be used, and that would unnecessarily
		# slow down this function.


		if [ "${udev_info}" ]; then

			local bus="$(grep -i ID_BUS ${udev_info} | awk -F= {'print $NF'})"
			if [ "$(echo $bus | grep usb)" ]; then
				# USB drive detected

				drive_type='USB drive'

			fi

			# test if the scsi_nr is found in /proc/scsi/usb-storage/
		elif [ -e "${proc_info}" ]; then

			if [ -e "${usb_devstrings}${scsi_nr}" ]; then
				local usb_info="${usb_devstrings}/${scsi_nr}"
				drive_type='USB drive'
			fi

		else
		# SATA/SCSI drive

			drive_type='SATA/SCSI drive'

		fi


		########
		# Vendor
		if [ "$smart" = "sata-ok" ]; then

			# because smartctl uses its own database to report the HDD vendor,
			# it is preferred over udev.
			#
			# this smart scan is not included into the scan_hdd_smart()
			# because it would break the correct order of the report.

			drive_vendor="$(smartctl -i -d ata ${drvdev} | grep '^Model' | \
							awk -F: {'print $2'} | sed 's/^ *//') "

		elif [ "${udev_info}" ]; then

			drive_vendor="$(grep -i vendor ${udev_info}  | \
							awk -F= {'print $NF'}) "

		elif [ -e "${proc_info}" ]; then

			drive_vendor="$(sed -n "$drvnr{p;q;}" "${scsi_devstrings}" | \
							awk {'print $1'}) "
							#"$(grep -i vendor ${usb_info} | awk -F': ' {'print $2'})"
		fi


		#######
		# Model
		if  [ "${udev_info}" ]; then

			drive_model="$(grep -i model ${udev_info} | \
							awk -F= {'print $NF'})"

		elif [ -e "${proc_info}" ]; then

			drive_model="$(sed -n "$drvnr{p;q;}" "${scsi_devstrings}" | \
							awk {'print $2" "$3'})"

		elif [ "$(type -p hdparm)" ]; then

			drive_model="$(hdparm -i ${drvdev} | grep -Eio 'Model=\w+' | \
							awk -F= {'print $2'})"
		fi


		# report both vendor and model on one line
		add_attribute	"$drive_type"		'hard_disk'
		add_values		"$vendor$model"


		###############
		# Serial number
		if  [ "${udev_info}" ]; then

			drive_serial="$(grep SERIAL ${udev_info} | awk -F= {'print $NF'})"

		elif [ "$(type -p hdparm)" ]; then

			drive_serial="$(hdparm -i ${drvdev} | grep -Eio 'serialno=\w+' | \
							awk -F= {'print $2'})"
		fi


		########
		# Driver
		if [ -e "${proc_info}" ]; then
			drive_driver="Linux SCSI Generic (sg) v.$(cat ${sg_version})"
		fi


		#TODO: dma status


		if [ "$smart" = "sata-ok" ]; then
			scan_hdd_smart ata
		fi

	}


	#######################
	# SOFTWARE RAID ARRAYS
	scan_hdd_md() {
		value_header	"todo"

	}

###### END OF HDD SUBFUNCTIONS #############


#######################
# MEMORY
#
# this module tells complete information of the memory
# installed on the system.
#
# only RAM at the moment and the solution is really dirty because
# it uses lshw. 'free' and '/proc/meminfo' would also report
# free RAM, but slightly incorrect number because it's the total
# ram after kernel has allocated some for system services.
#
#
# requires root access
Module_memory() {
	moduleName="System memory"
	module_header "${moduleName}"

	if CheckReq_lshw && CheckReq_root; then


		# TODO: add support for memory type/speed detection thru lshw
		lshw_xml

		# for some odd reason meminfo or free don't give a proper value

		meminfo="/proc/meminfo"

		#totalram="$(cat ${meminfo} | grep -i memtotal | grep -Eo [0-9]+)"
		totalram="$(grep 'id="memory' -A 20 ${lshw_xml_file} | grep size | \
			grep -Eo '[0-9]+')"

		totalram="$(echo "$totalram/1024/1024" | bc -l | grep -Eo '[0-9]+\.[0-9]{1}')"

		add_attribute	'RAM total'	'ram'
		add_values		"$totalram MB"

	fi

	module_footer
	flush_values

}


# INFORMATION OF CD/DVD DEVICES
Module_cdrom() {


	moduleName="CD/DVD drives"
	module_header "${moduleName}"

	if CheckReq_lshw && CheckReq_root; then
		lshw_xml
		cdrom_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		TempFiles=("${TempFiles[@]}" "$cdrom_tmp")

		# this gets the line number of the wanted node from lshw '$this'
		# and the line number of the next node '$next'
		# then what's between those lines is printed to another tmp file
		this="$(grep -n "node id=\"cdrom" $lshw_xml_file | \
			awk -F: {'print $1'})"
		next="$(grep -n 'node id' $lshw_xml_file | grep -A 1 cdrom | \
			awk -F: {'print $1'} | sed -n "2{p;q}")"
		((this++)) # this prevents the 'node' lines from printing
		((next--))

		# use a temp file to store cdrom information
		sed -n "$this,$next{p;}" ${lshw_xml_file} > ${cdrom_tmp}

		#cat $cdrom_tmp
		#exit 0


		add_attribute	'Model'	'cdrom'
		add_values		"$(grep -i product ${cdrom_tmp} | \
						sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		add_attribute	'Drive type'
		add_values		"$(grep -i description ${cdrom_tmp} | \
						sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		add_attribute	'Device node'
		add_values		"$(grep -i 'logicalname' ${cdrom_tmp} | \
						sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		add_attribute	'Serial number'
		add_values		"$(grep -i serial ${cdrom_tmp} | \
						sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		#add_attribute	'Capabilities'
		#add_values		"$(grep -i capabilities ${cdrom_tmp} | \
		#				sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"


		#value_footer


	fi

	module_footer
	flush_values

}


#######################
# DMI / OEM INFORMATION
#
# this module works as a replacement for module_oem. this is faster,
# as it doesn't scan hardware. look below for excerpt from 'man dmidecode':
#
# dmidecode  is  a  tool  for dumping a computer's DMI (some say SMBIOS) table
# contents in a human-readable format.
# This table contains a description of the system's hardware components,
# as well as other useful pieces of information  such  as  serial
# numbers and BIOS revision. Thanks to this table, you can retrieve this
# information without having to probe for the actual hardware.  While this
# is a good point in terms of report speed and safeness,  this also makes
# the presented information possibly unreliable.
Module_dmi() {
	moduleName="DMI information"
	module_header "${moduleName}"

	if CheckReq_dmidecode && CheckReq_root; then
		# allocate the temp files
		dmi_info="$(mktemp /tmp/osinfo.XXXXXX)"
		dmi_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		dmidecode > $dmi_info
		TempFiles=("${TempFiles[@]}" "$dmi_info" "$dmi_tmp")

		# the interesting handles:
		# 0x0000 'BIOS Information'
		# 0x0001 'System Information'
		# 0x0002 'Base Board Information'
		# 0x0003 'Chassis Information'

		local HANDLES="0x0000 0x0001 0x0002 0x0003"

		# following loop extracts the data under the nodes variable.

		# (1) get the line number where the 'node id=$HANDLES'
		# (2) get the line number of the next 'node id'
		# (3) everything in between those lines contains interesting data

		for myHANDLE in $HANDLES; do

			this="$(grep -n "Handle ${myHANDLE}" ${dmi_info} | \
				awk -F: {'print $1'})"
			next="$(grep -n Handle ${dmi_info} | grep -A 1 ${myHANDLE} | \
				awk -F: {'print $1'} | sed -n "2{p;q}")"
			((this++)) # this prevents the 'handle' lines from printing
			((next--))

			# use a temp file to store handle information
			sed -n "$this,$next{p;}" ${dmi_info} > ${dmi_tmp}


			# here the data is processed
			case $myHANDLE in

				"0x0001")	# System Information

					value_header	"System info"


					add_attribute	'Manufacturer' \
									'system_manufacturer'
					add_values		"$(grep -i manufacturer ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Product name'	'system_model'
					add_values		"$(grep -i product ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'System version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'OEM serial number' \
									'computer_product_serial'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'UUID' 	'uuid'
					add_values		"$(grep -i uuid ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;

				"0x0002")	# Base Board Information

					value_header	"Motherboard"


					add_attribute	'Manufacturer' \
									'mother_board_manufacturer'
					add_values		"$(grep -i manufacturer ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Model' \
									'mother_board_model'
					add_values		"$(grep -i product ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Version' \
									'mother_board_version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Serial number' \
									'mother_board_serial_number'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;

				"0x0000")	# BIOS Information

					value_header	"BIOS"

					add_attribute	'Vendor'
					add_values		"$(grep -i vendor ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Revision'	'bios_version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Date'	'bios_date'
					add_values		"$(grep -i date ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Serial number'	'bios_serial_number'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;


				"0x0003")	# Chassis Information

					value_header	'Chassis'

					add_attribute	'Manufacturer' 	'chassis_manufacturer'
					add_values		"$(grep -i manufacturer ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Type' 	'chassis_type'
					add_values		"$(grep -i type ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Version' 	'chassis_version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Serial number' \
									'chassis_serial_number'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Lock' 	'chassis_lock'
					add_values		"$(grep -i lock ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Asset tag' 'chassis_asset_tag'
					add_values		"$(grep -i asset ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;

			esac

		done

	fi

	# cleanup
	rm -f $dmi_info $dmi_tmp

	module_footer
	flush_values

}


#######################
# OEM INFORMATION (rewrite)
# this module is deprecated in favor of module_dmi
#
# this module collects information from lshw, a somewhat rare package, which
# tells a lot of interesting information of the system hardware.  it also seems
# to be the only way to get the serial number of a branded computer, thus 'oem
# info'. below is an excerpt from 'man lshw'
#
# lshw  is a small tool to extract detailed information on the hardware
# configuration of the machine. It can report exact memory configuration,
# firmware version, mainboard configuration, CPU version and  speed,  cache
# configuration,  bus  speed, etc. on DMI-capable x86 or IA-64 systems and on
# some PowerPC machines (PowerMac G4 is known to work).  It currently supports
# DMI (x86 and IA-64 only), OpenFirmware device tree (PowerPC only),  PCI/AGP,
# CPUID  (x86),IDE/ATA/ATAPI, PCMCIA (only tested on x86), SCSI and USB.
Module_oem() {


	local moduleName="OEM information"
	module_header "${moduleName}"


	if CheckReq_lshw && CheckReq_root; then
		lshw_xml

		# the interesting entries:
		# $hostname
		# core
		# firmware

		local NODES="$(hostname) core firmware"

		# following loop extracts the data under the nodes variable.

		# (1) get the line number where the 'node id=$NODES'
		# (2) get the line number of the next 'node id'
		# (3) everything in between those lines contains interesting data

		for myNODE in $NODES; do

			this="$(grep -n "node id=\""${myNODE}"\"" $lshw_xml_file | \
				awk -F: {'print $1'})"
			next="$(grep -n 'node id' $lshw_xml_file | grep -A 1 ${myNODE} | \
				awk -F: {'print $1'} | sed -n "2{p;q}")"
			((this++)) # this prevents the 'node' lines from printing
			((next--))

			local IFSbk="$IFS"
			IFS="
"; # a literal newline, do not indent!

			for info in $(sed -n "$this,$next{p;}" $lshw_xml_file); do

				# the data is avaiable here, printed line by line.
				# usually the fields are:

				# <description>
				# <product>
				# <vendor>
				# <version>
				# <serial>

				# then there special fields. see 'lshw -xml'

				# parse standard <foo> tags
				# TODO: add support for capabilities tags
				local tag="$(grep -o '<[a-z]*>' <<< ${info} | \
							sed 's/<\([^>]*\)>/\1/')"
							# matched everything between '<' and '>'

				[ "$tag" ] && \
				local value="$(grep ${tag} <<< ${info} | \
							awk -F'<|>' {'print $3'})"

				# here the data is processed
				case $myNODE in

					"$(hostname)")	# OEM info

						if [ "$printed" != "oem" ]; then
							value_header	"OEM info"
							local printed="oem"
						fi

						case $tag in

							'description')

								add_attribute 'System model' \
								              'system_model'
								add_values    "$value"
								;;

							'vendor')

								add_attribute 'System manufacturer' \
								              'system_manufacturer'
								add_values    "$value"
								;;

							'product')

								add_attribute	'System name'
								add_values		"$value"
								;;

							'version')

								add_attribute	'System version'
								add_values		"$value"
								;;

							'serial')

								add_attribute 'OEM serial number' \
								              'computer_product_serial'
								add_values    "$value"
								;;

							#*)

								#add_attribute	"$tag"
								#add_values		"$value"
								#;;

						esac

						value_footer
						;;

					'core')			# mobo info

						if [ "$printed" != "mobo" ]; then
							value_header	"Motherboard"
							local printed="mobo"
						fi

						case $tag in

							'vendor')

								add_attribute 'Make'
								add_values    "$value"
								;;

							'product')

								add_attribute 'Model'
								add_values    "$value"
								;;

							'version')

								add_attribute 'Revision'
								add_values    "$value"
								;;

							'serial')
								add_attribute 'Serial number' \
								              'mother_board_serial_number'
								add_values    "$value"
								;;

						esac

						value_footer
						;;

					'firmware')		# BIOS info

						if [ "$printed" != "bios" ]; then
							value_header	"BIOS"
							local printed="bios"
						fi

						case $tag in

							'vendor')

								add_attribute	'Vendor'
								add_values		"$value"
								;;

							'version')

								add_attribute	'Revision'	'bios_version'
								add_values		"$value"

								# trying to extract date from version
								add_attribute	'Date'	'bios_date'
								add_values		"$(echo $value | \
									grep -Eo '([0-9]{2,4}[-./][0-9]{2}[-./][0-9]{2,4})+')"
								;;

							'date')

								add_attribute	'Date'	'bios_date'
								add_values		"$value"

								;;

							'serial')
								add_attribute 'Serial number' \
								              'bios_serial_number'
								add_values    "$value"
								;;

						esac

						#value_footer
						# this produces an eternal loop
						;;

				esac

			done

			IFS="$IFSbk"

		done
	fi

	module_footer
	flush_values

}

Module_oem_old() {
# OEM INFORMATION
# deprecated, as this module has been rewritten. left here for reference.
#AnMaster: why? you can just look at an older revision in svn. If this is not used anywhere it should be deleted before a release.

	moduleName="OEM information"
	module_header "${moduleName}"
	error_deprecated Module_oem_old osinfo.modules

	if CheckReq_lshw && CheckReq_root; then

		lshw_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		TempFiles=("${TempFiles[@]}" "$lshw_tmp")
		lshw > $lshw_tmp

		# principle:
		# (1) output of lshw is stripped out of newlines, switched spaces with _ and
		#     added %newline% to denote a value pair
		# (2) this is put into hardware array, because bash doesn't support
		#     two-dimensional arrays
		# (3) a for loop then checks each array element for OUTPUT type node ID.
		# (4) another loop checks for DO_NOT_OUTPUT ; if this is satisfied,
		#     values are sent with add_values()


		# the verbosity of this module can be controlled by modifying the
		# OUTPUT and DO_NOT_OUTPUT strings. the example below should be clear.

		OUTPUT="$(hostname)\|cpu\|core\|firmware\|memory\|cdrom\|disk"
		DO_NOT_OUTPUT="description\|capabilities\|configuration\|resources\|physical\|bus"

		[[ "$isverbose" -eq 1 ]] &&
		OUTPUT=$OUTPUT"\|ide\|pci\|usb"


		# this loop fills the $hardware[] array with entries from lshw.
		#
		# 1) the leading spaces are removed
		# 2) whitespaces are converted to underscores
		# 3) newlines are replaced by '%newline%'
		# 4) the '*' character is the node identifier in lshw.
		#
		# the product of this is an array, where an item contains
		# all information of the node parsed to a single string.
		for node in $(seq 0 1 $(

				grep '\*' ${lshw_xml_file} | wc -l

				#cat ${lshw_xml_file} | sed 's/^ *//' | tr ' ' '_' | \
				#sed ':a;N;$!ba;s/\n/%node%/g' | awk -F"*" {'print NF'}

				));	do

		 #hardware_debug[$HW]="foo"
		 #echo $HW
		 #echo ${#hardware[@]}
		 oem_str[$node]="$(

			sed 's/^ *//g' ${lshw_xml_file} | tr ' ' '_' | \
			sed ':a;N;$!ba;s/\n/%newline%/g' | awk -F"*" {'print $('$node'+1) '}

		)"

		done

	# then fix the first node so that the hostname isn't printed
		oem_str[0]="-${oem_str[0]}"


		# parse the string in a loop
		for node in $(seq 0 1 ${#oem_str[@]}); do

		# if the oem_string contains an interesting node...
			if [ "$(echo ${oem_str[$node]} | awk -F'%newline%' {'print $1'} | \
			grep -i $OUTPUT)" ]; then # we want output

			myELEMENT=1;

			# then parse all elements in the array
			while [ "$(echo ${oem_str[$node]} | \
				awk -F'%newline%' {'print NF'})" -gt "$myELEMENT" ]; do


			 # if the node doesn't contain info we don't want..
				if [ ! "$(echo ${oem_str[$node]} | \
					awk -F'%newline%' {'print $'$myELEMENT' '} | \
					grep -i $DO_NOT_OUTPUT)" ]; then

					# the oem_string is extracted into a variable
					oem_node="$(echo ${oem_str[$node]} | \
						awk -F'%newline%' {'print $'$myELEMENT' '})"

					# then prune out the *-foo nodes
					# and send the data to add_values()
					if [ ! "$(echo ${oem_node} | grep '^-')" ]; then

						add_attribute	"  $(echo ${oem_node} | \
							awk -F":_" {'print $1'} | tr '_' ' ')"

						add_values		"  $(echo ${oem_node} | \
							awk -F":_" {'print $2'} | tr '_' ' ')"

					fi

					# 'description' values are printed as headers
				elif [ "$(echo ${oem_str[$node]} | \
					awk -F'%newline%' {'print $'$myELEMENT' '} | \
					grep -i 'description')" ]; then

					value_header	"$(echo ${oem_str[$node]} | \
						awk -F'%newline%' {'print $'$myELEMENT' '} | \
						awk -F":_" {'print $2'} | tr '_' ' ')"

				fi

				((myELEMENT++));
			done
			fi
		done


	fi

	module_footer
	flush_values
}


# GENERAL INFORMATION OF THE SYSTEM
Module_system() {

	moduleName="System"
	module_header "${moduleName}"

	add_attribute "Operating system"			"os"
	add_values    "$distro_id $(uname -s) $distro_release"

	add_attribute "Operating system kernel"	"os_build"
	add_values    "$(uname -sr)"

	add_attribute "Network node hostname"	"host_name"
	add_values    "$(hostname)"

	add_attribute "Machine hardware name"	"system_type"
	add_values    "$(uname -m)"

	add_attribute "System locale"
	add_values    "$(echo $LC_ALL)"

	add_attribute "System uptime"			"uptime"
	add_values    "$(uptime | awk -F, {'print $1'} | \
	                 grep -Eo 'up [a-z0-9: ]*' | sed 's/^[up ]*//')"

	module_footer
	flush_values
}


# OPERATING SYSTEM KERNEL
Module_kernel() {

	moduleName="Kernel"
	module_header "${moduleName}"

	local kernel_makefile

	add_attribute "Operating system"
	add_values    "$(uname -o)"

	add_attribute "Kernel release"
	add_values    "$(uname -r)"

	# Unique kernel name
	if [ -e "/usr/src/linux" ]; then
		kernel_makefile="/usr/src/linux/Makefile"
	elif [ "$(ls /usr/src/linux*)" ]; then
		kernel_makefile="/usr/src/linux*/Makefile"
	fi
	if [ -e "${kernel_makefile}" ]; then
		add_attribute "Kernel name"
		add_values    "$(head ${kernel_makefile} | grep NAME | \
						head -n 1 | awk -F= {'print $2'})"
	fi

	module_footer
	flush_values
}


# INFORMATION OF THE CPU
Module_processor() {

	moduleName="Processor"
	module_header "${moduleName}"

	local cpunr

	# AnMaster: Why this line? Would it ever be anything else?
	local cpuinfo="/proc/cpuinfo"
	local cpu_count="$(grep 'cpu cores' ${cpuinfo} | head -n 1 | awk {'print $NF'})"

	# test if /proc/cpuinfo gives a number for cpu cores.
	# if it is does not, the kernel probebly lacks SMP support so assume 1 cpu.
	if [ ! "$cpu_count" ]; then
		cpu_count=1
	fi

	add_attribute	"Count"			"processor_count"
	add_values		$cpu_count

	for cpunr in $(seq 1 1 $cpu_count); do

		if [ $cpu_count -gt 1 ]; then
			value_header	"Processor $cpunr"
		fi

		add_attribute	"Vendor"		"processor_vendor"
		add_values		"$(grep 'vendor' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2'})"

		add_attribute	"Model"			"processor_model"
		add_values		"$(grep 'model name' ${cpuinfo} | \
						sed -n "$cpunr{p;q}" | awk -F': ' {'print $2'})"

		add_attribute	"Frequency"		"processor_speed"
		add_values		"$(grep 'cpu MHz' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2" MHz"'})"

		add_attribute	"Cache"
		add_values		"$(grep 'cache' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2'})"

		add_attribute	"Stepping"
		add_values		"$(grep 'stepping' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2'})"


	done

	module_footer
	flush_values
}


# INFORMATION OF THE TERMINAL IN USE
Module_terminal() {

	moduleName="Terminal info"
	module_header "${moduleName}"

	add_attribute	"Terminal type"
	add_values		"$TERM"

	add_attribute	"Terminal speed"
	add_values		"$(stty speed)"

	add_attribute	"Rows"
	add_values		"$(stty size | awk '{print $1}')"

	add_attribute	"Columns"
	add_values		"$(stty size | awk '{print $2}')"

	module_footer
	flush_values
}


#######################
# PRINTERS AVAILABLE TO THE SYSTEM

# EXPERIMENTAL!

# uses only lpstat (cups) and hasn't been tested on multi-printer
# environments
Module_printers() {
	moduleName="Printers"
	module_header "${moduleName}"

	local lp_nr

	# first of all, check if lpstat is available
	if [ "$(type -p lpstat)" ]; then

		#	if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then

		add_attribute		'Printer'	'local_printer'

		# as there may be several printers, print info from all
		for lp_nr in $(seq 1 1 $(lpstat -a | wc -l) ); do

			add_values	"$(lpstat -a 2> /dev/null | sed -n "$lp_nr{p;q;}")"

		done

	fi


	module_footer
	flush_values

}

#######################
# USERS
#
# reports the current user, the user's X11 session manager + shell
# the last logged user, and other users that have logged in
# (that last can see).
Module_users() {
	moduleName="Users"
	module_header "${moduleName}"

	add_attribute	'Current user'			"current_user"
	add_values		"$(whoami)"


	add_attribute	'Real name'				"real_name"
	add_values		"$(grep $(whoami) /etc/passwd | awk -F: {'print $5'})"


	add_attribute	"User's X11 session"	"users_window_manager"
	# KDE sets $DESKTOP_SESSION nicely, but Gnome doesn't.
	local session_id="$(echo $DESKTOP_SESSION)"
	if [ "$session_id" == "default" ]; then
		if [ "$GNOME_DESKTOP_SESSION_ID" ]; then
			# try to get Gnome version
			local gnome_version="$(gnome-about --version | awk {'print $NF'})"
			session_id="Gnome $gnome_version"
		fi
	fi
	add_values		"$session_id"


	add_attribute	"User's shell"
	add_values		"$SHELL"


	add_attribute	'Last logged in user'	"last_logged_user"
	add_values		"$(last -1 | head -n 1 | awk {'print $1'})"


	add_attribute	'All users'				"users"
	# because 'last' command, part of sysvinit core package,
	# interprets the binary file /var/log/wtmp, but chomps off
	# the loginname at 9 characters, we need to find the full names
	# from the source file. a dirty hack...

	local users="$(last | awk {'print $1'} | sort | uniq | \
	               grep -v 'reboot\|wtmp' | grep '^[a-zA-Z]')"
	               # removes users 'reboot' and 'wtmp'
	local user
	local wtmp_file="/var/log/wtmp"
	for user in $users; do

		if [ ${#user} -ge 8 ]; then
			# parse special chars to meta-chars
			user="$(sed 's/[[:punct:]]/\\&/g' <<< $user)"
			add_values	"$(grep -Eoa "$user[a-zA-Z+]*" ${wtmp_file} | uniq)\n"
		else
			add_values	"$user\n"
		fi
	done

	module_footer
	flush_values
}


###########################
# SYSTEM SERVICES (daemons)

# EXPERIMENTAL!
Module_services() {


	# Gentoo: rc-status

	# Fedora: /sbin/service --status-all
	#         chkconfig --list

	# Ubuntu:

	moduleName="Services"
	module_header "${moduleName}"


	module_footer
	flush_values
}


#######################
# NETWORK
#
# this module detects the network settings of the computer.
#
# there are at least two methods to pull in information; ifconfig and iproute2.
# ifconfig is used; there are at least two versions of ifconfig being used, and
# all tested Linuxes have used the same, whereas FreeBSD v6 had different
# output. the script should work on both versions.
#
# some changes have been made after testing with FreeBSD, so compitibility
# may not be 100% anymore.
#
# WIRELESS SUPPORT IS EXPERIMENTAL
Module_network() {
	moduleName="Network information"
	module_header	"${moduleName}"

	local specials="UP|BROADCAST|LOOPBACK|NOARP|NOTRAILERS|RUNNING|MULTICAST"
	# what are these needed for?

	# allocate the temp file
	local nw_info="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$nw_info")

	################################
	# DETECT (WIRED) NETWORK DEVICES
	# using ifconfig
	#
	# detect the type of OS (and ifconfig available); there may other
	# versions, but these two OSes were tested. all ifconfigs in Linux operate
	# more of less similarity, but the one on FreeBSD is different.
	if [ "$(type -p ifconfig)" ]; then
		nw_src="ifconfig"

		if [ "$SYSTEM" == "linux" ] ; then
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST -B 3 | \
			grep -Ev '(^ )|(^--)|LOOPBACK' | awk  {'print $1'})"

		else # *BSD ifconfig
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST | grep -v LOOPBACK | \
			awk -F': ' {'print $1'})"
		fi
	fi


	# collect the information from detected network devices
	for interface_name in $ETH_DEVICES; do
		ifconfig $interface_name > ${nw_info}

		value_header	$interface_name

		add_attribute 'MAC'		"mac_address"
		add_values    "$(grep -Eo '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}' ${nw_info})"

		# TODO: IP type (static or dynamic)
		#add_attribute	'IP type'	"ip_type"

		add_attribute 'IPv4'		"ip_address"
		add_values    "$(grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' ${nw_info} | \
		                 grep -Eo '[0-9\.]+' )"

		add_attribute 'IPv6'
		add_values    "$(sed "s/  /\n/g" ${nw_info} | grep -i inet6 | \
		                 grep -Eio '([0-9a-f]{3,4}(\:){1,2}){4,8}([0-9a-f]{3,4})' )"

		add_attribute 'NIS domain'
		add_values    "$(hostname -y 2> /dev/null)"
		# hostname produces stderr if no network is available

		add_attribute  'DNS domain'	'domain'
		add_values    "$(hostname -d 2> /dev/null)"

		add_attribute 'FQDN'		"fully_qualified_domain_name"
		add_values    "$(hostname -f 2> /dev/null)"

		add_attribute 'Gateway'	"default_gateway"
		add_values    "$(route -n | awk '/^0.0.0.0/{print $2}')"

		add_attribute 'Broadcast'
		add_values    "$(sed "s/  /\n/g" ${nw_info} | \
		                 grep -Eio 'cast[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | \
		                 grep -Eo '[0-9\.]+' )"

		add_attribute 'Netmask'	"subnet_mask"
		add_values    "$(sed "s/  /\n/g" ${nw_info} | \
		                 grep -Eio 'mask[A-Za-z: ]*((([0-9]{1,3}\.){3}[0-9]{1,3})|(0x[0-f]{8}))' | \
		                 grep -Eo '[0-9\.fx]+' )"

		add_attribute 'RX bytes'
		add_values    "$(sed "s/  /\n/g" ${nw_info} | \
		                 grep -i 'RX bytes' | awk -F: {'print $2'})"

		add_attribute 'TX bytes'
		add_values    "$(sed "s/  /\n/g" ${nw_info} | \
		                 grep -i 'TX bytes' | awk -F: {'print $2'})"

		value_footer

	done


	###################################################
	# DETECT WIRELESS NETWORK DEVICES AND ACCESS POINTS
	# with iwconfig, Linux only
	#
	# under developement, does not yet work!

	# FIXME: This odd debug usage sucks... Better add a --debug if you realy need this.
	# note: for debugging, these variables are set here
	if [ "$isdebug" == 1 ]; then
		iw_src="debug/wlan-iwconfig-on"
		WLAN_DEVICES="eth1"
		ap_src="debug/wlan-stations"

		if [ "$(type -p iwconfig)" ]; then

			iw_src="iwconfig"

			# not tested yet
			if [ "$SYSTEM" == "linux" ] ; then

			# FIXME: on my system w/ wireless-tools,
			# but no wlan network (no working drivers)
			#  iwconfig -a
			#  -a        No such device

				ETH_DEVICES="$(iwconfig -a | grep BROADCAST -B 3 | \
				grep -Ev '(^ )|(^--)|LOOPBACK' | \
				awk  {'print $1'})"
			fi

		fi

		# info from access points (AP)
		if [ "$(type -p iwlist)" ]; then
			# tweak this a bit
			ap_src="iwlist $WLAN_DEVICES scan"
		fi

		value_header  'wlan'

		add_attribute "associated ESSID"
		add_values    "$(grep -Eo 'ESSID[:"A-Za-z/ ]*' "${iw_src}" | \
		                 awk -F: {'print $2'})"

		value_footer
	fi



	# cleanup
	rm -f ${nw_info}

	module_footer
	flush_values
}


##
# Gets data from lsb_release
# Parameters:
#  1  string   what value to get.
distro_lsb_release() {
	lsb_release -a 2> /dev/null | grep -i "^$1" | awk -F: '{print $2}' | sed -s 's/^\t*//'
}

#######################
# DISTRIBUTION
#
# this module will try to guess which Linux distrobution is installed.
# the default tool to use is the lsb-release (Linux Standard Base
# version reporting utility)
#
# a secondary id source are the unique files in /etc/, and as a last
# resort the /etc/issue file. this makes it possible to identify
# a distro which resides in a chroot environment, or from a livecd.
Module_distro() {
	moduleName="Distribution"
	module_header "${moduleName}"

	# distro_id, distro_release are used elsewhere, no not "localize" these
	local distro_codename distro_description


	# locate and echo the root directory.
	# TODO: Some of this isn't actually needed as we allready fixed so there is at most one endning / (can be zero ending / too).
	[ "$prefix" != '/' ] && \
		local root_dir="$(echo $prefix | sed 's/\/*$//')" || \
		local root_dir="$prefix"
	add_attribute		'Root dir'
	add_values			"$root_dir"
	[ "$root_dir" != '/' ] && root_dir="${root_dir}/"


	# look for lsb-release if real root is used.
	if [ "$(type -p lsb_release)" ] && [ "$prefix" == '/' ]; then

		distro_id="$(distro_lsb_release 'distributor')"
		distro_release="$(distro_lsb_release 'release')"
		distro_codename="$(distro_lsb_release 'codename')"
		distro_description="$(distro_lsb_release 'description')"

	else

		# Begin searching for distro identifying files
		local found_files="" myfile
		for myfile in ${root_dir}etc/{SuSE-release,fedora-release,redhat-release,slackware-version,Topologilinux-version,gentoo-release,issue}; do
			[ -e $myfile ] && found_files="$found_files $myfile"
		done

		# Now make a list of distros from the $found_files list above
		local found_distros="" distro_ident
		for distro_ident in $found_files; do
			case $distro_ident in
				"${root_dir}etc/SuSE-release")
					found_distros="$found_distros SuSE"
					break;
					;;
				"${root_dir}etc/fedora-release")
					found_distros="$found_distros Fedora Core"
					break;
					;;
				"${root_dir}etc/redhat-release")
					found_distros="$found_distros Red Hat"
					break;
					;;
				"${root_dir}etc/slackware-version")
					found_distros="$found_distros Slackware"
					break;
					;;
				"${root_dir}etc/Topologilinux-version")
					found_distros="$found_distros Topologilinux"
					break;
					;;
				"${root_dir}etc/gentoo-release")
					found_distros="$found_distros Gentoo"
					break;
					;;
				# if nothing previous matches, then use /etc/issue
				# AnMaster: Inform user that this might be very wrong...
				"${root_dir}etc/issue")
					found_distros="$found_distros misc"
					break;
					;;
			esac
		done
		# Remove leading spaces.
		found_distros="$(sed 's/^ *//' <<< "${found_distros}")"


		# Get distro name
		# NOTE: have been changed to case-insensitive, although
		# has not been thoroughly tested. the commented code
		# may be removed after verifying the new code works.
		case "$(echo ${found_distros} | tr 'A-Z' 'a-z')" in
			'suse'|'fedora core'|'fedora'|'red hat'|'slackware'|'slackware topologilinux'|'gentoo'|'ubuntu')
			#'SuSE'|'Fedora Core'|'Fedora'|'Red Hat'|'Slackware'|'Slackware Topologilinux'|'Gentoo'|'Ubuntu')

				distro_id="${found_distros}"

				# clear spaces
				#[ "$found_distros" = 'Slackware Topologilinux' ] && \
				#	found_distros='Topologilinux'
				#[ "$found_distros" = 'Red Hat' ] && found_distros='RedHat'
				#[ "$found_distros" = 'Fedora Core' ] && found_distros='Fedora'
				;;

			'topologilinux')
				print_error 1 "This module will abort." "$usekdialog" \
					"Topologilinux is based on Slackware and should" \
					"contain ${root_dir}etc/slackware-version AND " \
					"${root_dir}etc/Topologilinux-version."
				return 1
				;;

			'misc')
				for misc_distro in 'Ubuntu' 'Fedora' 'SuSE'; do
					if [ "$(grep -i ${misc_distro} ${distro_ident})" ]; then

						distro_id="${misc_distro}"
					fi
				done
				;;

			'')
				# Abort if no distro found
				print_error 1 "This module will abort." "$usekdialog" \
					"You have zero distros installed or use a distro " \
					"not recognised by ${appname}"
				return 1
				;;

			#*)
				# Abort if more than one distro
				#if [ "$usekdialog" == "1" ]; then
					#kdialog --error  "You have several distros installed at the \
					#same time.\nInstalled distros:\n${found_distros}\n\
					#This module will abort."
				#else
					#echo "${tcRED}ERROR:${tSTD} You have several distros \
						#installed at the same time."
					#echo "${tcRED}ERROR:${tSTD} ${tBOLD}Installed distros:${tSTD}\
						#${found_distros}"
					#echo "${tcRED}This module will abort.${tSTD}"
				#fi
				#return 1
			#;;
			esac


		# Output distro version
		case "${found_distros}" in
			'SuSE')
				distro_release="$(grep -F 'VERSION = ' ${root_dir}etc/SuSE-release          | sed 's/VERSION = //'    )" ;;
			'Red Hat')
				distro_release="$(cat ${root_dir}etc/redhat-release)" ;;
			'Fedora')
				distro_release="$(cat ${root_dir}etc/fedora-release)" ;;
			'Slackware')
				distro_release="$(grep -F 'Slackware ' ${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
			'Topologilinux')
				distro_release="$(grep -F 'Topologilinux ' ${root_dir}etc/Topologilinux-version | sed 's/Topologilinux //')"
				local  SlackwareBase="$(grep -F 'Slackware  '${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
			'Gentoo')
				# AnMaster: Not sure if readlink is POSIX but it exists on Gentoo and we allready know this is Gentoo.
				distro_release="$(readlink /etc/make.profile | grep -Eo '[0-9]{4}\.[0-9]')";;
			'misc')
				# FIXME: AnMaster: . is a wildcard meaning any single char. Isn't grep -F what you want?
				distro_release="$(grep '.' "${root_dir}etc/issue" | grep -Eo '([A-Za-z0-9 ."])+' | head -n 1 )";;
				# TODO: improve the grep
		esac

	fi


	# then output what we found..

	[ "${distro_id}" ] && \
		add_attribute	'Distro ID'
		add_values		"${distro_id}"

	[ "${distro_release}" ] && \
		add_attribute	'Release'
		add_values		"$distro_release"

	[ "${distro_codename}" ] && \
		add_attribute	'Codename'
		add_values		"$distro_codename"

	[ "${distro_description}" ] && \
		add_attribute	'Description'
		add_values		"$distro_description"

	[ "$SlackwareBase" ] && \
		add_values	'Based on Slackware version' \
					"$SlackwareBase"


	module_footer
	flush_values
}


#######################
# APPLICATIONS
#
# version information of standard *nix, dev, and dependency packages.
# probably should take an additional switch like --X, --server, etc.
Module_applications() {
	moduleName="Applications"
	module_header "${moduleName}"

	local APPLICATIONS app
	## Applications to look for..
	if [ "$SYSTEM" == "linux" ] ; then

		APPLICATIONS="X kde-config gnome-about x11vnc \
			bash csh ls \
			gcc make \
			awk sed grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			udevinfo lspci lshw dmidecode smartctl hdparm"

	elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then

		APPLICATIONS="X kde-config x11vnc \
			csh bash ksh \
			gcc grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			lspci lshw smartctl hdparm"

	fi

	## Write the header for output
	add_attribute "Applications\n" 'software'

	local missing_ERRMSG="if you want to be able to use all modules of ${appname}"
	## Process all applications
	for app in ${APPLICATIONS}; do

		if [ "$(type -p $app)" ]; then # it is installed
			case "$app" in
				'perl')
					add_values 	"Perl $($app --version 2>&1 | grep 'perl, v' | \
								grep -Eo 'v[ A-Za-z0-9.-]*')\n"
					;;
				'python')
					add_values	"$($app -V 2>&1 | head -n 1 )\n"
					;;
				'X')
					add_values	"$($app -version 2>&1 | grep Revision)\n"
					;;
				'kde-config')
					add_values	"$($app -version 2>&1 | grep KDE)\n"
					;;
				'gnome-about')
					add_values	"$($app --version 2>&1 )\n"
					;;
				'apache2'|'apache')
					add_values	"$($app -V | head -n 1 | awk -F': ' {'print $2'})\n"
					;;
				'cups-config')
					add_values	"Cups $($app --version 2>&1 )\n"
					;;
				'smbd')
					add_values	"Samba $($app -V 2>&1 )\n"
					;;
				'udevinfo')
					add_values	"$($app -V 2>&1 )\n"
					;;
				'awk')
					add_values	"$($app -W version 2>&1 | head -n 1 )\n"
					;;
				'dmidecode')
					add_values	"dmidecode $(dmidecode -V 2> /dev/null )\n"
					;;
				*)
						add_values	"$($app --version 2>&1 | grep '\w' | head -n 1)\n"
					;;
										#grep  -P '[0-9]+\.[0-9]+' | sed 's/^tune2fs //')"
			esac
		else
			case "$app" in
				'lspci')
					add_values 'lspci'      "please install pciutils ${missing_ERRMSG}\n"
					;;
				'lshw')
					add_values 'lshw'       "please install lshw ${missing_ERRMSG}\n"
					;;
				'smartctl')
					add_values 'smartctl'   "please install smartmontools ${missing_ERRMSG}\n"
					;;
				'dmidecode')
					add_values 'demidecode' "please install dmidecode ${missing_ERRMSG}\n"
					;;
			esac
		fi
	done
	module_footer
	flush_values
}


#######################
# hardware devices of the system
#
# this function parses the physical devices in the computer from lspci.
# depends on pciutils.
#
# the output verbosity can be increased to include devices in the
# DO_NOT_OUTPUT string to include standard motherboard controllers
# which are suppressed in the normal level of verbosity.
Module_devices() {
	moduleName="Devices"
	module_header "${moduleName}"
	local DEVICE
	local DEV_ARRAY=1;
	for DEVICE in $(lspci | awk {'$1="\b" ; print $0'} | tr ' ' '_' ); do

		devices[$DEV_ARRAY]="$(

			echo $DEVICE | sed -r 's/:_/:/g;s/(^_)//g' | tr ':' ' ' )"

			# with lspci 2.2 and later, the -m switch works fine
			#	for DEVICE in $(lspci -m | tr ' ' '_'); do
			#		devices_dbg[$DEV_ARRAY]="$(	echo $DEVICE | grep -Eo '"[^"]+"' | awk -F\" {'print $2'} )";

		((DEV_ARRAY++))
	done

	# the devices array now contains the ' ' separated entries from lsmod.
	# [1] device type		# [2] manufacturer		# [3] device name	etc
	# ${#devices[@]} # is the number of devices in the array

	# by default output all, but
	DO_NOT_OUTPUT="pci\|usb\|smb\|bridge\|ide"

	[[ "$isverbose" -eq 1 ]] && \
		DO_NOT_OUTPUT="smb\|bridge"


	for DEV_ARRAY in $(seq 1 1 ${#devices[@]}); do
		#if [ ! "$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | \
		#	grep -i $DO_NOT_OUTPUT)" ]; then
		if [ -z "$(grep -i $DO_NOT_OUTPUT <<< ${devices[$DEV_ARRAY]})" ]; then


			# make an exception for display and ethernet adapters
			# so they can be tagged properly in the xml output.

			# make sure that if several adapters are found, they are
			# printed as <value>s under the same <attribute> tag

			# AnMaster: Could you please tell me what you (ruxpin) mean with this?
			#           As there is nothing about network in lspci...
			#           And Display adapter(s) seems broken.
			#               01:00.0 VGA compatible controller: ATI Technologies Inc RV280 [Radeon 9200 PRO] (rev 01)
			#               01:00.1 Display controller: ATI Technologies Inc RV280 [Radeon 9200 PRO] (Secondary) (rev 01)
			#           And there is only one in osinfo. In osinfo --xml there is one normal and one empty for it.
			#               <value>ATI Technologies Inc RV280 [Radeon 9200 PRO] (rev 01) </value>
			#               <value></value>
			#           Same in the lanforce output.

			# ruxpin: I already though of fixing it, because I got two network cards
			# to output. I can't debug that right now.

			local description="$(awk  '{ print $1 }' <<< ${devices[$DEV_ARRAY]} | \
			                     tr '_' ' ' | sed 's/^.//;s/^ *//')"
			local device="$(awk  '{ print $2" "$3 }' <<< ${devices[$DEV_ARRAY]} | \
								tr '_' ' ')"


			if [ "$(grep -i 'network\|ethernet' <<< "$description")" ]; then

				# these values should not be local,
				# older bash fails there
				eth_adapter[${#eth_adapter[@]}]="$device"

			elif [ "$(grep -i 'vga\|display' <<< "$description")" ]; then

				video_adapter[${#video_adapter[@]}]="$device"

			else

				add_attribute "$description"
				add_values    "$device"

			fi

		fi
	done


	#then report the eth and video adapters
	if [ "$eth_adapter" ]; then
		add_attribute	'Ethernet controller(s)'	"network_adapter"
		for i in $(seq 0 1 $((${#eth_adapter[@]}-1)) ); do
			add_values		"${eth_adapter[$i]}\n"
		done
	fi


	if [ "$video_adapter" ]; then
		add_attribute	'Display adapter(s)'		"display_adapter"
		for i in $(seq 0 1 $((${#video_adapter[@]}-1)) ); do
			add_values		"${video_adapter[$i]}\n"
		done
	fi

	#12:04 < LinuxNIT> is there a way to check and see how much ram my video card actually has available/is using? not just what i set in the xorg.conf
	#12:04 < Kevin`> lspci -vv
	#12:06 < LinuxNIT> IRegion 0: Memory at e8000000 (32-bit, prefetchable) [size=128M]

	module_footer
	flush_values
}


#######################
# ENVIRONMENT VARIABLES
#
# xml only
# FIXME: Shouldn't be xml only...
# ruxpin: no, this information is useless to produce to stdout, as the 'env' command
# does the same..
# AnMaster: ah ok.
Module_env() {
	moduleName="Environment variables"
	module_header "${moduleName}"

	## Write the header for output
	add_attribute   'System enviroment variables\n' \
	                'system_enviroment_variables'
	## Process all variables
	for var in $(env); do

		add_values	"${var}\n"

	done

	module_footer
	flush_values
}

