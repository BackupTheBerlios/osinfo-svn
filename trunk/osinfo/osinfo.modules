#!/bin/bash
#################################################################################
# OSINFO MODULES
#
# osinfo lists system information available to the OS.
#
# this file contains the osinfo modules and module subfunctions.
# modules can be freely added; the data processing and outputting is taken
# care of by other functions. these are accessed by the following functions,
# and here they are presented in the order in which they should appear in
# the modules.
#
# module_header	"Module name <string>"
#  each module should begin with this line.
#  it will be printed in colour at stdout and as a tag to xml.
#  it may contain spaces; in the xml tag they will be replaced by '_'
#
# add_header	"Header <string>" "Xml modifier <string> (optional)"
#  the argument is printed on a single line in bold to stdout,
#  and as a <header> tag to the xml, unless the modifier
#  is present. see add_header() for more information.
#  each module may contain several calls of this type.
#
# add_attribute "Common Name <string>"	"xml_code <string>"
#  the first argument is printed at the first field to stdout,
#  and the xml output is formulated as:
#  <xml_code>
#   <value>foo</value>
#  </xml_code>
#  each module may contain several calls of this type.
#  the previous attribute tag is automatically closed when a new
#  one is introduced.
#
# add_values "value 1 <any type>" "value 2" "value n"
#  several values can be given;
#  all of them will be separated with tab at stdout,
#  and they will each get their own <value>foo</value> line at xml output.
#  special characters as '\n' and '\t' can be used;
#  they will not affect the xml output.
#  each module may contain several calls of this type.
#
# add_footer "Footer <string>"
#  this call may follow a block of values, if the add_header
#  function is called before them. this closes open header tags.
#
# flush_values
#  prints the values to xml file or to stdout.
#  this should be the final command in a module.
#
#################################################################################
# Written by Mikael Lammentausta and Arvid Norlander
#
# Some parts are taken from:
#   --Advanced Bash Scripting Guide (ABS)
#################################################################################


## META-MODULES
#
# can be also used as aliases on the command line,
# but not inside another meta-module

# AnMaster: I think this isn't very useful at all...
#           Also you need to get rid of eval if you plan to use it...
# ruxpin: this is a way to run mod_distro with mod_system, otherwise we'll have to
#         combine the two modules because the latter depends on the former.
#         this may well repeat later with other modules too. and besides a subset
#         of modules is useful, we may not fully realise it yet.
# TODO: make meta modules run the dependencies silent.

Meta_all='system distro kernel processor hdd applications network wlan terminal devices dmi cdrom memory users services'
Meta_lanforce='system processor memory network wlan dmi hdd devices cdrom users applications services env'
Meta_system='system kernel processor'
Meta_cpu='processor'
Meta_apps='applications'
Meta_net='network wlan'
MODULES_META='all lanforce system cpu apps net'

# these are used to control run access and validify against

MODULES_LINUX='system distro kernel processor hdd network wlan applications terminal devices dmi cdrom memory users services'
MODULES_BSD='system applications terminal network'
MODULES_BROKEN='printers lvm ide'
MODULES_REAL_ROOT_ONLY='system memory cdrom processor terminal applications network wlan devices services hdd printers dmi services ide'
MODULES_SU_ONLY='cdrom hdd dmi memory oem'
# MUST contain a list of all modules. This is used to find any invalid modules.
MODULES_ALL='applications cdrom devices distro dmi env hdd kernel memory network oem printers processor services system terminal users wlan lvm ide'


################################################################################
################################################################################
## General helper functions                                                   ##
################################################################################
################################################################################

##
# Checks for lshw and print a message if it doesn't exist
# Returns 0 if lshw eixsts and 1 if it is missing.
CheckReq_lshw() {
	if [ ! "$(type -p lshw)" ]; then
		info    "Please install lshw to collect this information"
		return 1
	else
		return 0
	fi
}

##
# Checks for dmidecode and print a message if it doesn't exist
# Returns 0 if dmidecode eixsts and 1 if it is missing.
CheckReq_dmidecode() {
	if [ ! "$(type -p dmidecode)" ]; then
		info    "Please install dmidecode to collect this information"
		return 1
	else
		return 0
	fi
}


##
# Check if the system has working sensors
CheckReq_sensors() {
	if [ "$(type -p sensors)" ]; then
		# FIXME: make better sensor-detecting scheme
		if [ "$(sensors 2>/dev/null | grep -i vcore)" ]; then
			return 0
		else
			return 1
		fi
	else
		return 1
	fi
}


##
# Checks if we are run as root and print a message if we are not.
# Returns 0 if we are root and 1 if we are not.
CheckReq_root() {
	if [ "$EUID" != 0 ]; then
		info    "Please run $appname as super-user to collect this information"
		return 1
	else
		return 0
	fi
}


##
# Checks if lshw was already run.
#  if it wasn't then run lshw and export the filename of the temporary file.
#  otherwise just return.
lshw_xml() {
	if [ -z "$lshw_xml_file" ]; then
		export lshw_xml_file="$(mktemp /tmp/osinfo.XXXXXX)"
		lshw -xml > "$lshw_xml_file"
	fi
}

##################################
# extracts a node from input file
# based on indentation, and the begin and end keywords
#
# operation is case-insensitive
#
#	parameters:
#	(1) node id, the begin keyword
#	(2) input file
#	(3) node closer, the end keyword, defaults to 'node id'
extr_node() {
	local node_id="${1}"
	local input_file="${2}"
	local node_closer="${3}"
	local nr node
	local all_nodes=""
	local node_count=0

	input_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$input_tmp" )

	# add line numbers
	grep -n . ${input_file} > $input_tmp

	# if a special node closer is not defined, use the node_id
	[ ! "$node_closer" ] && node_closer="${node_id}"

	# get all matching nodes and node count
	all_nodes="$(grep  -i "${node_id}" $input_tmp)"
	# NOTE: this uses an extra grep, because '<<<' adds a '\n' and
	# wc counts an empty variable line length as '1'
	node_count="$(grep -i "${node_id}" <<< ${all_nodes} | wc -l)"

	if [ $node_count -ge 1 ]; then

		# this loop extracts the information between the node begin
		# and end lines, based on indentation level (xml), echoing
		# the results out
		for nr in $(seq 1 1 $node_count); do
			this_node="$(sed -n "$nr{p;q;}" <<< "${all_nodes}")"

			# this gets the line number of the wanted node from lshw
			local begin="$(awk -F: {'print $1'} <<< ${this_node})"
			local node_indent="$(awk -F: {'print $2'} <<< "${this_node}" | \
					     grep -Eo '^[ ]*' | wc -m)"

			# this loop takes care that all subnodes are included, by comparing
			# the indentation level. not very elegant..
			# basically it just searches for $node_closer and gets the line#
			IFS_bak="$IFS"; IFS=$'\n' ;
			for node in $(sed -n "$(($begin+1)),\${p;}" $input_tmp | \
				      grep ${node_closer}); do

				# if the indentation matches...
				if [ "$(awk -F: {'print $2'} <<< ${node} | grep -Eo '\ *' | \
					wc -m)" == "$node_indent" ]; then

					# read the line# to $nigeb (begin backwards)
					# the line number of the closing node
					local nigeb="$(awk -F: {'print $1'} <<< "${node}" )"
					((nigeb--)) # this prevents the closing node to displaying
						    # as sometimes this may not be wanted
					break;

				fi

			done

			# if the closing node wasn't found, read to EOF
			[ ! "$nigeb" ] && nigeb="$"
			IFS="$IFS_bak"

			# then what's between the first node and the closing id
			# is echoed to whichever function called this
			echo "%node $nr%"
			sed -n "$begin,$nigeb{p;}" $input_file

		done
	fi
}

TempFiles=()
##
# Cleans up some temporary files in the TempFiles array.
#
cleanup_temp_files() {
	if [ "$lshw_xml_file" ]; then
		rm -f "$lshw_xml_file"
	fi
	local File
	for File in "${TempFiles[@]}"; do
		rm -f "$File"
	done
}

##
# Keeps track of open headers, and closes them in the correct
# order upon flush_values.
OpenHeaders=()



################################################################################
################################################################################
## Modules                                                                    ##
################################################################################
################################################################################


#######################
# HARD DISK DRIVES
#
# this module collects data of the hard disk drives attached to the system.
# some information is unaccesible unless the partitions are mounted.
#
# S-ATA drives now display everything as nicely as IDE drives,
# due to support in recent smartmontools (version 5.36).
#
# used tools:
# fdisk, df, udev, /proc (deprecated), smartmontools, hdparm, bc
Module_hdd() {
	local moduleName="Disk information"
	module_header "${moduleName}"

	# developement status:
	# -------------------
	# IDE/PATA is tested
	# SATA is tested
	# USB (flash sticks and hard drives) is tested
	# SCSI is untested, although works probably as SATA
	# Software RAID is planned (mdadm only), untested
	# Logical Volume Management support is planned, untested
	# FreeBSD is untested


	# this module depends heavily on root access, so prevent other users
	# of running this module
	if CheckReq_root; then

		# declare variables
		local hdd_total_capacity=0 hdd_total_used=0 hdd_total_free=0 hdd_ID=0

		# detect all drives in the system
		local drives="$(fdisk -l | grep -Eo '\/(dev)\/[a-z]+' | uniq )"

		# collect data of all detected drives in this loop
		for drvdev in $drives; do

			((hdd_ID++))

			#########################
			# initialize variables
			#
			# $hdd_dev is the devfs/udev node, e.g. "/dev/hda"
			# $hdd_node is the device id, e.g. "hda"
			# $hdd_busnr is the drive bus number, e.g. for sdc '3' and hdd '4'

			hdd_dev[$hdd_ID]="${drvdev}"
			hdd_node[$hdd_ID]=$(echo $drvdev | awk -F/ {'print $NF'})
			# FIXME: useless use of echo?
			hdd_busnr[$hdd_ID]=$(( $(echo -n ${hdd_node[$hdd_ID]: -1:1} | \
				tr 'a-z' 'A-Z' | od -A n -t u1) - 64));
				# 64 is the offset of 'A' in the ASCII chart


			#################################
			# scan type-dependent attributes

			# IDE drives
			if [ "$(echo $drvdev | grep 'hd' )" ]; then

				# On FreeBSD the first ATA drive is 'ad0',
				# not tested!
				scan_hdd_ide ${drvdev} ${hdd_node[$hdd_ID]} ${hdd_busnr[$hdd_ID]}


			# SATA/SCSI/USB drives (Linux SCSI sg driver)
			elif [ "$(echo $drvdev | grep 'sd' )" ]; then

				# On FreeBSD the first ATA drive is 'da0',
				# hasn't been tested!
				scan_hdd_sata ${drvdev} ${hdd_node[$hdd_ID]} ${hdd_busnr[$hdd_ID]}


			# software RAID arrays
			elif  [ "$(echo $drvdev | grep md)" ]; then

				scan_hdd_raid ${drvdev} ${hdd_node[$hdd_ID]} ${hdd_busnr[$hdd_ID]}

			else

				hdd_type="Unknown drive type"

			fi


			###############################
			# scan common attributes
			scan_hdd_common ${drvdev}


			#####################
			# scan the partitions
			#
			# see the function code for comments on the variables
			# this functions sets. they will be overwritten during
			# the next run of this function. this would be easily
			# fixed if bash would support matrices, but no.
			hdd_pt_ID=0
			scan_hdd_partitions ${drvdev}


			##############################################
			# calculate the total disk capacity of $drvdev
			calculate_hdd_usage


			####################
			# OUTPUT DRIVE DATA
			if [ $usexml -eq 0 ]; then

			# TODO: use array for these values, no need to unset then

				add_header  "\n${drvdev}"

				add_attribute "$hdd_type"
					add_values  "$(echo $hdd_vendor $hdd_model | sed 's/^ *//')"
				add_attribute 'Serial number'
					add_values  "$hdd_serial"
				add_attribute 'Driver'
					add_values  "$hdd_driver"
				add_attribute 'DMA'
					add_values  "$hdd_dma"
				add_attribute 'Geometry'
					add_values  "$hdd_geometry"
				add_attribute 'Capacity (reported)'
					add_values  "$hdd_capacity_label"
				add_attribute 'Capacity (actual)'
					add_values  "$(hdd_human_readable $hdd_capacity)"

				if [ "$(type -p smartctl)" ]; then
					add_attribute 'S.M.A.R.T.'
						add_values  "$hdd_smart"
					add_attribute 'Lifetime'
						add_values  "$hdd_lifetime"
					add_attribute 'Temperature'
						add_values  "$hdd_tempC"
						add_value_footer "C"
					add_attribute 'Health Status'
						add_values  "$hdd_health"
				fi

				flush_values

				add_header	'' # adds a space into stdout, does not affect xml
				add_nc_header	" Partition%col%mountpoint%col%blocks%col%free%col%filesystem\n"
				add_nc_header	" ---------%col%----------%col%------%col%----%col%----------"


				for hdd_pt in $(seq 1 1 $partitions_on_drive); do
					# print the device node
					add_attribute "  ${hdd_pt_node[$hdd_pt]}"

					# print info of mounted drives
					if [ "${hdd_pt_mp[$hdd_pt]}" ]; then #mount point exists

						# mount point
						add_values    "${hdd_pt_mp[$hdd_pt]}"

						# blocks
						add_values    "$(hdd_human_readable \
						               ${hdd_pt_blocks[$hdd_pt]})"
						# free
						add_values    "$(hdd_human_readable \
						               ${hdd_pt_free[$hdd_pt]})"
						#add_values    "${hdd_pt_free_pc[$hdd_pt]})"

						# fs type
						add_values    "${hdd_pt_fs[$hdd_pt]}"

					else

						# mount point
						add_values    " "

						# blocks
						add_values    "$(hdd_human_readable \
						               ${hdd_pt_blocks[$hdd_pt]})"

						# free would come here
						add_values    ' '

						# fs type
						add_values    "${hdd_pt_fs[$hdd_pt]}"

					fi

				done

				flush_values

			### XML OUTPUT
			else

				add_attribute "$hdd_type"			'hard_disk'
				# TODO: how to break these into many lines?
				add_values    "$hdd_type $hdd_vendor $hdd_model ($hdd_serial) $hdd_capacity_label"

				add_attribute "partitions"		'drive'
				for hdd_pt in $(seq 1 1 $partitions_on_drive); do
					add_values    "${hdd_pt_node[$hdd_pt]} ${hdd_pt_mp[$hdd_pt]} ${hdd_pt_free[$hdd_pt]}/${hdd_pt_blocks[$hdd_pt]}"
				done

			fi

			##################
			# clear varibles
			unset hdd_vendor hdd_model hdd_serial \
					hdd_geometry hdd_dma hdd_driver \
					hdd_capacity_label hdd_capacity partitions_on_drive \
					hdd_smart hdd_lifetime hdd_tempC hdd_health \
					hdd_pt_node hdd_pt_mp hdd_pt_blocks hdd_pt_fs

		done


		######################################
		# calculate total system disk capacity
		# report data of the whole system

		#totalpercfree=0

		#add_attribute "Total disk space"
		#add_values    "Capacity: $(echo $totalsize)"
		#add_values    "Free: $(echo -e $totalfree ; $totalpercfree %)"


		#DISKFREE=$(($DISKFREE+$partfree))


	fi

	flush_values
}


###### BEGIN HDD SUBFUNCTIONS #############
#
# these functions are called from mod_hdd and they generate no output,
# all data is stored into global variables.


	##############################################
	# CALCULATES THE TOTAL DISK USAGE OF A DRIVE
	#
	# Sets variables:
	#  hdd_used[]           # total used space in kB
	#  hdd_free[]           # total free   - " -
	#  hdd_used_pc[]        # ratio of used/total capacity
	#  hdd_free_pc[]        # ratio of free/total capacity
	#  hdd_mnt_pc[]         # ratio of mounted/total disk capacity
	#  hdd_mnt_free_pc[]    # ratio of free/used on mounted
	#  hdd_mnt_used_pc[]    # ratio of used/free on mounted
	#  hdd_mnt_capacity[]   # total capacity in mounted partitions
	#
	calculate_hdd_usage() {
		local ID=$hdd_ID
		hdd_used[$ID]=0           # total used space in kB
		hdd_free[$ID]=0           # total free   - " -
		hdd_used_pc[$ID]=0        # ratio of used/total capacity
		hdd_free_pc[$ID]=0        # ratio of free/total capacity
		hdd_mnt_pc[$ID]=0         # ratio of mounted/total disk capacity
		hdd_mnt_free_pc[$ID]=0    # ratio of free/used on mounted
		hdd_mnt_used_pc[$ID]=0    # ratio of used/free on mounted
		[ ! "$partitions_on_drive" ] && scan_hdd_partitions
		[ ! "$hdd_capacity" ] && scan_hdd_common

		# calculate the total free space on all partitions
		# may be incorrect, since some partitions may be unmounted,
		# and swap if not counted in
		for hdd_pt in $(seq 1 1 $partitions_on_drive);do

			let hdd_used[$ID]+=hdd_pt_used[$hdd_pt]
			((hdd_free[$ID]+=hdd_pt_free[$hdd_pt]))

		done

		#echo "${hdd_free[$ID]}/${hdd_used[$ID]}/$hdd_capacity"

		# if the drive has mounted partitions
		if [ ${hdd_used[$ID]} -ne 0 ] && [ ${hdd_free[$ID]} -ne 0 ]; then

			# calculate the percentages of free and used space
			hdd_mnt_free_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_free[$ID]}*100/${hdd_used[$ID]}) %"

			hdd_mnt_used_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_used[$ID]}*100/${hdd_free[$ID]}) %"

			# calculate the ratio of mounted_capacity/total_capacity
			hdd_mnt_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_free[$ID]}*100/${hdd_capacity})%"


			# the ratio of used and free/total capacity
			hdd_used_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_used[$ID]}*100/${hdd_capacity})%"

			hdd_free_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_free[$ID]}*100/${hdd_capacity})%"

		fi
	}



	#################################################
	# SCAN COMMON ATTRIBUTES OF ALL HARD DRIVE TYPES
	#
	# geometry and capacity
	#
	# Sets variables:
	#  hdd_geometry
	#  hdd_capacity_label	is the value given by the vendor
	#  hdd_capacity			is the true capacity of the drive
	#
	# Parameters:
	#  (1) drive device
	#
	scan_hdd_common() {
		local dev_scan="${1}"

		hdd_geometry="$(fdisk -l | grep ${dev_scan} -A 1 | sed -n "2{p;q}")"

		# FIXME: couldn't this be simpler?
		hdd_capacity_label="$(fdisk -l ${dev_scan} | grep ${dev_scan} | \
			head -n 1 | grep -Eo '[1-9][0-9]+[\.0-9]* \w{2}' | head -n 1)"

		# fdisk gives drive capacity in kB
		hdd_capacity="$(fdisk -s $dev_scan)"
	}

	#########################
	# S.M.A.R.T. scanning
	#
	# smartmontools are handy in getting the extended parameters
	# of hard drives. only version 5.36 and onward support SATA drives
	# and the version may be a bit uncommon, as it was released in April 2006.
	# all major distros should begin to include it in their packages,
	# so this should be relatively common in late 2006.
	# for ide drives this is not a problem.
	#
	# Parameters:
	#  (1) drive device
	#  (2) device type (man smartctl for details)
	#
	scan_hdd_smart() {
		local dev_scan="${1}" dev_type smart_info version
		if [ "$2" ]; then
			dev_type="$2"
		else
			dev_type=ata
		fi

		# allocate a temp file
		smart_info="$(mktemp /tmp/osinfo.XXXXXX)"
		TempFiles=("${TempFiles[@]}" "$smart_info")

		smartctl -a -d $dev_type ${dev_scan} > $smart_info

		hdd_smart="$(grep 'SMART support' ${smart_info} | \
		             head -n 1 | awk -F': ' {'print $2'})"

		hdd_lifetime="$(grep -i power_on $smart_info | awk {'print $NF'})"

		hdd_tempC="$(grep -i temperature_celsius $smart_info | \
		             awk '{for (i=10; i<=NF; i++) printf("%s ",$i);printf ("\n")}')"

		hdd_health="$( grep -Ei '(health)+' $smart_info | awk {'print $NF'})"
	}


	####################
	# PARTITIONS
	#
	# function extracts information of hard drive partitions and
	# stores it into arrays. the arrays are identified by the variable
	# hdd_pt_ID, which should be used to identify the parameters of the
	# partition in hdd_pt_node[hdd_pt_ID]. the arrays this function creates:
	#
	#  hdd_pt_ID         # this is an internal reference number
	#  hdd_pt_node[]     # partition devfs/udev node, e.g. "/dev/hda1"
	#  hdd_pt_blocks[]   # size of the partition in 1 kB blocks
	#  hdd_pt_capacity[] # capacity of the partition  - " -
	#  hdd_pt_used[]     # used space  - " -
	#  hdd_pt_free[]     # free space  - " -
	#  hdd_pt_used_pc[]  # used space in percentage, e.g. "84.5%"
	#  hdd_pt_free_pc[]  # free space in percentage
	#  hdd_pt_mp[]       # mount point
	#  hdd_pt_fs[]       # filesystem type
	#  hdd_pt_fs_size[]  # space allocated by the filesystem
	#
	# Parameters:
	#  (1) drive device
	#
	scan_hdd_partitions() {
		local dev_scan="${1}" part_free=0
		partitions_on_drive="$(fdisk -l ${dev_scan} | grep ^${dev_scan} | wc -l)"
		local ID=$hdd_pt_ID


		#TODO for version 0.5 or so
		#hdd_fs_ID=[83] [7] [82] ... #which tells the FS type
		#hdd_fs_allocated=[1292372032] [28402202] [10284942]


		# loop all partitions detected by fdisk
		for PARTNR in $(seq 1 1 $partitions_on_drive); do

			((ID++)) # increase the array number

			# get the partition node
			hdd_pt_node[$ID]="$(fdisk -l ${dev_scan} | grep ^${dev_scan} | \
				awk {'print $1'} | sed -n "${PARTNR}{p;q;}" )"


			# get the partition size in 1 kB blocks
			hdd_pt_blocks[$ID]="$(fdisk -s ${hdd_pt_node[$ID]})"


			# detect the filesystem
			#
			# fdisk uses spaces, not tabs for indentation.
			# awk's $NF does not work, as the filesystem name may have spaces.
			# awk is looped from field 6 onward. while the field 6 is the
			# FS type integer, it has to be included when fdisk adds a '*'
			# character to denote bootable partitions. the numbers are removed
			# from the beginning of string with sed.
			hdd_pt_fs[$ID]="$(fdisk -l | grep ^${hdd_pt_node[$ID]} | \
			                  awk '{for (i=6; i<=NF; i++) printf("%s ",$i);printf ("\n")}' | \
			                  sed 's/^[0-9 ]*//')"


			# if partition is mounted (=is in mtab)
			#
			# FIXME: submounted (=system for automounting usb sticks) partitions
			# may be considered unmounted, while they are not!

			# the partition size is calculated from the value given by df,
			# and the float division is computed by bc.
			if [ "$(df -Plk | grep ${hdd_pt_node[$ID]})" ]; then

				# locate the mountpoint
				hdd_pt_mp[$ID]="$(df -PT ${hdd_pt_node[$ID]} | \
					grep ^${hdd_pt_node[$ID]} | awk {'print $NF'})"

				# get the partition capacity, used and free space in 1 kB blocks
				local df_output="$(df -Plk | grep ${hdd_pt_node[$ID]})"
				hdd_pt_capacity[$ID]="$(awk {'print $2'} <<< "$df_output")"
				hdd_pt_used[$ID]="$(awk {'print $3'} <<< "$df_output")"
				hdd_pt_free[$ID]="$(awk {'print $4'} <<< "$df_output")"
				hdd_pt_used_pc[$ID]="$(awk {'print $5'} <<< "$df_output")"

				# calculate the space allocated by the filesystem
				hdd_pt_fs_size[$ID]="$(bc -s <<< scale=1\;" \
					"${hdd_pt_free[$ID]}-${hdd_pt_capacity[$ID]})"

				# calculate the percentages of free and used space
				hdd_pt_free_pc[$ID]="$(bc -s <<< scale=1\;" \
					"${hdd_pt_free[$ID]}/${hdd_pt_capacity[$ID]}*100)%"


			fi

		done
	}


	#################
	# MAKES HDD SIZE REPORTS HUMAN-READABLE
	#
	# Parameters:
	#  (1) input value in kB
	#  (2) significant digits _after_ decimal, default 1
	#
	hdd_human_readable() {
		local value="${1}"

		if [ ! "$2" ]; then
			local digits=1
		else
			local digits="${2}"
		fi

		# dimension, 10^3 multiple of bytes, e.g. 'GB', defaults to MB
		case $(bc -s <<< ${value}/1024 | wc -m ) in
			'1'|'2'|'3'|'4')
				local dim='MB'
				local denominator="1024"
				;;
			'5'|'6'|'7')
				local dim='GB'
				local denominator='1024^2'
				;;
			'8'|'9'|'10')
				local dim='TB'
				local denominator="1024^3"
				;;
			'11'|'12'|'13')
				local dim='PB'
				local denominator="1024^4"
				;;
			*)
				local dim='kB'
				local denominator="1"
				;;
		esac

		local hdd_val="$(bc -s <<< scale=$digits\;${value}/${denominator}) $dim"

		# check if val<1
		if [ "${hdd_val:0:1}" == "." ]; then
			hdd_val="0${hdd_val}"
		fi

		echo "${hdd_val}"
	}


	#################
	# IDE drives
	#
	# this function collects information of IDE drives in the system
	#
	# udevinfo, /proc/ide/, smartmontools and hdparm are used as the data source.
	#
	# Parameters:
	#  (1) drive device
	#  (2) drive node in the /dev/ tree
	#  (3) the node number in the bus
	#
	scan_hdd_ide() {
		hdd_type='IDE drive'
		local dev_scan="${1}" dev_scannode="${2}"

		# detect the available data sources
		if [ "$(type -p udevinfo)" ]; then
			# allocate a temp file
			local udev_info="$(mktemp /tmp/osinfo.XXXXXX)"
			TempFiles=("${TempFiles[@]}" "$udev_info")
			udevinfo -q all -n ${dev_scan} > $udev_info
		fi
		if [ -e "/proc/ide/" ]; then
			local proc_info="/proc/ide/${dev_scannode}"
		fi
		# hdparm output is not read into a temp file, as
		# it is unlikely to be used, and that would unnecessarily
		# slow down this function.


		########
		# Vendor
		if [ "$(type -p smartctl)" ]; then

			# because smartctl uses its own database to report the HDD vendor,
			# it is preferred over udev.
			#
			# this smart scan is not included into the scan_hdd_smart()
			# because it would break the correct order of the report.
			hdd_vendor="$(smartctl -i ${dev_scan} | grep '^Model' | \
			              awk -F: {'print $2'} | sed 's/^ *//')"

		elif [ "${udev_info}" ]; then
			hdd_vendor="$(udevinfo -q all -n ${dev_scan} | grep -i vendor | \
			              awk -F_ {'print $NF'})"
		fi

		# check whether we got anything else than empty $vendor string
		if [  "$(grep  '^\ *' <<< $vendor )" ]; then
			hdd_vendor="Unknown vendor"
		fi


		#######
		# Model
		if  [ "${udev_info}" ]; then
			hdd_model="$(udevinfo -q all -n ${dev_scan} | grep -i model | \
			             awk -F= {'print $NF'})"

		elif [ -e "${proc_info}" ]; then
			hdd_model="$(cat ${proc_info}/model)"

		elif [ "$(type -p hdparm)" ]; then
			hdd_model="$(hdparm -i ${dev_scan} | grep -Eio 'Model=\w+' | \
			             awk -F= {'print $2'})"

		fi


		###############
		# Serial number
		if  [ "${udev_info}" ]; then
			hdd_serial="$(grep SERIAL ${udev_info} | awk -F= {'print $NF'})"

		elif [ "$(type -p hdparm)" ]; then
			hdd_serial="$(hdparm -i ${dev_scan} | grep -Eio 'serialno=\w+' | \
			              awk -F= {'print $2'})"
		fi


		########
		# Driver
		if [ -e "/proc/ide/${dev_scannode}" ]; then
			hdd_driver="$(cat ${proc_info}/driver)"
		fi


		############
		# DMA STATUS
		if [ "$(type -p hdparm)" ]; then
			hdd_dma="$(hdparm ${dev_scan} | grep dma | grep -Eo '\([onf]+\)' | \
			           sed 's/(\|)//g')"
		fi


		#############################
		# scan for SMART attributes
		if [ "$(type -p smartctl)" ]; then
			scan_hdd_smart ${dev_scan} ata
		fi
	}


	#################
	# SATA/SCSI/USB drives (sg driver)
	#
	# this function collects information of SATA/SCSI/USB drives,
	# because under Linux they all use the same SCSI drivers.
	#
	# the information in stored into two or three locations, depending
	# on the kernel and whether the system uses devfs or udev.
	# since devfs is deprecated, it is not used at all.
	# the /proc/scsi/ system is deprecated from 2.6 on, but it is left
	# here for legacy support.
	#
	# usb drives, when properly detected by the Linux kernel,
	# are added to /proc/scsi/scsi info sheet, and the assigned scsi number
	# which can be found both in the beforementioned location and also
	# in /proc/scsi/sg/devices, can be used to identify the device
	# in /proc/scsi/usb-storage/*.
	#
	# as the devices are (hopefully) linearily, the devices catalogue
	# can be used to identify which /dev/sd* node is a certain scsi#.
	#
	# this is not true in the case of custom udev rules. although
	# a good practise is to let kernel do its magic and create a
	# link node to that device, so this is unlikely to be a problem.
	#
	# smartmontools support SATA drives from version 5.36 on
	# (released April 2006). this function is written in June 2006,
	# and for that the version of smartctl is checked before trying
	# to access SATA drives.
	#
	# Parameters:
	#  (1) drive device
	#  (2) drive node in the /dev/ tree
	#  (3) the node number in the bus
	#
	scan_hdd_sata() {
		local dev_scan="${1}" dev_scannode="${2}" dev_nodenr="${3}"

		# detect the available data sources
		if [ "$(type -p udevinfo)" ]; then
			# allocate a temp file
			local udev_info="$(mktemp /tmp/osinfo.XXXXXX)"
			TempFiles=("${TempFiles[@]}" "$udev_info")
			udevinfo -q all -n ${dev_scan} > ${udev_info}
		fi
		if [ -e "/proc/scsi/" ]; then
			local proc_info="/proc/scsi/scsi"
			local scsi_devices="/proc/scsi/sg/devices"
			local scsi_devstrings="/proc/scsi/sg/device_strs"
			local usb_devstrings="/proc/scsi/usb-storage/"
			local sg_version="/proc/scsi/sg/version"
			local scsi_nr="$(sed -n "$dev_nodenr{p;q;}" ${scsi_devices} | \
			                 awk {'print $1'})"
		fi
		# hdparm output is not read into a temp file, as
		# it is unlikely to be used, and that would unnecessarily
		# slow down this function.

		if [ "${udev_info}" ]; then

			local bus="$(grep -i ID_BUS ${udev_info} | awk -F= {'print $NF'})"
			if [ "$(grep usb <<< $bus)" ]; then		# USB drive detected

				hdd_type='USB drive'

			else
				hdd_type='SATA/SCSI drive'
			fi

		# test if the scsi_nr is found in /proc/scsi/usb-storage/
		elif [ -e "${proc_info}" ]; then

			if [ -e "${usb_devstrings}${scsi_nr}" ]; then
				local usb_info="${usb_devstrings}/${scsi_nr}"
				hdd_type='USB drive'
			fi

		else	# no udev and no /proc/scsi. odd.

			hdd_type='SATA/SCSI drive'

		fi

		########
		# Vendor
		if [ "$smart" = "sata-ok" ]; then

			# because smartctl uses its own database to report the HDD vendor,
			# it is preferred over udev.
			#
			# this smart scan is not included into the scan_hdd_smart()
			# because it would break the correct order of the report.

			hdd_vendor="$(smartctl -i -d ata ${dev_scan} | grep '^Model' | \
			              awk -F: {'print $2'} | sed 's/^ *//') "

		elif [ "${udev_info}" ]; then

			hdd_vendor="$(grep -i vendor ${udev_info}  | \
			              awk -F= {'print $NF'}) "

		elif [ -e "${proc_info}" ]; then

			hdd_vendor="$(sed -n "$dev_nodenr{p;q;}" "${scsi_devstrings}" | \
			              awk {'print $1'}) "
			              #"$(grep -i vendor ${usb_info} | awk -F': ' {'print $2'})"
		fi


		#######
		# Model
		if  [ "${udev_info}" ]; then

			hdd_model="$(grep -i model ${udev_info} | \
			             awk -F= {'print $NF'})"

		elif [ -e "${proc_info}" ]; then

			hdd_model="$(sed -n "$dev_nodenr{p;q;}" "${scsi_devstrings}" | \
			             awk {'print $2" "$3'})"

		elif [ "$(type -p hdparm)" ]; then

			hdd_model="$(hdparm -i ${dev_scan} | grep -Eio 'Model=\w+' | \
			             awk -F= {'print $2'})"
		fi


		###############
		# Serial number
		if  [ "${udev_info}" ]; then

			hdd_serial="$(grep SERIAL ${udev_info} | awk -F= {'print $NF'})"

		elif [ "$(type -p hdparm)" ]; then

			hdd_serial="$(hdparm -i ${dev_scan} | grep -Eio 'serialno=\w+' | \
			              awk -F= {'print $2'})"
		fi


		########
		# Driver
		if [ -e "${proc_info}" ]; then
			hdd_driver="Linux SCSI Generic (sg) v.$(cat ${sg_version})"
		fi


		#TODO: dma status


		#############################
		# check the smartctl version >5.36
		if [ "$(type -p smartctl)" ]; then
			local smartctl_version="$(smartctl --version | \
				grep -Eo 'version [0-9.]+' | grep -Eo '[0-9]\.[0-9]+')";
			diff="$(bc -s <<< $smartctl_version-5.36 )"
			# check if the difference is (not) negative
			if [ ! "${diff:0:1}" = "-" ]; then
			# this is a newer version which supports SATA
			# scan for SMART attributes
				scan_hdd_smart ${dev_scan} ata
			fi
		fi
	}


	#######################
	# SOFTWARE RAID ARRAYS
	#
	scan_hdd_raid() {
		info	"todo"
	}


	#######################
	# LVM PARTITIONS
	#
	scan_hdd_lvm() {

		local volgroups volgroup

		# get lvm groups with vgscan
		volgroups="$(vgscan | grep -i found | \
		             grep -Eo '\"[a-zA-Z0-9]+\"' | sed 's/\"//g')"

		if [ "$volgroups" != "" ]; then

			lvm_full_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
			lvm_group_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
			TempFiles=("${TempFiles[@]}" "$lvm_full_tmp" "$lvm_group_tmp" )

			vgdisplay -v 2>/dev/null > $lvm_full_tmp

			#add_attribute	"Volume groups" "volume_groups"

			for volgroup in $volgroups; do

				extr_node 'Volume group' $lvm_full_tmp > $lvm_group_tmp

				add_header	$volgroup  "logical volume"

				add_attribute    'Format' "format"
				add_values       "$(grep -i format $lvm_group_tmp | awk {'print $2'})"

				add_attribute    'Physical volume'
				add_values       "$(grep -i 'PV name' $lvm_group_tmp | awk {'print $3'})"

				add_attribute    'VG size'
				add_attribute    'PE size'


			done

		fi
	}

###### END OF HDD SUBFUNCTIONS #############

# fake module that calls the hdd subfunction
Module_lvm () {
	local moduleName="Logical Volumes"
	module_header "${moduleName}"

	if CheckReq_root; then
		scan_hdd_lvm
	fi

	flush_values
}


######################
# IDE bus
#
Module_ide () {
	module_header "IDE bus"

		if [ "$(grep ide0 /proc/devices)" ]; then
			add_attribute "IDE 0:0"
			add_values    "$(cat /sys/devices/ide0/0.0/media)"
			add_attribute "IDE 0:1"
			add_values    "$(cat /sys/devices/ide0/0.1/media)"
		fi
		if [ "$(grep ide1 /proc/devices)" ]; then
			add_attribute "IDE 1:0"
			add_values    "$(cat /sys/devices/ide1/0.0/media)"
			add_attribute "IDE 0:0"
			add_values    "$(cat /sys/devices/ide1/0.1/media)"
		fi

	flush_values
}

#######################
# MEMORY
#
# this module tells complete information of the memory
# installed on the system.
#
# only RAM at the moment and the solution is really dirty because
# it uses lshw. 'free' and '/proc/meminfo' would also report
# free RAM, but slightly incorrect number because it's the total
# ram after kernel has allocated some for system services.
#
# requires root access
#
# TODO: add support for memory type/speed detection thru lshw
Module_memory() {
	local moduleName="System memory"
	module_header "${moduleName}"
	local ram_size

	if CheckReq_lshw && CheckReq_root; then

		mem_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		TempFiles=("${TempFiles[@]}" "$mem_tmp" )

		# meminfo or free don't give a proper value, so we use lshw
		# meminfo="/proc/meminfo"

		lshw_xml
		extr_node "node id=\"memory" $lshw_xml_file /node > $mem_tmp

		ram_size="$(grep size ${mem_tmp} | head -n 1 | grep -Eo '[0-9]+')"
		ram_size="$(bc -l <<< scale=1\;$ram_size/1024/1024)"

		add_attribute     'Total size'	'ram'
		add_values        "$ram_size"
		add_value_footer  "MB"

	fi

	flush_values
}


##################
# CD/DVD DEVICES
Module_cdrom() {
	local moduleName="CD/DVD drives"
	module_header "${moduleName}"

	if CheckReq_lshw && CheckReq_root; then
		cdrom_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		cdrom_tmp2="$(mktemp /tmp/osinfo.XXXXXX)"
		udev_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		TempFiles=("${TempFiles[@]}" "$cdrom_tmp" "$cdrom_tmp2" "$udev_tmp")

		lshw_xml
		if [ "$(grep -i cdrom $lshw_xml_file)" ]; then
			extr_node 'node id="cdrom' $lshw_xml_file /node > $cdrom_tmp

			#for debugging:
			#extr_node 'node id="cdrom' debug/lshw-platon /node > $cdrom_tmp
			#cat $cdrom_tmp

			# extr_node echoes back all the cdrom drives in the system,
			# let's see how many
			local cdrom_count="$(grep 'node id="cdrom' $cdrom_tmp | wc -l)"

			for drv_nr in $(seq 1 1 $cdrom_count); do

				# collect information

				if [ $drv_nr -lt $cdrom_count ]; then

					sed -n "/%node $drv_nr%/,/%node $(($drv_nr+1))%/{p;}" \
					    $cdrom_tmp > $cdrom_tmp2

					# KEEP THESE for testing times on ubuntu
					#local this_node="$(grep -n "%node $drv_nr%" $cdrom_tmp | \
					#	awk -F: {'print $1'})"
					#local next_node="$(grep -n "%node $(($drv_nr+1))%" $cdrom_tmp | \
					#	awk -F: {'print $1'})"
					#sed -n "$this_node,$next_node{p;}" $cdrom_tmp > $cdrom_tmp2

				else

					sed -n "/%node $drv_nr%/,\${p;}" $cdrom_tmp > $cdrom_tmp2

					#local this_node="$(grep -n "%node $drv_nr%" $cdrom_tmp | \
					#	awk -F: {'print $1'})"
					#sed -n "$this_node,\${p;}" $cdrom_tmp > $cdrom_tmp2

				fi

				cdrom_model[$drv_nr]="$(grep -i product $cdrom_tmp2  | \
				                        sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"

				cdrom_type[$drv_nr]="$(grep -i descr ${cdrom_tmp2} | \
				                       sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"

				cdrom_serial[$drv_nr]="$(grep -i serial ${cdrom_tmp2} | \
				                         sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"

				cdrom_node[$drv_nr]="$(grep -i 'logicalname' ${cdrom_tmp2} | \
				                       sed 's/[^>]*>\([^<]*\)<[^.]*/\1/' | head -n 1)"
				                       # sometimes there's a 'disc' node with a second
				                       # logicalname node, which is the same as the first

				cdrom_bus[$drv_nr]="$(grep -i businfo ${cdrom_tmp2} | \
				                      sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"

				#udevinfo -q all -n "${cdrom_node[$drv_nr]}" > ${udev_tmp}

				#cat $cdrom_tmp

				# display

				if [ $lanforce -eq 1 ]; then

					# print attribute only once
					[ $drv_nr -eq 1 ] && add_attribute 'Model'	'cdrom'
					add_values    "${cdrom_model[$drv_nr]}"

				else

					add_header  "CD/DVD drive $drv_nr" "cd_drive"

					add_attribute 'Model'	'cdrom'
					add_values    "${cdrom_model[$drv_nr]}"

					add_attribute 'Drive type'
					add_values    "${cdrom_type[$drv_nr]}"

					add_attribute 'Serial number'
					add_values    "${cdrom_serial[$drv_nr]}"

					add_attribute 'Physical bus'
					add_values    "${cdrom_bus[$drv_nr]}"

					add_attribute 'Device node'
					add_values    "${cdrom_node[$drv_nr]}"

					add_attribute 'Capabilities'
					#add_values    "$(grep -i capabilities ${cdrom_tmp})" #| \
									#sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"
					# dvd-r, dvd+r, DL, etc...
					# generally grep cd|dvd
					# debug with debug/lshw-dvdwriter

					add_footer "cd_drive"

				fi
			done

		else
			info    'No cdrom drives detected'
		fi
	fi

	##module_footer
	flush_values
}


#######################
# DMI / OEM INFORMATION
#
# this module works as a replacement for module_oem. this is faster,
# as it doesn't scan hardware. look below for excerpt from 'man dmidecode':
#
# dmidecode  is  a  tool  for dumping a computer's DMI (some say SMBIOS) table
# contents in a human-readable format.
# This table contains a description of the system's hardware components,
# as well as other useful pieces of information  such  as  serial
# numbers and BIOS revision. Thanks to this table, you can retrieve this
# information without having to probe for the actual hardware.  While this
# is a good point in terms of report speed and safeness,  this also makes
# the presented information possibly unreliable.
Module_dmi() {
	local moduleName="DMI information"
	module_header "${moduleName}"

	if CheckReq_dmidecode && CheckReq_root; then
		# allocate the temp files
		dmi_info="$(mktemp /tmp/osinfo.XXXXXX)"
		dmi_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		dmidecode > "$dmi_info"
		TempFiles=("${TempFiles[@]}" "$dmi_info" "$dmi_tmp")

		# the interesting handles:
		# 0x0000 or 0x0001 = 'BIOS Information'
		# 0x0001 or 0x0002 = 'System Information'
		# 0x0002 or 0x0003 = 'Base Board Information'
		# 0x0003 or 0x0004 = 'Chassis Information'
		# 0x0004 or 0x0005 = 'Processor Information'
		# .... and more

		local HANDLES="BIOS information,System information,Base Board information,Chassis information"

		# the following loop extracts the data under the nodes variable.

		# (1) get the line number where the description occurs
		# (2) get the line number of the next 'node id'
		# (3) everything in between those lines contains interesting data


		# IFS need to be changed because the values are separated by newline
		local IFS_bak="$IFS" value
		IFS=$','

		for handle_desc in ${HANDLES}; do

			#handle_desc="$(sed s/^[^a-zA-Z]*// <<< $handle_desc)"

			# get the handle number (0x000#)
			# -B 5 is defined because sometimes there's some extra
			# information between the Handle_nr and the description.
#			handle_nr="$(grep -in ${handle_desc} ${dmi_info} -B 5 | \
#			             grep -Eo '0x[0-9]{4}')"
#			this="$(grep -in "Handle ${handle_nr}" ${dmi_info}  | \
#			        awk -F: {'print $1'})"
#			next="$(grep -n 'Handle' ${dmi_info} | grep -A 1 ${handle_nr} | \
#			        awk -F: {'print $1'} | sed -n "2{p;q}")"
#			((this++))
#			((next--)) # this prevents the 'handle' lines from printing
#
#			# use a temp file to store handle information
#
#			sed -n "$this,$next{p;}" ${dmi_info} > ${dmi_tmp}
#			#cat $dmi_tmp

			# extract the handle and string the first line
			# (%node% identifier that is useless here)
			extr_node ${handle_desc} ${dmi_info} Handle | \
				sed -n "2,\${p}" > ${dmi_tmp}

			# because sometimes there's some extra info, head -n 5
			# TODO: combine grep and sed
			local handleID="$(head -n 5 ${dmi_tmp} | grep -i ${handle_desc} | \
				sed 's/^[^a-zA-Z]//')"

			# here the data is processed
			case $handleID in
				"System Information")

					add_header  "System info"

					add_attribute 'Manufacturer' \
					              'system_manufacturer'
					add_values    "$(grep -i manufacturer ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Model'	'system_model'
					add_values    "$(grep -i product ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Version number'
					add_values    "$(grep -i version ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'OEM serial number' \
					              'computer_product_serial'
					add_values    "$(grep -i serial ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'UUID' 	'uuid'
					add_values    "$(grep -i uuid ${dmi_tmp} | \
					                 awk -F: {'print $2'})"

					add_footer
					;;

				"Base Board Information")

					add_header    "Motherboard"

					add_attribute 'Manufacturer' \
					              'mother_board_manufacturer'
					add_values    "$(grep -i manufacturer ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Model' \
					              'mother_board_model'
					add_values    "$(grep -i product ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Version' \
					              'mother_board_version'
					add_values    "$(grep -i version ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Serial number' \
					              'mother_board_serial_number'
					add_values    "$(grep -i serial ${dmi_tmp} | \
					                 awk -F: {'print $2'})"

					add_footer
					;;

				"BIOS Information")

					add_header    "BIOS"

					add_attribute 'Vendor'
					add_values    "$(grep -i vendor ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Revision'	'bios_version'
					add_values    "$(grep -i version ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Date'	'bios_date'
					add_values    "$(grep -i date ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Serial number'	'bios_serial_number'
					add_values    "$(grep -i serial ${dmi_tmp} | \
					                 awk -F: {'print $2'})"

					add_footer
					;;


				"Chassis Information")	# Chassis Information

					add_header    'Chassis'

					add_attribute 'Manufacturer' 	'chassis_manufacturer'
					add_values    "$(grep -i manufacturer ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Type' 	'chassis_type'
					add_values    "$(grep -i type ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Version' 	'chassis_version'
					add_values    "$(grep -i version ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Serial number' \
					              'chassis_serial_number'
					add_values    "$(grep -i serial ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Lock' 	'chassis_lock'
					add_values    "$(grep -i lock ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute 'Asset tag' 'chassis_asset_tag'
					add_values    "$(grep -i asset ${dmi_tmp} | \
					                 awk -F: {'print $2'})"

					add_footer
					;;

			esac

		done

		IFS="$IFS_bak"

	fi

	flush_values
}


# GENERAL INFORMATION OF THE SYSTEM
Module_system() {
	local moduleName="System"
	module_header "${moduleName}"

	add_attribute "Operating system"		"os"
	case $SYSTEM in
		'Linux'|'linux')
			[ ! "$distro_id" ] && identify_Linux_distro
			add_values      "$distro_id $(uname -s) $distro_release"
		;;

		'FreeBSD'|'freebsd')
			add_values      "$SYSTEM"
		;;
	esac

	add_attribute "Operating system kernel"	"os_build"
	add_values    "$(uname -sr)"

	#add_attribute "System encoding"
	# this is probably incorrect. determines the default output encoding
	# of the echo command.
	#add_values    "$(echo Ã¤ | file - | awk -F': ' {'print $2'})"

	add_attribute "System uptime"			"uptime"
	add_values    "$(uptime | awk -F, {'print $1'} | \
	                 grep -Eo 'up [a-z0-9: ]*' | sed 's/^[up ]*//')"

	if CheckReq_sensors; then
		add_attribute "M/B temperature"
		local mobo_temp="$(sensors | grep -i 'cpu temp' | \
		                   grep -Eo '\+[0-9]*[[:punct:]]?[CF]+')"
		add_values       "$(awk -F'+' {'print $2'} <<< $mobo_temp)\n "
		#add_value_footer "C"
	fi

	flush_values
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}


# OPERATING SYSTEM KERNEL
Module_kernel() {
	local moduleName="Kernel"
	module_header "${moduleName}"

	local kernel_makefile

	add_attribute "Kernel name"
	add_values    "$(uname -o)"

	add_attribute "Kernel release"		'os_build' #FIXME
	add_values    "$(uname -r)"

	add_attribute "Kernel version"
	add_values    "$(uname -v)"

	# Unique kernel name
	if [ -e "/usr/src/linux" ]; then
		kernel_makefile="/usr/src/linux/Makefile"
	elif [ "$(ls /usr/src/linux* 2> /dev/null)" ]; then
		kernel_makefile="/usr/src/linux*/Makefile"
	fi
	if [ -e "${kernel_makefile}" ]; then
		add_attribute "Kernel name"
		add_values    "$(head ${kernel_makefile} | grep NAME | \
		                 head -n 1 | awk -F= {'print $2'})"
	fi

	flush_values
	# HACK: As syntax highlighting seems broken in my editor I add this comment hack as a workaround: "
}


# INFORMATION OF THE CPU
#
# uses /proc/cpuinfo (Linux only)
# and x86info (optional)
Module_processor() {
	local moduleName="Processor"
	module_header "${moduleName}"

	local cpunr

	local cpuinfo="/proc/cpuinfo"
	local cpu_count="$(grep 'processor' ${cpuinfo} | wc -l)"

	# test if /proc/cpuinfo gives a number for cpu cores.
	# if it is does not, the kernel probebly lacks SMP support so assume 1 cpu.
	if [ ! "$cpu_count" ]; then
		cpu_count=1
	fi

	if [ "$usexml" == 1 ]; then
		add_attribute "Count"      "processor_count"
		add_values    $cpu_count
	fi

	for cpunr in $(seq 1 1 $cpu_count); do
		[ $cpu_count -gt 1 ] && add_header	"CPU $cpunr"

		add_attribute     "Vendor"		"processor_vendor"
		add_values        "$(grep 'vendor' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
		                     awk -F': ' {'print $2'})"

		add_attribute     "Model"			"processor_model"
		add_values        "$(grep 'model name' ${cpuinfo} | \
		                     sed -n "$cpunr{p;q}" | awk -F': ' {'print $2'})"

		add_attribute     "Frequency"		"processor_speed"
		add_values        "$(grep 'cpu MHz' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
		                     awk -F': ' {'print $2'})"
		add_value_footer  "MHz"

		add_attribute     "Architecture"	"system_type"
		add_values        "$(uname -m)"

		# temperature and voltage info
		if CheckReq_sensors; then
			add_attribute   "Temperature"
			local cpu_temp="$(sensors | grep -i 'cpu temp' | \
			                  grep -Eo '[0-9\.]+[[:punct:]]?[CF]+')"
			add_values       "$(awk  {'print $1'} <<< $cpu_temp )"

			add_attribute   "Fan"
			local cpu_fan="$(sensors | grep -i 'cpu fan' | \
			                  grep -Eo '[0-9]+ RPM')"
			add_values       "$(awk  {'print $1'} <<< $cpu_fan )"
			add_value_footer "RPM"

			add_attribute   "Voltage"
			local voltage="$(sensors | grep -i 'vcore' | \
			                 grep -Eo '\+[0-9. ]*')"
			add_values       "$(awk  {'print $2'} <<< $voltage)"
			add_value_footer "V"
		fi

		add_attribute      "Cache"
				local cache_size="$(grep 'cache' ${cpuinfo} | sed -n "$cpunr{p;q}" )"
				add_values       "$(grep -Eo '[0-9]+' <<< $cache_size)"
				add_value_footer "$(awk {'print $NF'} <<< $cache_size)"

		add_attribute     "Stepping"
		add_values        "$(grep 'stepping' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
		                     awk -F': ' {'print $2'})"

		[ $cpu_count -gt 1 ] &&	add_footer
	done

	flush_values
}


# INFORMATION OF THE TERMINAL IN USE
Module_terminal() {
	local moduleName="Terminal info"
	module_header "${moduleName}"

	add_attribute "Terminal type"
	add_values    "$TERM"

	# TODO
	add_attribute "Terminal encoding"
	add_values    "?"

	add_attribute "Terminal speed"
	add_values    "$(stty speed)"

	add_attribute "Rows"
	add_values    "$(stty size | awk '{print $1}')"

	add_attribute "Columns"
	add_values    "$(stty size | awk '{print $2}')"

	#module_footer
	flush_values
}


#######################
# PRINTERS AVAILABLE TO THE SYSTEM

# EXPERIMENTAL!

# uses only lpstat (cups) and hasn't been tested on multi-printer
# environments
#
# TODO: add some kind of timeout function
Module_printers() {
	local moduleName="Printers"
	module_header "${moduleName}"

	local lp_nr

	# first of all, check if lpstat is available
	if [ "$(type -p lpstat)" ]; then

		#  if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then

		add_attribute 	'Printer'	'local_printer'

		# as there may be several printers, print info from all
		#for lp_nr in $(seq 1 1 $(lpstat -a | wc -l) ); do
		#	add_values  "$(lpstat -a 2> /dev/null | sed -n "$lp_nr{p;q;}")"
		#done

		add_attribute	'model'
		add_attribute	'location'
		add_attribute	'server'
		add_attribute	'spooler'
		add_attribute	'status'
		add_attribute	'completed jobs'

	fi

	#module_footer
	flush_values
}


#######################
# USERS
#
# reports the current user, the user's X11 session manager + shell
# the last logged user, and other users that have logged in
# (that last can see).
Module_users() {
	local moduleName="Users"
	module_header "${moduleName}"

	local last_login login_count user user_fullname
	local wtmp_file="/var/log/wtmp"

	### CURRENT USER (ACTIVE UID)
	add_header   "Current user"

		add_attribute  'Real name'				"real_name"
		add_values     "$(awk -F: /$(whoami)/{'print $5'} /etc/passwd)"

		add_attribute  "Unix name / UID"				'active_user'
		add_values     "$(whoami) ($(id -u))"

		add_attribute  'Groups'
		local group
		for group in $(groups | sed 's/ /\n/g' | uniq); do
			add_values "$group\n " # << note that for indentation, the
			                       # space at the end of string is important!
		done

		#add_attribute  "User's X11 session"	"users_window_manager"
		# KDE sometimes sets $DESKTOP_SESSION nicely, Gnome doesn't.
		# AnMaster: KDE doesn't set that for me (in konsole at least)
		# ruxpin: I get this in konsole: DESKTOP_SESSION="kde-7.0"
		# any ideas where else to look?
		#local session_id="$DESKTOP_SESSION"
		#if [ "$session_id" == "default" ]; then
		#	if [ "$GNOME_DESKTOP_SESSION_ID" ]; then
		#		# try to get Gnome version
		#		local gnome_version="$(gnome-about --version | awk {'print $NF'})"
		#		session_id="Gnome $gnome_version"
		#	fi
		#fi
		#add_values     "$session_id"

		add_attribute  "User's shell"
		add_values     "$SHELL"

		add_attribute  "User's locale"
		add_values     "$LC_ALL"

	add_footer

	### LAST LOGGED IN USER
	add_header     "\nLast logged in user"

		last_login="$(last -1 | head -n 1 | awk {'print $1'})"

		add_attribute  "Unix name"    'last_logged_user'
		add_values     "$last_login"

		add_attribute  'Real name'    'last_logged_real_name'
		add_values     "$(awk -F: /$last_login/{'print $5'} /etc/passwd)"

		add_attribute  'Login date'
		add_values     "$(date -d "$(last -1 | head -n 1  | \
                                  grep -Eo '[a-Z]{3} [a-Z]{3} [0-9]{2} [0-9:]*')" \
		                  +"%Y-%m-%d %T")"

	add_footer


	### ALL USERS
	if [ $lanforce = 1 ]; then
		add_attribute 'All logged in users' "users"
	elif [ $usexml = 1 ]; then
		add_header    'All users'
	else
		add_header	'' # NOTE: this header is for printing a newline
		                   # before the next header, due to the column bug
		add_nc_header   "All users%col%last login%col%login count\n"
		add_nc_header   "---------%col%----------%col%-----------\n"

	fi

	if [ ! -e ${wtmp_file} ]; then
		info	"${wtmp_file} does not exist. Cannot parse data."
	else

		fake_users="reboot\|wtmp\|ftp"
		local users="$(last | awk {'print $1'} | sort | uniq | \
		               grep -v "$fake_users" | grep '^[a-zA-Z]')"
		               # ^^ removes fake users

		for user in $users; do

			# get the full username (user_fullname)
			#
			# because 'last' command, part of the sysvinit core package,
			# interprets the binary file /var/log/wtmp, but chomps off
			# the loginname at 8 characters, we need to find the full names
			# from the source file. for node ina dirty hack but may well be the only way...
			if [ ${#user} -ge 8 ]; then
				# parse special chars to meta-chars
				user_fullname="$(sed 's/[[:punct:]]/\\&/g' <<< $user)"
				user_fullname="$(grep -Eoa "$user_fullname[a-zA-Z0-9\\\+]*" \
				                 ${wtmp_file} | uniq)"
			else
				user_fullname="$user"
			fi


			# get the last login date & time
			# FIXME: works always on the command line,
			# but NOT ALWAYS IN THE SCRIPT!??
			unset last_login
			last_login="$(date -d "$(last | grep -m 1 $user | \
			              grep -Eo '[a-zA-Z]{3} [a-zA-Z]{3}\ *[0-9]{1,2} [0-9:]{5}')" \
			              +"%Y-%m-%d %T")"


			# get the login count
			login_count="$(last | grep $user | wc -l)"


			# finally, output
			if [ $usexml -eq 1 ]; then
				add_values "$user_fullname  $last_login  $login_count"
			else
				add_values "$user_fullname"
				add_values "$last_login"
				add_values "$login_count\n"
			fi

		done
	fi

	flush_values
}


###########################
# SYSTEM SERVICES (daemons)

# http://linuxhelp.blogspot.com/2006/04/enabling-and-disabling-services-during_01.html

# Gentoo based:
#  rc-status

# Fedora, RedHat, Suse:
#  /sbin/service --status-all
#  chkconfig --list

# Ubuntu, Debian based:
#  sysv-init
#  'runlevel' gives to values: "previous current", grep on the current

# Slackware:
#	There is no sane way to get "running services" from Slackware
#	(at least last time I used Slackware: 9.0 I think).
#	to change what services are started you edit the bootscripts (written in bash).
#	(there are 7 or 8 IIRC, one for each runlevel, 1 for kernel modules to load,
#	1 for local and 1 for system startup)
Module_services() {
	local moduleName="Services"
	module_header "${moduleName}"

	local method

		# these functions handle scanning, they'll echo output
		if [ "$(type -p rc-status)" ]; then
			# Gentoo
			method='rc-status'
			local services="$(scan_services_rc-status)"

		elif [ "$(type -p sysv-rc-conf)" ]; then
			# Debian and Ubuntu, if they've got the package
			method='sysv-rc-conf'
			local services="$(scan_services_sysv)"

		elif [ "$(type -p chkconfig)" ]; then
			# Red Hat, Fedora Core, SuSE
			method='chkconfig'
			local services="$(scan_services_chkconfig)"
		fi


		# attribute only for lanfroce xml, nothing for std xml
		if [ $lanforce = 1 ]; then
			add_attribute 'Services'	'service'
		elif [ $usexml = 0 ]; then
			add_header  "$method"
		fi


		# then report what scan found
		local count=0 columns=5
		for srv in $services; do
			if [ $count -eq $columns ]; then
				add_values    "$srv\n "
				count=0
			else
				add_values    "$srv"
			fi

			((count++))
		done

		#value_footer


	#module_footer
	flush_values
}

#################################
### SERVICE MODULE SUBFUNCTIONS

	# this script is used on gentoo
	scan_services_rc-status() {

		echo $(rc-status | awk '/started/{print $1}' | sort)

	}

	# this works on debian-based systems
	scan_services_sysv() {

		local runlevel=$(runlevel | awk {'print $2'})

		echo $(sysv-rc-conf --list 2> /dev/null | \
		       awk '/'$runlevel'\:on/{print $1}' | sort)

	}

	scan_services_chkconfig() {

		# similar to sysv-rc-conf
		# works on rpm-based systems

		local runlevel=$(runlevel | awk {'print $2'})

		echo $(chkconfig --list 2> /dev/null | \
		       awk '/'$runlevel'\:on/{print $1}' | sort)

	}

#################################


##########
# NETWORK
#
# this module detects the network settings of the computer.
#
# there are at least two methods to pull in information; ifconfig and iproute2.
# ifconfig is used; there are at least two versions of ifconfig being used, and
# all tested Linuxes have used the same, whereas FreeBSD v6 had different
# output. the script should work on both versions.
#
# some changes have been made after testing with FreeBSD, so compitibility
# may not be 100% anymore.
Module_network() {
	local moduleName="Network information"
	module_header	"${moduleName}"

	local specials="UP|BROADCAST|LOOPBACK|NOARP|NOTRAILERS|RUNNING|MULTICAST"
	local nwfile

	# allocate a temp file
	local nw_info="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$nw_info")

	################################
	# DETECT (WIRED) NETWORK DEVICES
	# using ifconfig
	#
	# detect the type of OS. all ifconfigs in tested Linuxes operate
	# more of less similarity, but the one on FreeBSD 6.0 is different.
	if [ "$(type -p ifconfig)" ]; then
		nw_src="ifconfig"

		if [ "$SYSTEM" == "linux" ] ; then
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST -B 3 | \
			grep -Ev '(^ )|(^--)|LOOPBACK' | awk  {'print $1'})"

		else # *BSD ifconfig
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST | grep -v LOOPBACK | \
			awk -F': ' {'print $1'})"
		fi
	fi


	### generic information
	add_header  "$(hostname 2> /dev/null)"

		add_attribute 'NIS domain'
		add_values    "$(hostname -y 2> /dev/null)"
		# hostname produces stderr if no network is available

		add_attribute 'DNS domain'	'domain'
		add_values    "$(hostname -d 2> /dev/null)"

		add_attribute 'FQDN'		"fully_qualified_domain_name"
		add_values    "$(hostname -f 2> /dev/null)"

		local ipv4 ipv6

		# collect the information from detected network devices
		for interface_name in $ETH_DEVICES; do
			ifconfig $interface_name > ${nw_info}

			add_header    $interface_name   'iface'

			add_attribute 'MAC'		"mac_address"
			add_values    "$(grep -Eo '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}' ${nw_info})"


			add_attribute 'IPv4'		"ip_address"
			ipv4="$(grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' ${nw_info} | \
			        grep -Eo '[0-9\.]+' )"
			add_values    "$ipv4"

			add_attribute 'IPv6'
			ipv6="$(sed "s/  /\n/g" ${nw_info} | grep -i inet6 | \
			        grep -Eio '([0-9a-f]{3,4}(\:){1,2}){4,8}([0-9a-f]{3,4})' )"
			add_values    "$ipv6"

			add_attribute 'IP type'	"ip_type"
			add_values    "$(detect_ip_type)"

			add_attribute 'Gateway'	"default_gateway"
			add_values    "$(route -n | grep $interface_name | \
			              awk '/^0.0.0.0/{print $2}')"

			add_attribute 'Broadcast'
			add_values    "$(sed "s/  /\n/g" ${nw_info} | \
			                 grep -Eio 'cast[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | \
			                 grep -Eo '[0-9\.]+' )"

			add_attribute 'Netmask'	"subnet_mask"
			add_values    "$(sed "s/  /\n/g" ${nw_info} | \
			                 grep -Eio 'mask[A-Za-z: ]*((([0-9]{1,3}\.){3}[0-9]{1,3})|(0x[0-f]{8}))' | \
			                 grep -Eo '[0-9\.fx]+' )"

			add_attribute 'RX bytes'
			add_values    "$(sed "s/  /\n/g" ${nw_info} | \
			                 grep -i 'RX bytes' | awk -F: {'print $2'})"

			add_attribute 'TX bytes'
			add_values    "$(sed "s/  /\n/g" ${nw_info} | \
			                 grep -i 'TX bytes' | awk -F: {'print $2'})"

			add_footer    "iface"
		done

	flush_values
}

### network helper functions

	# detects the ip type (static or dynamic) based on some common
	# configuration files. works on Debian, Ubuntu and Gentoo.
	function detect_ip_type () {
			local nw_conf_files="/etc/network/interfaces
			                     /etc/conf.d/net"
			for nwfile in $nw_conf_files; do
				if [ -e $nwfile ]; then

					# grep for the word 'dhcp' and the iface name in the config file
					if [ "$(grep -v ^# $nwfile | grep $interface_name | grep -i dhcp)" ]; then
						echo    'DHCP'

					# grep for the word 'static' or the ip address and the iface
					elif [ "$(grep -v ^# $nwfile | grep $interface_name | \
					          grep -i "static\|$ipv4\|$ipv6")" ]; then
						echo    'static'

					else # give up
						echo    'undetermined'
					fi
				fi
			done
	}



###################################################
# MODULE WLAN
#
# detects wireless network access points
#
# uses wireless-tools (iwconfig, iwlist)
# Linux only
#
# under developement, does not yet work!
Module_wlan() {
	local moduleName="Wlan information"
	module_header	"${moduleName}"

	iw_src="$(mktemp /tmp/osinfo.XXXXXX)"
	ap_src="$(mktemp /tmp/osinfo.XXXXXX)"
	cell_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$iw_src" "$ap_src" "$cell_tmp")
	#TempFiles=("${TempFiles[@]}" "$cell_tmp")

	if [ ! "$(type -p iwconfig)" ]; then

		info "No wireless extensions found"

	elif [ "$SYSTEM" == "linux" ] ; then

		# get the basic info
		iwconfig 2>/dev/null > $iw_src
		local wlan_devices="$(grep 'IEEE 802' ${iw_src} | awk  {'print $1'})"
		iwlist $wlan_devices scan 2> /dev/null > $ap_src


		# for debugging purposes
		if [ "$fake" == 1 ]; then
			iw_src="debug/wlan-iwconfig-on"
			wlan_devices="eth1"
			ap_src="debug/wlan-stations"
		fi

		local ap_count="$(grep -i cell $ap_src | wc -l)"

		# print status
		if [ "$ap_count" -ge 1 ]; then
			info "$ap_count access points found by device $wlan_devices"
		else
			info "No access points found by device $wlan_devices"
		fi

		# process all access points
		IFS_bak="$IFS"
		IFS=$'\n'

		for access_point in $(grep -i cell ${ap_src}); do

			# this functions extracts each cell into a temp file
			extr_node $access_point $ap_src Cell > $cell_tmp

			add_header    "$(awk -F: '/ESSID/ {print $2}' $cell_tmp | sed 's/\"//g')"

			if [ $accociated ]; then
				#access_points[${access_points[@]}]="$(grep -A 1 -i ${access_point}" \
				#awk -F: '/ESSID/ {print $2}' | sed 's/\"//g' )"


				#add_attribute   'associated ESSID'
				#add_header    "$(grep -Eo 'ESSID[:"A-Za-z/ ]*' "${iw_src}" | \
				#                awk -F: {'print $2'})"

				add_attribute   'device node'
				add_values      "$(grep -Eo '^[a-z0-9]'+ ${iw_src})"
								# the device associated to this AP

				add_attribute   'device'
				#add_values     "some_device_from_mod_devices"
			fi

			add_attribute   'link quality'
			add_values      "$(grep -Eo 'Quality[\=:][a-zA-Z0-9\/]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"
			add_attribute   'address'
			add_values      "$(awk -F"Address:" '{print $2}' $cell_tmp | sed 's/^\ *//')"

			add_attribute   'channel'
			add_values      "$(grep -Eo 'Channel[\=:][a-zA-Z0-9]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"

			add_attribute   'frequency'
			add_attribute   'bit rate'

			add_attribute   'protocol'
			add_values      "$(grep -Eo 'Protocol[\=:][a-zA-Z0-9. ]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"

			add_attribute   'mode'
			add_values      "$(grep -Eo 'Mode[\=:][a-zA-Z]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"

			add_attribute   'encryption key'
			add_values      "$(grep -Eo 'Encryption key[\=:][a-zA-Z]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"
			add_attribute   'encryption type'

			add_attribute   'security mode'

			add_attribute   'signal level'
			add_values      "$(grep -Eo 'Signal level[\=:][-a-zA-Z0-9\/ ]+' $cell_tmp | \
			                   awk -F"=|:" '{print $2}')"


			#value_footer

		done

		IFS="$IFS_bak"

	fi

	#module_footer
	flush_values
}


#######################
# DISTRIBUTION
#
# this module will try to guess which Linux distrobution is installed.
Module_distro() {
	local moduleName="Distribution"
	module_header "${moduleName}"

	# NOTE: do not make distro_* variables local, as they might be used
	# in other modules



	# then call the subfunction
	identify_Linux_distro


	# then output what the was found..

	add_attribute 'Root dir'
	add_values    "$root_dir"

	[ "${distro_id}" ] && \
		add_attribute 'Distro ID'
		add_values    "${distro_id}"

	[ "${distro_release}" ] && \
		add_attribute 'Release'
		add_values    "$distro_release"

	[ "${distro_codename}" ] && \
		add_attribute 'Codename'
		add_values    "$distro_codename"

	[ "${distro_description}" ] && \
		add_attribute 'Description'
		add_values    "$distro_description"

	[ "$SlackwareBase" ] && \
		add_values  'Based on Slackware version' \
		            "$SlackwareBase"

	flush_values
}

## DISTRIBUTION SUBFUNCTIONS ##################################

##
# distro_lsb_release
#
# Gets data from lsb_release
# Parameters:
#  1  string   what value to get.
distro_lsb_release() {
	lsb_release -a 2> /dev/null | grep -i "^$1" | awk -F: '{print $2}' | sed -s 's/^\t*//'
}

###
# identify_Linux_distro
#
# the default tool to use is the lsb-release (Linux Standard Base
# version reporting utility)
#
# a secondary id source are the unique files in /etc/, and as a last
# resort the /etc/issue file. this makes it possible to identify
# a distro which resides in a chroot environment, or from a livecd.
identify_Linux_distro() {

	# locate and echo the root directory.
	# TODO: Some of this isn't actually needed as we allready fixed so there is at most one endning / (can be zero ending / too).
	[ "$prefix" != '/' ] && \
		local root_dir="$(echo $prefix | sed 's/\/*$//')" || \
		local root_dir="$prefix"
	[ "$root_dir" != '/' ] && root_dir="${root_dir}/"



	# look for lsb-release if real root is used.
	#set -x
	if [ "$(type -p lsb_release)" ] && [ "$prefix" == '/' ]; then

		distro_id="$(distro_lsb_release 'distributor')"
		distro_release="$(distro_lsb_release 'release')"
		distro_codename="$(distro_lsb_release 'codename')"
		distro_description="$(distro_lsb_release 'description')"

	else

		# Begin searching for distro identifying files
		local found_files="" myfile
		for myfile in ${root_dir}etc/{SuSE-release,fedora-release,redhat-release,slackware-version,Topologilinux-version,gentoo-release,issue}; do
			[ -e $myfile ] && found_files="$found_files $myfile"
		done

		# Now make a list of distros from the $found_files list above
		local found_distros="" distro_ident
		for distro_ident in $found_files; do
			case $distro_ident in
				"${root_dir}etc/SuSE-release")
					found_distros="$found_distros SuSE"
					break
					;;
				"${root_dir}etc/fedora-release")
					found_distros="$found_distros Fedora Core"
					break
					;;
				"${root_dir}etc/redhat-release")
					found_distros="$found_distros Red Hat"
					break
					;;
				"${root_dir}etc/slackware-version")
					found_distros="$found_distros Slackware"
					break
					;;
				"${root_dir}etc/Topologilinux-version")
					found_distros="$found_distros Topologilinux"
					break
					;;
				"${root_dir}etc/gentoo-release")
					found_distros="$found_distros Gentoo"
					break
					;;
				# if nothing previous matches, then use /etc/issue
				# AnMaster: Inform user that this might be very wrong...
				"${root_dir}etc/issue")
					found_distros="$found_distros misc"
					break
					;;
			esac
		done
		# Remove leading spaces.
		found_distros="$(sed 's/^ *//' <<< "${found_distros}")"


		# Get distro name
		# NOTE: have been changed to case-insensitive, although
		# has not been thoroughly tested. the commented code
		# may be removed after verifying the new code works.
		case "$(echo ${found_distros} | tr 'A-Z' 'a-z')" in
			'suse'|'fedora core'|'fedora'|'red hat'|'slackware'|'slackware topologilinux'|'gentoo'|'ubuntu')
			#'SuSE'|'Fedora Core'|'Fedora'|'Red Hat'|'Slackware'|'Slackware Topologilinux'|'Gentoo'|'Ubuntu')

				distro_id="${found_distros}"

				# clear spaces
				#[ "$found_distros" = 'Slackware Topologilinux' ] && \
				#	found_distros='Topologilinux'
				#[ "$found_distros" = 'Red Hat' ] && found_distros='RedHat'
				#[ "$found_distros" = 'Fedora Core' ] && found_distros='Fedora'
				;;

			'topologilinux')
				print_error 1 "This module will abort." "$usekdialog" \
					"Topologilinux is based on Slackware and should" \
					"contain ${root_dir}etc/slackware-version AND " \
					"${root_dir}etc/Topologilinux-version."
				return 1
				;;

			'misc')
				for misc_distro in 'Ubuntu' 'Fedora' 'SuSE'; do
					if [ "$(grep -i ${misc_distro} ${distro_ident})" ]; then
						distro_id="${misc_distro}"
					fi
				done
				;;

			'')
				# Abort if no distro found
				print_error 1 "This module will abort." "$usekdialog" \
				              "You have zero distros installed or use a distro " \
				              "not recognised by ${appname}"
				return 1
				;;

			#*)
				# Abort if more than one distro
				#if [ "$usekdialog" == "1" ]; then
					#kdialog --error  "You have several distros installed at the \
					#same time.\nInstalled distros:\n${found_distros}\n\
					#This module will abort."
				#else
					#echo "${tcRED}ERROR:${tSTD} You have several distros \
						#installed at the same time."
					#echo "${tcRED}ERROR:${tSTD} ${tBOLD}Installed distros:${tSTD}\
						#${found_distros}"
					#echo "${tcRED}This module will abort.${tSTD}"
				#fi
				#return 1
			#;;
			esac


		# Output distro version
		case "${found_distros}" in
			'SuSE')
				distro_release="$(grep -F 'VERSION = ' ${root_dir}etc/SuSE-release          | sed 's/VERSION = //'    )" ;;
			'Red Hat')
				distro_release="$(cat ${root_dir}etc/redhat-release)" ;;
			'Fedora')
				distro_release="$(cat ${root_dir}etc/fedora-release)" ;;
			'Slackware')
				distro_release="$(grep -F 'Slackware ' ${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
			'Topologilinux')
				distro_release="$(grep -F 'Topologilinux ' ${root_dir}etc/Topologilinux-version | sed 's/Topologilinux //')"
				local  SlackwareBase="$(grep -F 'Slackware  '${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
			'Gentoo')
				# AnMaster: Not sure if readlink is POSIX but it exists on Gentoo and we allready know this is Gentoo.
				distro_release="$(readlink /etc/make.profile | grep -Eo '[0-9]{4}\.[0-9]')";;
			'misc')
				# FIXME: AnMaster: . is a wildcard meaning any single char. Isn't grep -F what you want?
				distro_release="$(grep '.' "${root_dir}etc/issue" | grep -Eo '([A-Za-z0-9 ."])+' | head -n 1 )";;
				# TODO: improve the grep
		esac

	fi
}
#############################################################



#######################
# APPLICATIONS
#
# version information of standard *nix, dev, and dependency packages.
# probably should take an additional switch like --X, --server, etc.
Module_applications() {
	local moduleName="Applications"
	module_header "${moduleName}"

	local APPLICATIONS app
	## Applications to look for..
	if [ "$SYSTEM" == "linux" ] ; then

		APPLICATIONS="X kde-config gnome-about x11vnc \
			bash csh ksh \
			gcc make \
			ls awk sed grep gzip \
			perl python java-config \
			apache2 php mysql smbd cups-config \
			udevinfo lspci lshw dmidecode smartctl hdparm"

	elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then

		APPLICATIONS="X kde-config x11vnc \
			csh bash ksh \
			gcc grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			lspci lshw smartctl hdparm"

	fi

	## Write the header for output
	if [ $usexml = 1 ]; then
		add_attribute "Applications" 'software'
	fi

	local missing_ERRMSG="if you want to be able to use all modules of ${appname}"
	## Process all applications
	for app in ${APPLICATIONS}; do

		if [ "$(type -p $app)" ]; then # it is installed
			case "$app" in
				'perl')
					add_values  "Perl $($app --version 2>&1 | grep 'perl, v' | \
					                    grep -Eo 'v[ A-Za-z0-9.-]*')\n"
					;;
				'python')
					add_values  "$($app -V 2>&1 | head -n 1 )\n"
					;;
				'X')
					add_values  "$($app -version 2>&1 | grep Revision)\n"
					;;
				'kde-config')
					add_values  "$($app -version 2>&1 | grep KDE)\n"
					;;
				'gnome-about')
					add_values  "$($app --version 2>&1 )\n"
					;;
				'apache2'|'apache')
					add_values  "$($app -V | head -n 1 | awk -F': ' {'print $2'})\n"
					;;
				'cups-config')
					add_values  "Cups $($app --version 2>&1 )\n"
					;;
				'smbd')
					add_values  "Samba $($app -V 2>&1 )\n"
					;;
				'udevinfo')
					add_values  "$($app -V 2>&1 )\n"
					;;
				'awk')
					add_values  "$($app -W version 2>&1 | head -n 1 )\n"
					;;
				'dmidecode')
					add_values  "dmidecode $(dmidecode -V 2> /dev/null )\n"
					;;
				'java-config')
					add_values "Java $(java-config -f)\n"
					;;
				*)
					add_values  "$($app --version 2>&1 | grep '\w' | head -n 1)\n"
					;;

				'lspci')
					info "please install pciutils ${missing_ERRMSG}"
					;;
				'lshw')
					info "please install lshw ${missing_ERRMSG}"
					;;
				'smartctl')
					info "please install smartmontools ${missing_ERRMSG}"
					;;
				'dmidecode')
					info "please install dmidecode ${missing_ERRMSG}"
					;;
			esac
		fi
	done
	#module_footer
	flush_values
}


#######################
# hardware devices of the system
#
# this function parses the physical devices in the computer from lspci.
# depends on pciutils.
#
# the output verbosity can be increased to include devices in the
# DO_NOT_OUTPUT string to include standard motherboard controllers
# which are suppressed in the normal level of verbosity.
#
# TODO: is there a way to link these devices to specific udev nodes?
#       udevinfo 087 hadn't got the data lspci has
Module_devices() {
	local moduleName="Devices"
	module_header "${moduleName}"
	local DEVICE
	local DEV_ARRAY=1;
	for DEVICE in $(lspci | awk {'$1="\b" ; print $0'} | tr ' ' '_' ); do

		devices[$DEV_ARRAY]="$(

			echo $DEVICE | sed -r 's/:_/:/g;s/(^_)//g' | tr ':' ' ' )"

			# with lspci 2.2 and later, the -m switch works fine
			#	for DEVICE in $(lspci -m | tr ' ' '_'); do
			#		devices_dbg[$DEV_ARRAY]="$(	echo $DEVICE | grep -Eo '"[^"]+"' | awk -F\" {'print $2'} )";

		((DEV_ARRAY++))
	done

	# the devices array now contains the ' ' separated entries from lsmod.
	# [1] device type		# [2] manufacturer		# [3] device name	etc
	# ${#devices[@]} # is the number of devices in the array

	# by default output all, but
	DO_NOT_OUTPUT="pci\|usb\|smb\|bridge\|ide"

	[[ "$isverbose" -eq 1 ]] && \
		DO_NOT_OUTPUT="smb\|bridge"


	for DEV_ARRAY in $(seq 1 1 ${#devices[@]}); do
		#if [ ! "$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | \
		#	grep -i $DO_NOT_OUTPUT)" ]; then
		if [ -z "$(grep -i $DO_NOT_OUTPUT <<< ${devices[$DEV_ARRAY]})" ]; then


			# make an exception for display and ethernet adapters
			# so they can be tagged properly in the xml output.

			# make sure that if several adapters are found, they are
			# printed as <value>s under the same <attribute> tag

			# AnMaster: Could you please tell me what you (ruxpin) mean with this?
			#           As there is nothing about network in lspci...
			#           And Display adapter(s) seems broken.
			#               01:00.0 VGA compatible controller: ATI Technologies Inc RV280 [Radeon 9200 PRO] (rev 01)
			#               01:00.1 Display controller: ATI Technologies Inc RV280 [Radeon 9200 PRO] (Secondary) (rev 01)
			#           And there is only one in osinfo. In osinfo --xml there is one normal and one empty for it.
			#               <value>ATI Technologies Inc RV280 [Radeon 9200 PRO] (rev 01) </value>
			#               <value></value>
			#           Same in the lanforce output.

			# ruxpin: I already though of fixing it, because I got two network cards
			# to output. I can't debug that right now.

			local description="$(awk  '{ print $1 }' <<< ${devices[$DEV_ARRAY]} | \
			                     tr '_' ' ' | sed 's/^.//;s/^ *//')"
			local device="$(awk  '{ print $2" "$3 }' <<< ${devices[$DEV_ARRAY]} | \
			                tr '_' ' ')"


			if [ "$(grep -i 'network\|ethernet' <<< "$description")" ]; then

				# these values should not be local,
				# older bash fails there
				eth_adapter[${#eth_adapter[@]}]="$device"

			elif [ "$(grep -i 'vga\|display' <<< "$description")" ]; then

				video_adapter[${#video_adapter[@]}]="$device"

			else

				add_attribute "$description"
				add_values    "$device"

			fi

		fi
	done


	#then report the eth and video adapters
	if [ "$eth_adapter" ]; then
		add_attribute 'Ethernet controller(s)'	"network_adapter"
		for i in $(seq 0 1 $((${#eth_adapter[@]}-1)) ); do
			add_values    "${eth_adapter[$i]}\n "
		done
	fi


	if [ "$video_adapter" ]; then
		add_attribute 'Display adapter(s)'		"display_adapter"
		for i in $(seq 0 1 $((${#video_adapter[@]}-1)) ); do
			add_values    "${video_adapter[$i]}\n "
		done
	fi

	#12:04 < LinuxNIT> is there a way to check and see how much ram my video card actually has available/is using? not just what i set in the xorg.conf
	#12:04 < Kevin`> lspci -vv
	#12:06 < LinuxNIT> IRegion 0: Memory at e8000000 (32-bit, prefetchable) [size=128M]

	#module_footer
	flush_values
}


#######################
# ENVIRONMENT VARIABLES
#
# xml only, stdout is not needed
Module_env() {
	local moduleName="Environment variables"
	module_header "${moduleName}"

	## Write the header for output
	add_attribute   'System enviroment variables\n' \
	                'system_enviroment_variables'
	## Process all variables
	for var in $(env); do

		add_values  "${var}\n"

	done

	#module_footer
	flush_values
}

