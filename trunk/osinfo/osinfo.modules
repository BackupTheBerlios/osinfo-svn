#!/bin/bash
#################################################################################
# OSINFO MODULES
#
# osinfo lists system information available to the OS.
#
# this file contains the osinfo modules and module subfunctions.
# modules can be freely added; the data processing and outputting is taken
# care of by other functions. these are accessed by the following functions,
# and here they are presented in the order in which they should appear in
# the modules.
#
# module_header	"Module name"
#  each module should begin with this line.
#  it will be printed in colour at stdout and as a tag to xml.
#  it may contain spaces; in the xml tag they will be replaced by '_'
#
# value_header	"Header"
#  the argument is printed on a single line in bold to stdout,
#  and as a <header> tag to the xml.
#  each module may contain several calls of this type
#
# add_attribute "Common Name"	"xml_code"
#  the first argument is printed at the first field to stdout,
#  and the xml output is formulated as:
#  <xml_code>
#   <value>foo</value>
#  </xml_code>
#  each module may contain several calls of this type.
#  the previous attribute tag is automatically closed when a new
#  one is introduced.
#
# add_values "value 1" "value 2" "value n"
#  several values can be given;
#  all of them will be separated with tab at stdout,
#  and they will each get their own <value>foo</value> line at xml output.
#  special characters as '\n' and '\t' can be used;
#  they will not affect the xml output.
#  each module may contain several calls of this type.
#
# value_footer
#  this call should follow a block of values, if the value_header
#  function is called before them. this closes open header tags.
#
# module_footer
#  this call should immediately precede the flush_values call.
#  this takes care of closing an open attribute tag.
#
# flush_values
#  prints the values to xml file or to stdout.
#  this should be the final command in a module.
#
#################################################################################
# Written by Mikael Lammentausta and Arvid Norlander
#
# Some parts are taken from:
#   --Advanced Bash Scripting Guide (ABS)
#################################################################################


## META-MODULES
#
# can be also used as aliases on the command line,
# but not inside another meta-module

Meta_all='distro system kernel processor applications network terminal devices hdd dmi cdrom memory users services printers'
Meta_lanforce='distro system processor memory network dmi hdd devices cdrom users printers applications services env'
Meta_system='distro system kernel processor'
Meta_cpu='processor'
Meta_apps='applications'
Meta_net='network'


# these are used to control run access

MODULES_LINUX='distro system kernel processor network applications terminal devices hdd dmi cdrom memory users services printers'
MODULES_BSD='distro system applications terminal network'
MODULES_LANFORCE=''
MODULES_BROKEN=''
MODULES_REAL_ROOT_ONLY='system terminal applications network devices services hdd printers dmi services'
MODULES_SU_ONLY='cdrom hdd dmi memory oem'
# MUST contain a list of all modules. This is used to find any invalid modules.
MODULES_ALL='applications cdrom devices distro dmi env hdd kernel memory network oem printers processor services system terminal users'


################################################################################
################################################################################
## General helper functions                                                   ##
################################################################################
################################################################################

##
# Checks for lshw and print a message if it doesn't exist
# Returns 0 if lshw eixsts and 1 if it is missing.
CheckReq_lshw() {
	if [ ! "$(type -p lshw)" ]; then
		add_attribute	"$appname notification"
		add_values		"Please install lshw to collect this information"
		return 1
	else
		return 0
	fi
}

##
# Checks for dmidecode and print a message if it doesn't exist
# Returns 0 if dmidecode eixsts and 1 if it is missing.
CheckReq_dmidecode() {
	if [ ! "$(type -p dmidecode)" ]; then
		add_attribute	"$appname notification"
		add_values		"Please install dmidecode to collect this information"
		return 1
	else
		return 0
	fi
}

##
# Checks if we are run as root and print a message if we are not.
# Returns 0 if we are root and 1 if we are not.
CheckReq_root() {
	if [ "$EUID" != 0 ]; then
		add_attribute	"$appname notification"
		add_values		"Please run $appname as super-user to collect this information"
		return 1
	else
		return 0
	fi
}


##
# Checks if lshw was already run.
#  if it wasn't then run lshw and export the filename of the temporary file.
#  otherwise just return.
lshw_xml() {
	if [ -z "$lshw_xml_file" ]; then
		export lshw_xml_file="$(mktemp /tmp/osinfo.XXXXXX)"
		lshw -xml > "$lshw_xml_file"
	fi
}

TempFiles=()
##
# Cleans up some temporary files in the TempFiles array.
#
cleanup_temp_files() {
	if [ "$lshw_xml_file" ]; then
		rm -f "$lshw_xml_file"
	fi
	local fil
	for fil in "${TempFiles[@]}"; do
		rm -f "$fil"
	done
}

################################################################################
################################################################################
## Modules                                                                    ##
################################################################################
################################################################################


#######################
# HARD DISK DRIVES
#
# this module collects data of the hard disk drives attached to the system.
# some information is unaccesible unless the partitions are mounted.
#
# S-ATA drives now display everything as nicely as IDE drives,
# due to support in recent smartmontools (version 5.36).
#
# used tools:
# fdisk, df, udev, /proc (deprecated), smartmontools, hdparm, bc
Module_hdd() {
	local moduleName="Disk information"
	module_header "${moduleName}"

	# developement status:
	# -------------------
	# IDE/PATA is tested
	# SATA is tested
	# USBhdd is tested
	# SCSI is untested, although works probably as SATA
	# Software RAID is planned (mdadm only), untested
	# Logical Volume Management support is planned, untested
	# FreeBSD is untested


	# this module depends heavily on root access, so prevent other users
	# of running this module
	if CheckReq_root; then

		# declare variables
		local hdd_total_capacity=0 hdd_total_used=0 hdd_total_free=0 hdd_ID=0 

		# detect all drives in the system
		local drives="$(fdisk -l | grep Disk | grep -Eo '\/(dev)\/\w'+)"

		# collect data of all detected drives in this loop
		for drvdev in $drives; do

			((hdd_ID++))

			#########################
			# initialize variables
			#
			# $hdd_dev is the devfs/udev node, e.g. "/dev/hda"
			# $hdd_node is the device id, e.g. "hda"
			# $hdd_busnr is the drive bus number, e.g. for sdc '3' and hdd '4'

			hdd_dev[$hdd_ID]="${drvdev}"
			hdd_node[$hdd_ID]=$(echo $drvdev | awk -F/ {'print $NF'})
			# FIXME: useless use of echo?
			hdd_busnr[$hdd_ID]=$(( $(echo -n ${hdd_node[$hdd_ID]: -1:1} | \
				tr 'a-z' 'A-Z' | od -A n -t u1) - 64));
				# 64 is the offset of 'A' in the ASCII chart


			#################################
			# scan type-dependent attributes

			# IDE drives
			if [ "$(echo $drvdev | grep 'hd' )" ]; then

				# On FreeBSD the first ATA drive is 'ad0',
				# not tested!
				scan_hdd_ide ${drvdev} ${hdd_node[$hdd_ID]} ${hdd_busnr[$hdd_ID]}


			# SATA/SCSI/USB drives (Linux SCSI sg driver)
			elif [ "$(echo $drvdev | grep 'sd' )" ]; then

				# On FreeBSD the first ATA drive is 'da0',
				# hasn't been tested!
				scan_hdd_sata ${drvdev} ${hdd_node[$hdd_ID]} ${hdd_busnr[$hdd_ID]}


			# software RAID arrays
			elif  [ "$(echo $drvdev | grep md)" ]; then

				scan_hdd_raid ${drvdev} ${hdd_node[$hdd_ID]} ${hdd_busnr[$hdd_ID]}

			else

				hdd_type="Unknown drive type"

			fi


			###############################
			# scan common attributes
			scan_hdd_common ${drvdev}


			#####################
			# scan the partitions
			#
			# see the function code for comments on the variables
			# this functions sets. they will be overwritten during
			# the next run of this function. this would be easily
			# fixed if bash would support matrices, but no.
			hdd_pt_ID=0
			scan_hdd_partitions ${drvdev}


			##############################################
			# calculate the total disk capacity of $drvdev
			calculate_hdd_usage


			####################
			# OUTPUT DRIVE DATA
			if [ $usexml -eq 0 ]; then

			# TODO: use array for these values, no need to unset then

				value_header	 ${drvdev}
				
				add_attribute	"$hdd_type"
					add_values	"$(echo $hdd_vendor $hdd_model | sed 's/^ *//')"
				add_attribute	'Serial number'
					add_values	"$hdd_serial"
				add_attribute	'Driver'
					add_values	"$hdd_driver"
				add_attribute	'DMA'
					add_values	"$hdd_dma"
				add_attribute	'Geometry'
					add_values	"$hdd_geometry"
				add_attribute	'Capacity (reported)'
					add_values	"$hdd_capacity_label"
				add_attribute	'Capacity (actual)'
					add_values	"$(hdd_human_readable $hdd_capacity)"

				add_attribute	'S.M.A.R.T.'
					add_values	"$hdd_smart"
				add_attribute	'Lifetime'
					add_values	"$hdd_lifetime"
				add_attribute	'Temperature (C)'
					add_values	"$hdd_tempC"
				add_attribute	'Health Status'
					add_values	"$hdd_health"
					
				value_header	"  Partition\t\tmntpoint\tblocks\t\tfree\t\tfilesystem"

				for hdd_pt in $(seq 1 1 $partitions_on_drive); do
					# dev node
					add_attribute	"  ${hdd_pt_node[$hdd_pt]}"

					if [ "${hdd_pt_mp[$hdd_pt]}" ]; then #mount point exists

						# mount point
						add_values		"${hdd_pt_mp[$hdd_pt]}"

						# blocks
						add_values		"$(hdd_human_readable \
										${hdd_pt_blocks[$hdd_pt]})"
						# free
						add_values		"$(hdd_human_readable \
										${hdd_pt_free[$hdd_pt]})"
						#add_values		"${hdd_pt_free_pc[$hdd_pt]})"

						# fs type
						add_values		"${hdd_pt_fs[$hdd_pt]}"

					else

						# blocks
						add_values		"-"
						add_values		"$(hdd_human_readable \
										${hdd_pt_blocks[$hdd_pt]})"

						# free would come here
						add_values		''
						
						# fs type
						add_values		"${hdd_pt_fs[$hdd_pt]}"

						
					fi

				done

			### XML OUTPUT
			else 

				add_attribute	"$hdd_type"			'hard_disk'
				# TODO: how to break these into many lines?
				add_values		"$hdd_type $hdd_vendor $hdd_model ($hdd_serial) $hdd_capacity_label"

				add_attribute	"partitions"		'drive'
				for hdd_pt in $(seq 1 1 $partitions_on_drive); do
					add_values		"${hdd_pt_node[$hdd_pt]} ${hdd_pt_mp[$hdd_pt]} ${hdd_pt_free[$hdd_pt]}/${hdd_pt_blocks[$hdd_pt]}" 
				done

			fi

			##################
			# clear varibles
			unset hdd_vendor hdd_model hdd_serial \
					hdd_geometry hdd_dma hdd_driver \
					hdd_capacity_label hdd_capacity partitions_on_drive \
					hdd_smart hdd_lifetime hdd_tempC hdd_health

		done


		######################################
		# calculate total system disk capacity
		# report data of the whole system

		#totalpercfree=0

		#add_attribute	"Total disk space"
		#add_values		"Capacity: $(echo $totalsize)"
		#add_values		"Free: $(echo -e $totalfree ; $totalpercfree %)"


		#DISKFREE=$(($DISKFREE+$partfree))


	fi

	# finalize
	module_footer
	flush_values
}


###### BEGIN HDD SUBFUNCTIONS #############
#
# these functions are called from mod_hdd and they generate no output,
# all data is stored into global variables.


	##############################################
	# CALCULATES THE TOTAL DISK USAGE OF A DRIVE
	#
	# Sets variables:
	#	hdd_used[]           # total used space in kB
	#	hdd_free[]           # total free   - " -
	#	hdd_used_pc[]        # ratio of used/total capacity
	#	hdd_free_pc[]        # ratio of free/total capacity
	#	hdd_mnt_pc[]         # ratio of mounted/total disk capacity
	#	hdd_mnt_free_pc[]    # ratio of free/used on mounted
	#	hdd_mnt_used_pc[]    # ratio of used/free on mounted
	#	hdd_mnt_capacity[]   # total capacity in mounted partitions
	#
	calculate_hdd_usage() {
	
		local ID=$hdd_ID
		hdd_used[$ID]=0           # total used space in kB
		hdd_free[$ID]=0           # total free   - " -
		hdd_used_pc[$ID]=0        # ratio of used/total capacity
		hdd_free_pc[$ID]=0        # ratio of free/total capacity
		hdd_mnt_pc[$ID]=0         # ratio of mounted/total disk capacity
		hdd_mnt_free_pc[$ID]=0    # ratio of free/used on mounted
		hdd_mnt_used_pc[$ID]=0    # ratio of used/free on mounted
		[ ! "$partitions_on_drive" ] && scan_hdd_partitions
		[ ! "$hdd_capacity" ] && scan_hdd_common

		# calculate the total free space on all partitions
		# may be incorrect, since some partitions may be unmounted,
		# and swap if not counted in
		for hdd_pt in $(seq 1 1 $partitions_on_drive);do

			let hdd_used[$ID]+=hdd_pt_used[$hdd_pt]
			((hdd_free[$ID]+=hdd_pt_free[$hdd_pt]))

		done

		#echo "${hdd_free[$ID]}/${hdd_used[$ID]}/$hdd_capacity"

		# if the drive has mounted partitions
		if [ ${hdd_used[$ID]} -ne 0 ] && [ ${hdd_free[$ID]} -ne 0 ]; then

			# calculate the percentages of free and used space
			hdd_mnt_free_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_free[$ID]}*100/${hdd_used[$ID]}) %"
			
			hdd_mnt_used_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_used[$ID]}*100/${hdd_free[$ID]}) %"

			# calculate the ratio of mounted_capacity/total_capacity
			hdd_mnt_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_free[$ID]}*100/${hdd_capacity})%"


			# the ratio of used and free/total capacity
			hdd_used_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_used[$ID]}*100/${hdd_capacity})%"

			hdd_free_pc[$ID]="$(bc -s <<< scale=1\;" \
				"${hdd_free[$ID]}*100/${hdd_capacity})%"

		fi

	}



	#################################################
	# SCAN COMMON ATTRIBUTES OF ALL HARD DRIVE TYPES
	#
	# geometry and capacity
	#
	# Sets variables:
	#	hdd_geometry
	#	hdd_capacity_label	is the value given by the vendor
	#	hdd_capacity			is the true capacity of the drive
	#
	# Parameters:
	#	(1) drive device
	#
	scan_hdd_common() {

		local dev_scan="${1}"

		hdd_geometry="$(fdisk -l | grep ${dev_scan} -A 1 | sed -n "2{p;q}")"

		# FIXME: couldn't this be simpler?
		hdd_capacity_label="$(fdisk -l ${dev_scan} | grep ${dev_scan} | \
			head -n 1 | grep -Eo '[1-9][0-9]+[\.0-9]* \w{2}' | head -n 1)"

		# fdisk gives drive capacity in kB
		hdd_capacity="$(fdisk -s $dev_scan)"

	}

	#########################
	# S.M.A.R.T. scanning
	#
	# smartmontools are handy in getting the extended parameters
	# of hard drives. only version 5.36 and onward support SATA drives
	# and the version may be a bit uncommon, as it was released in April 2006.
	# all major distros should begin to include it in their packages,
	# so this should be relatively common in late 2006.
	# for ide drives this is not a problem.
	#
	# Parameters:
	#	(1) drive device
	#	(2) device type (man smartctl for details)
	#
	scan_hdd_smart() {

		local dev_scan="${1}" dev_type smart_info version
		if [ "$2" ]; then
			dev_type="$2"
		else
			dev_type=ata
		fi

		# allocate a temp file
		smart_info="$(mktemp /tmp/osinfo.XXXXXX)"
		TempFiles=("${TempFiles[@]}" "$smart_info")

		smartctl -a -d $dev_type ${dev_scan} > $smart_info

		hdd_smart="$(grep 'SMART support' ${smart_info} | \
						head -n 1 | awk -F': ' {'print $2'})"

		hdd_lifetime="$(grep -i power_on $smart_info | awk {'print $NF'})"

		hdd_tempC="$(grep -i temperature_celsius $smart_info | \
						awk '{for (i=10; i<=NF; i++) printf("%s ",$i);printf ("\n")}')"

		hdd_health="$( grep -Ei '(health)+' $smart_info | awk {'print $NF'})"

	}


	####################
	# PARTITIONS
	#
	# function extracts information of hard drive partitions and
	# stores it into arrays. the arrays are identified by the variable
	# hdd_pt_ID, which should be used to identify the parameters of the
	# partition in hdd_pt_node[hdd_pt_ID]. the arrays this function creates:
	#
	# 	hdd_pt_ID         # this is an internal reference number
	#	hdd_pt_node[]     # partition devfs/udev node, e.g. "/dev/hda1"
	#	hdd_pt_blocks[]   # size of the partition in 1 kB blocks
	#	hdd_pt_capacity[] # capacity of the partition  - " -
	#	hdd_pt_used[]     # used space  - " -
	#	hdd_pt_free[]     # free space  - " -
	#	hdd_pt_used_pc[]  # used space in percentage, e.g. "84.5%"
	#	hdd_pt_free_pc[]  # free space in percentage
	#	hdd_pt_mp[]       # mount point
	#	hdd_pt_fs[]       # filesystem type
	#	hdd_pt_fs_size[]  # space allocated by the filesystem
	#
	# Parameters:
	#	(1) drive device
	#
	scan_hdd_partitions() {

		local dev_scan="${1}" part_free=0
		partitions_on_drive="$(fdisk -l ${dev_scan} | grep ^${dev_scan} | wc -l)"
		local ID=$hdd_pt_ID


		#TODO for version 0.5 or so
		#hdd_fs_ID=[83] [7] [82] ... #which tells the FS type
		#hdd_fs_allocated=[1292372032] [28402202] [10284942]


		# loop all partitions detected by fdisk
		for PARTNR in $(seq 1 1 $partitions_on_drive); do

			((ID++)) # increase the array number

			# get the partition node
			hdd_pt_node[$ID]="$(fdisk -l ${dev_scan} | grep ^${dev_scan} | \
				awk {'print $1'} | sed -n "${PARTNR}{p;q;}" )"


			# get the partition size in 1 kB blocks
			hdd_pt_blocks[$ID]="$(fdisk -s ${hdd_pt_node[$ID]})"


			# detect the filesystem
			#
			# fdisk uses spaces, not tabs for indentation.
			# awk's $NF does not work, as the filesystem name may have spaces.
			# awk is looped from field 6 onward. while the field 6 is the 
			# FS type integer, it has to be included when fdisk adds a '*' 
			# character to denote bootable partitions. the numbers are removed
			# from the beginning of string with sed.
			hdd_pt_fs[$ID]="$(fdisk -l | grep ^${hdd_pt_node[$ID]} | \
				awk '{for (i=6; i<=NF; i++) printf("%s ",$i);printf ("\n")}' | \
				sed 's/^[0-9 ]*//')"


			# if partition is mounted (=is in mtab)
			#
			# FIXME: submounted (=system for automounting usb sticks) partitions
			# may be considered unmounted, while they are not!

			# the partition size is calculated from the value given by df,
			# and the float division is computed by bc.
			if [ "$(df -Plk | grep ${hdd_pt_node[$ID]})" ]; then

				# locate the mountpoint
				hdd_pt_mp[$ID]="$(df -PT ${hdd_pt_node[$ID]} | \
					grep ^${hdd_pt_node[$ID]} | awk {'print $NF'})"


				# get the partition capacity, used and free space in 1 kB blocks
				local df_output="$(df -Plk | grep ${hdd_pt_node[$ID]})"
				hdd_pt_capacity[$ID]="$(awk {'print $2'} <<< "$df_output")"
				hdd_pt_used[$ID]="$(awk {'print $3'} <<< "$df_output")"
				hdd_pt_free[$ID]="$(awk {'print $4'} <<< "$df_output")"
				hdd_pt_used_pc[$ID]="$(awk {'print $5'} <<< "$df_output")"

				# calculate the space allocated by the filesystem
				hdd_pt_fs_size[$ID]="$(bc -s <<< scale=1\;" \
					"${hdd_pt_free[$ID]}-${hdd_pt_capacity[$ID]})"

				# calculate the percentages of free and used space
				hdd_pt_free_pc[$ID]="$(bc -s <<< scale=1\;" \
					"${hdd_pt_free[$ID]}/${hdd_pt_capacity[$ID]}*100)%"
				

			fi

		done

	}


	#################
	# MAKES HDD SIZE REPORTS HUMAN-READABLE
	#
	# Parameters:
	#	(1) input value in kB
	#	(2) significant digits _after_ decimal, default 1
	#
	hdd_human_readable() {

		local value="${1}"

		if [ ! "$2" ]; then
			local digits=1
		else
			local digits="${2}"
		fi


		#	dimension, 10^3 multiple of bytes, e.g. 'GB', defaults to MB
		case $(bc -s <<< ${value}/1024 | wc -m ) in
			'1'|'2'|'3'|'4')
				local dim='MB'
				local denominator="1024"
				;;
			'5'|'6'|'7')
				local dim='GB'
				local denominator='1024^2'
				;;
			'8'|'9'|'10')
				local dim='TB'
				local denominator="1024^3"
				;;
			'11'|'12'|'13')
				local dim='PB'
				local denominator="1024^4"
				;;
			*)
				local dim='kB'
				local denominator="1"
		esac

		local hdd_val="$(bc -s <<< scale=$digits\;${value}/${denominator}) $dim"

		# check if val<1
		if [ "${hdd_val:0:1}" == "." ]; then
			hdd_val="0${hdd_val}"
		fi

		echo "${hdd_val}"
	
	}


	#################
	# IDE drives
	#
	# this function collects information of IDE drives in the system
	#
	# udevinfo, /proc/ide/, smartmontools and hdparm are used as the data source.
	#
	# Parameters:
	#	(1) drive device
	#	(2) drive node in the /dev/ tree
	#	(3) the node number in the bus
	#
	scan_hdd_ide() {

		hdd_type='IDE drive'
		local dev_scan="${1}" dev_scannode="${2}"

		# detect the available data sources
		if [ "$(type -p udevinfo)" ]; then
			# allocate a temp file
			local udev_info="$(mktemp /tmp/osinfo.XXXXXX)"
			TempFiles=("${TempFiles[@]}" "$udev_info")
			udevinfo -q all -n ${dev_scan} > $udev_info
		fi
		if [ -e "/proc/ide/" ]; then
			local proc_info="/proc/ide/${dev_scannode}"
		fi
		# hdparm output is not read into a temp file, as
		# it is unlikely to be used, and that would unnecessarily
		# slow down this function.


		########
		# Vendor
		if [ "$(type -p smartctl)" ]; then

			# because smartctl uses its own database to report the HDD vendor,
			# it is preferred over udev.
			#
			# this smart scan is not included into the scan_hdd_smart()
			# because it would break the correct order of the report.
			hdd_vendor="$(smartctl -i ${dev_scan} | grep '^Model' | \
							awk -F: {'print $2'} | sed 's/^ *//')"

		elif [ "${udev_info}" ]; then
			hdd_vendor="$(udevinfo -q all -n ${dev_scan} | grep -i vendor | \
							awk -F_ {'print $NF'})"
		fi

		# check whether we got anything else than empty $vendor string
		if [  "$(grep  '^\ *' <<< $vendor )" ]; then
			hdd_vendor="Unknown vendor"
		fi


		#######
		# Model
		if  [ "${udev_info}" ]; then
			hdd_model="$(udevinfo -q all -n ${dev_scan} | grep -i model | \
							awk -F= {'print $NF'})"

		elif [ -e "${proc_info}" ]; then
			hdd_model="$(cat ${proc_info}/model)"

		elif [ "$(type -p hdparm)" ]; then
			hdd_model="$(hdparm -i ${dev_scan} | grep -Eio 'Model=\w+' | \
							awk -F= {'print $2'})"

		fi


		###############
		# Serial number
		if  [ "${udev_info}" ]; then
			hdd_serial="$(grep SERIAL ${udev_info} | awk -F= {'print $NF'})"

		elif [ "$(type -p hdparm)" ]; then
			hdd_serial="$(hdparm -i ${dev_scan} | grep -Eio 'serialno=\w+' | \
						 awk -F= {'print $2'})"
		fi


		########
		# Driver
		if [ -e "/proc/ide/${dev_scannode}" ]; then
			hdd_driver="$(cat ${proc_info}/driver)"
		fi


		############
		# DMA STATUS
		if [ "$(type -p hdparm)" ]; then
			hdd_dma="$(hdparm ${dev_scan} | grep dma | grep -Eo '\([onf]+\)')"
		fi


		#############################
		# scan for SMART attributes
		if [ "$(type -p smartctl)" ]; then
			scan_hdd_smart ${dev_scan} ata
		fi

	}


	#################
	# SATA/SCSI/USB drives (sg driver)
	#
	# this function collects information of SATA/SCSI/USB drives,
	# because under Linux they all use the same SCSI drivers.
	#
	# the information in stored into two or three locations, depending
	# on the kernel and whether the system uses devfs or udev.
	# since devfs is deprecated, it is not used at all.
	# the /proc/scsi/ system is deprecated from 2.6 on, but it is left
	# here for legacy support.
	#
	# usb drives, when properly detected by the Linux kernel,
	# are added to /proc/scsi/scsi info sheet, and the assigned scsi number
	# which can be found both in the beforementioned location and also
	# in /proc/scsi/sg/devices, can be used to identify the device
	# in /proc/scsi/usb-storage/*.
	#
	# as the devices are (hopefully) linearily, the devices catalogue
	# can be used to identify which /dev/sd* node is a certain scsi#.
	#
	# this is not true in the case of custom udev rules. although
	# a good practise is to let kernel do its magic and create a
	# link node to that device, so this is unlikely to be a problem.
	#
	# smartmontools support SATA drives from version 5.36 on
	# (released April 2006). this function is written in June 2006,
	# and for that the version of smartctl is checked before trying
	# to access SATA drives.
	#
	# Parameters:
	#	(1) drive device
	#	(2) drive node in the /dev/ tree
	#	(3) the node number in the bus
	#
	scan_hdd_sata() {

		local dev_scan="${1}" dev_scannode="${2}" dev_nodenr="${3}"

		# detect the available data sources
		if [ "$(type -p udevinfo)" ]; then
			# allocate a temp file
			local udev_info="$(mktemp /tmp/osinfo.XXXXXX)"
			TempFiles=("${TempFiles[@]}" "$udev_info")
			udevinfo -q all -n ${dev_scan} > ${udev_info}
		fi
		if [ -e "/proc/scsi/" ]; then
			local proc_info="/proc/scsi/scsi"
			local scsi_devices="/proc/scsi/sg/devices"
			local scsi_devstrings="/proc/scsi/sg/device_strs"
			local usb_devstrings="/proc/scsi/usb-storage/"
			local sg_version="/proc/scsi/sg/version"
			local scsi_nr="$(sed -n "$dev_nodenr{p;q;}" ${scsi_devices} | \
				awk {'print $1'})"
		fi
		# hdparm output is not read into a temp file, as
		# it is unlikely to be used, and that would unnecessarily
		# slow down this function.

		if [ "${udev_info}" ]; then

			local bus="$(grep -i ID_BUS ${udev_info} | awk -F= {'print $NF'})"
			if [ "$(grep usb <<< $bus)" ]; then		# USB drive detected

				hdd_type='USB drive'

			else
				hdd_type='SATA/SCSI drive'
			fi

		# test if the scsi_nr is found in /proc/scsi/usb-storage/
		elif [ -e "${proc_info}" ]; then

			if [ -e "${usb_devstrings}${scsi_nr}" ]; then
				local usb_info="${usb_devstrings}/${scsi_nr}"
				hdd_type='USB drive'
			fi

		else	# no udev and no /proc/scsi. odd.
		
			hdd_type='SATA/SCSI drive'
			
		fi

		########
		# Vendor
		if [ "$smart" = "sata-ok" ]; then

			# because smartctl uses its own database to report the HDD vendor,
			# it is preferred over udev.
			#
			# this smart scan is not included into the scan_hdd_smart()
			# because it would break the correct order of the report.

			hdd_vendor="$(smartctl -i -d ata ${dev_scan} | grep '^Model' | \
							awk -F: {'print $2'} | sed 's/^ *//') "

		elif [ "${udev_info}" ]; then

			hdd_vendor="$(grep -i vendor ${udev_info}  | \
							awk -F= {'print $NF'}) "

		elif [ -e "${proc_info}" ]; then

			hdd_vendor="$(sed -n "$dev_nodenr{p;q;}" "${scsi_devstrings}" | \
							awk {'print $1'}) "
							#"$(grep -i vendor ${usb_info} | awk -F': ' {'print $2'})"
		fi


		#######
		# Model
		if  [ "${udev_info}" ]; then

			hdd_model="$(grep -i model ${udev_info} | \
							awk -F= {'print $NF'})"

		elif [ -e "${proc_info}" ]; then

			hdd_model="$(sed -n "$dev_nodenr{p;q;}" "${scsi_devstrings}" | \
							awk {'print $2" "$3'})"

		elif [ "$(type -p hdparm)" ]; then

			hdd_model="$(hdparm -i ${dev_scan} | grep -Eio 'Model=\w+' | \
							awk -F= {'print $2'})"
		fi


		###############
		# Serial number
		if  [ "${udev_info}" ]; then

			hdd_serial="$(grep SERIAL ${udev_info} | awk -F= {'print $NF'})"

		elif [ "$(type -p hdparm)" ]; then

			hdd_serial="$(hdparm -i ${dev_scan} | grep -Eio 'serialno=\w+' | \
							awk -F= {'print $2'})"
		fi


		########
		# Driver
		if [ -e "${proc_info}" ]; then
			hdd_driver="Linux SCSI Generic (sg) v.$(cat ${sg_version})"
		fi


		#TODO: dma status

		#############################
		# check the smartctl version >5.36
		version="$(smartctl --version | grep -Eo 'version [0-9.]+' | \
			grep -Eo '[0-9]\.[0-9]+')";
		if [ ! "$smart" ]; then
			diff="$(bc -s <<< $version-5.36 )"
			if [ ! "${diff:0:1}" = "-" ]; then 
			# this is a newer version which supports SATA
			# scan for SMART attributes
				scan_hdd_smart ${dev_scan} ata
			fi
		fi
		
	}


	#######################
	# SOFTWARE RAID ARRAYS
	# Parameters:
	#	(1) drive device
	#	(2) drive node in the /dev/ tree
	#	(3) the node number in the bus
	#
	scan_hdd_raid() {
		value_header	"todo"

	}

###### END OF HDD SUBFUNCTIONS #############


#######################
# MEMORY
#
# this module tells complete information of the memory
# installed on the system.
#
# only RAM at the moment and the solution is really dirty because
# it uses lshw. 'free' and '/proc/meminfo' would also report
# free RAM, but slightly incorrect number because it's the total
# ram after kernel has allocated some for system services.
#
# requires root access
Module_memory() {
	moduleName="System memory"
	module_header "${moduleName}"

	if CheckReq_lshw && CheckReq_root; then


		# TODO: add support for memory type/speed detection thru lshw
		lshw_xml

		# for some odd reason meminfo or free don't give a proper value

		meminfo="/proc/meminfo"

		#totalram="$(cat ${meminfo} | grep -i memtotal | grep -Eo [0-9]+)"
		totalram="$(grep 'id="memory' -A 20 ${lshw_xml_file} | grep size | \
			grep -Eo '[0-9]+')"

		totalram="$(echo "$totalram/1024/1024" | bc -l | grep -Eo '[0-9]+\.[0-9]{1}')"

		add_attribute	'RAM total'	'ram'
		add_values		"$totalram MB"

	fi

	module_footer
	flush_values
}


##################
# CD/DVD DEVICES
Module_cdrom() {
	local moduleName="CD/DVD drives"
	module_header "${moduleName}"

	if CheckReq_lshw && CheckReq_root; then
		lshw_xml
		cdrom_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		udev_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		TempFiles=("${TempFiles[@]}" "$cdrom_tmp" "$udev_tmp")

		# this gets the line number of the wanted node from lshw '$this'
		# and the line number of the next node '$next'
		# then what's between those lines is printed to another tmp file
		first_node="$(grep -n "node id=\"cdrom" $lshw_xml_file | \
			awk -F: {'print $1'})"

		# check whether there are cdrom drives in the system..
		if [ "$first_node"  ]; then 
		
			# TODO: detect how many drives. atm it only supports one drive.
			local ID=1

			# do a for loop here by ID

			next_node="$(grep -n 'node id' $lshw_xml_file | grep -A 1 cdrom | \
				awk -F: {'print $1'} | sed -n "2{p;q}")"
			((first_node++)) # this prevents the 'node' lines from printing
			((next_node--))

			# use a temp file to store cdrom information
			sed -n "$first_node,$next_node{p;}" ${lshw_xml_file} > ${cdrom_tmp}

			# collect information

			cdrom_model[$ID]="$(grep -i product ${cdrom_tmp} | \
							sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"

			cdrom_type[$ID]="$(grep -i descr ${cdrom_tmp} | \
							sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"

			cdrom_serial[$ID]="$(grep -i serial ${cdrom_tmp} | \
							sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"

			cdrom_node[$ID]="$(grep -i 'logicalname' ${cdrom_tmp} | \
							sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"
			
			#udevinfo -q all -n "${cdrom_node[$ID]}" > ${udev_tmp}

			#cat $cdrom_tmp
			#exit 0

			
			add_attribute	'Model'	'cdrom'
			add_values		"${cdrom_model[$ID]}"

			add_attribute	'Drive type'
			add_values		"${cdrom_type[$ID]}"

			add_attribute	'Device node'
			add_values		"${cdrom_node[$ID]}"

			add_attribute	'Serial number'
			add_values		"${cdrom_serial[$ID]}"

			# TODO
			# Configuration: first IDE channel master
			# etc


			#add_attribute	'Capabilities'
			#add_values		"$(grep -i capabilities ${cdrom_tmp})" #| \
							#sed 's/[^>]*>\([^<]*\)<[^.]*/\1/')"
			# dvd-r, dvd+r, DL, etc...
			# generally grep cd|dvd 
			# debug with debug/lshw-dvdwriter


			#value_footer

		else

			add_values		'No cdrom drives detected'

		fi

	fi

	module_footer
	flush_values
}


#######################
# DMI / OEM INFORMATION
#
# this module works as a replacement for module_oem. this is faster,
# as it doesn't scan hardware. look below for excerpt from 'man dmidecode':
#
# dmidecode  is  a  tool  for dumping a computer's DMI (some say SMBIOS) table
# contents in a human-readable format.
# This table contains a description of the system's hardware components,
# as well as other useful pieces of information  such  as  serial
# numbers and BIOS revision. Thanks to this table, you can retrieve this
# information without having to probe for the actual hardware.  While this
# is a good point in terms of report speed and safeness,  this also makes
# the presented information possibly unreliable.
Module_dmi() {
	moduleName="DMI information"
	module_header "${moduleName}"

	if CheckReq_dmidecode && CheckReq_root; then
		# allocate the temp files
		dmi_info="$(mktemp /tmp/osinfo.XXXXXX)"
		dmi_tmp="$(mktemp /tmp/osinfo.XXXXXX)"
		dmidecode > $dmi_info
		TempFiles=("${TempFiles[@]}" "$dmi_info" "$dmi_tmp")

		# the interesting handles:
		# 0x0000 'BIOS Information'
		# 0x0001 'System Information'
		# 0x0002 'Base Board Information'
		# 0x0003 'Chassis Information'

		local HANDLES="0x0000 0x0001 0x0002 0x0003"

		# following loop extracts the data under the nodes variable.

		# (1) get the line number where the 'node id=$HANDLES'
		# (2) get the line number of the next 'node id'
		# (3) everything in between those lines contains interesting data

		for myHANDLE in $HANDLES; do

			this="$(grep -n "Handle ${myHANDLE}" ${dmi_info} | \
			        awk -F: {'print $1'})"
			next="$(grep -n Handle ${dmi_info} | grep -A 1 ${myHANDLE} | \
			        awk -F: {'print $1'} | sed -n "2{p;q}")"
			((this++)) # this prevents the 'handle' lines from printing
			((next--))

			# use a temp file to store handle information
			sed -n "$this,$next{p;}" ${dmi_info} > ${dmi_tmp}


			# here the data is processed
			case $myHANDLE in

				"0x0001")	# System Information

					value_header	"System info"


					add_attribute 'Manufacturer' \
					              'system_manufacturer'
					add_values    "$(grep -i manufacturer ${dmi_tmp} | \
					                 awk -F: {'print $2'})"


					add_attribute	'Product name'	'system_model'
					add_values		"$(grep -i product ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'System version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'OEM serial number' \
									'computer_product_serial'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'UUID' 	'uuid'
					add_values		"$(grep -i uuid ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;

				"0x0002")	# Base Board Information

					value_header	"Motherboard"


					add_attribute	'Manufacturer' \
									'mother_board_manufacturer'
					add_values		"$(grep -i manufacturer ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Model' \
									'mother_board_model'
					add_values		"$(grep -i product ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Version' \
									'mother_board_version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Serial number' \
									'mother_board_serial_number'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;

				"0x0000")	# BIOS Information

					value_header	"BIOS"

					add_attribute	'Vendor'
					add_values		"$(grep -i vendor ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Revision'	'bios_version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Date'	'bios_date'
					add_values		"$(grep -i date ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Serial number'	'bios_serial_number'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;


				"0x0003")	# Chassis Information

					value_header	'Chassis'

					add_attribute	'Manufacturer' 	'chassis_manufacturer'
					add_values		"$(grep -i manufacturer ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Type' 	'chassis_type'
					add_values		"$(grep -i type ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Version' 	'chassis_version'
					add_values		"$(grep -i version ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Serial number' \
									'chassis_serial_number'
					add_values		"$(grep -i serial ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Lock' 	'chassis_lock'
					add_values		"$(grep -i lock ${dmi_tmp} | \
									awk -F: {'print $2'})"


					add_attribute	'Asset tag' 'chassis_asset_tag'
					add_values		"$(grep -i asset ${dmi_tmp} | \
									awk -F: {'print $2'})"


					value_footer
					;;

			esac

		done

	fi

	# cleanup
	rm -f $dmi_info $dmi_tmp

	module_footer
	flush_values
}


#######################
# OEM INFORMATION (rewrite)
# this module is deprecated in favor of module_dmi
#
# this module collects information from lshw, a somewhat rare package, which
# tells a lot of interesting information of the system hardware.  it also seems
# to be the only way to get the serial number of a branded computer, thus 'oem
# info'. below is an excerpt from 'man lshw'
#
# lshw  is a small tool to extract detailed information on the hardware
# configuration of the machine. It can report exact memory configuration,
# firmware version, mainboard configuration, CPU version and  speed,  cache
# configuration,  bus  speed, etc. on DMI-capable x86 or IA-64 systems and on
# some PowerPC machines (PowerMac G4 is known to work).  It currently supports
# DMI (x86 and IA-64 only), OpenFirmware device tree (PowerPC only),  PCI/AGP,
# CPUID  (x86),IDE/ATA/ATAPI, PCMCIA (only tested on x86), SCSI and USB.
Module_oem() {
	local moduleName="OEM information"
	module_header "${moduleName}"


	if CheckReq_lshw && CheckReq_root; then
		lshw_xml

		# the interesting entries:
		# $hostname
		# core
		# firmware

		local NODES="$(hostname) core firmware"

		# following loop extracts the data under the nodes variable.

		# (1) get the line number where the 'node id=$NODES'
		# (2) get the line number of the next 'node id'
		# (3) everything in between those lines contains interesting data

		for myNODE in $NODES; do

			this="$(grep -n "node id=\""${myNODE}"\"" $lshw_xml_file | \
				awk -F: {'print $1'})"
			next="$(grep -n 'node id' $lshw_xml_file | grep -A 1 ${myNODE} | \
				awk -F: {'print $1'} | sed -n "2{p;q}")"
			((this++)) # this prevents the 'node' lines from printing
			((next--))

			local IFSbk="$IFS"
			IFS="
"; # a literal newline, do not indent!

			for info in $(sed -n "$this,$next{p;}" $lshw_xml_file); do

				# the data is avaiable here, printed line by line.
				# usually the fields are:

				# <description>
				# <product>
				# <vendor>
				# <version>
				# <serial>

				# then there special fields. see 'lshw -xml'

				# parse standard <foo> tags
				# TODO: add support for capabilities tags
				local tag="$(grep -o '<[a-z]*>' <<< ${info} | \
							sed 's/<\([^>]*\)>/\1/')"
							# matched everything between '<' and '>'

				[ "$tag" ] && \
				local value="$(grep ${tag} <<< ${info} | \
							awk -F'<|>' {'print $3'})"

				# here the data is processed
				case $myNODE in

					"$(hostname)")	# OEM info

						if [ "$printed" != "oem" ]; then
							value_header	"OEM info"
							local printed="oem"
						fi

						case $tag in

							'description')

								add_attribute 'System model' \
								              'system_model'
								add_values    "$value"
								;;

							'vendor')

								add_attribute 'System manufacturer' \
								              'system_manufacturer'
								add_values    "$value"
								;;

							'product')

								add_attribute	'System name'
								add_values		"$value"
								;;

							'version')

								add_attribute	'System version'
								add_values		"$value"
								;;

							'serial')

								add_attribute 'OEM serial number' \
								              'computer_product_serial'
								add_values    "$value"
								;;

							#*)

								#add_attribute	"$tag"
								#add_values		"$value"
								#;;

						esac

						value_footer
						;;

					'core')			# mobo info

						if [ "$printed" != "mobo" ]; then
							value_header	"Motherboard"
							local printed="mobo"
						fi

						case $tag in

							'vendor')

								add_attribute 'Make'
								add_values    "$value"
								;;

							'product')

								add_attribute 'Model'
								add_values    "$value"
								;;

							'version')

								add_attribute 'Revision'
								add_values    "$value"
								;;

							'serial')
								add_attribute 'Serial number' \
								              'mother_board_serial_number'
								add_values    "$value"
								;;

						esac

						value_footer
						;;

					'firmware')		# BIOS info

						if [ "$printed" != "bios" ]; then
							value_header	"BIOS"
							local printed="bios"
						fi

						case $tag in

							'vendor')

								add_attribute	'Vendor'
								add_values		"$value"
								;;

							'version')

								add_attribute	'Revision'	'bios_version'
								add_values		"$value"

								# trying to extract date from version
								add_attribute	'Date'	'bios_date'
								add_values		"$(echo $value | \
									grep -Eo '([0-9]{2,4}[-./][0-9]{2}[-./][0-9]{2,4})+')"
								;;

							'date')

								add_attribute	'Date'	'bios_date'
								add_values		"$value"

								;;

							'serial')
								add_attribute 'Serial number' \
								              'bios_serial_number'
								add_values    "$value"
								;;

						esac

						#value_footer
						# this produces an eternal loop
						;;

				esac

			done

			IFS="$IFSbk"

		done
	fi

	module_footer
	flush_values
}


# GENERAL INFORMATION OF THE SYSTEM
Module_system() {
	moduleName="System"
	module_header "${moduleName}"

	add_attribute "Operating system"		"os"
	add_values    "$distro_id $(uname -s) $distro_release"

	add_attribute "Operating system kernel"	"os_build"
	add_values    "$(uname -sr)"

	add_attribute "Network node hostname"	"host_name"
	add_values    "$(hostname)"

	add_attribute "Machine hardware name"	"system_type"
	add_values    "$(uname -m)"

	add_attribute "System uptime"			"uptime"
	add_values    "$(uptime | awk -F, {'print $1'} | \
	                 grep -Eo 'up [a-z0-9: ]*' | sed 's/^[up ]*//')"

	module_footer
	flush_values
}


# OPERATING SYSTEM KERNEL
Module_kernel() {
	moduleName="Kernel"
	module_header "${moduleName}"

	local kernel_makefile

	add_attribute "Operating system"
	add_values    "$(uname -o)"

	add_attribute "Kernel release"
	add_values    "$(uname -r)"

	# Unique kernel name
	if [ -e "/usr/src/linux" ]; then
		kernel_makefile="/usr/src/linux/Makefile"
	elif [ "$(ls /usr/src/linux* 2> /dev/null)" ]; then
		kernel_makefile="/usr/src/linux*/Makefile"
	fi
	if [ -e "${kernel_makefile}" ]; then
		add_attribute "Kernel name"
		add_values    "$(head ${kernel_makefile} | grep NAME | \
						head -n 1 | awk -F= {'print $2'})"
	fi

	module_footer
	flush_values
}


# INFORMATION OF THE CPU
Module_processor() {
	moduleName="Processor"
	module_header "${moduleName}"

	local cpunr

	# AnMaster: Why this line? Would it ever be anything else?
	local cpuinfo="/proc/cpuinfo"
	local cpu_count="$(grep 'cpu cores' ${cpuinfo} | head -n 1 | awk {'print $NF'})"

	# test if /proc/cpuinfo gives a number for cpu cores.
	# if it is does not, the kernel probebly lacks SMP support so assume 1 cpu.
	if [ ! "$cpu_count" ]; then
		cpu_count=1
	fi

	add_attribute	"Count"			"processor_count"
	add_values		$cpu_count

	for cpunr in $(seq 1 1 $cpu_count); do

		if [ $cpu_count -gt 1 ]; then
			value_header	"Processor $cpunr"
		fi

		add_attribute	"Vendor"		"processor_vendor"
		add_values		"$(grep 'vendor' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2'})"

		add_attribute	"Model"			"processor_model"
		add_values		"$(grep 'model name' ${cpuinfo} | \
						sed -n "$cpunr{p;q}" | awk -F': ' {'print $2'})"

		add_attribute	"Frequency"		"processor_speed"
		add_values		"$(grep 'cpu MHz' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2" MHz"'})"

		add_attribute	"Cache"
		add_values		"$(grep 'cache' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2'})"

		add_attribute	"Stepping"
		add_values		"$(grep 'stepping' ${cpuinfo} | sed -n "$cpunr{p;q}" | \
						awk -F': ' {'print $2'})"


	done

	module_footer
	flush_values
}


# INFORMATION OF THE TERMINAL IN USE
Module_terminal() {
	moduleName="Terminal info"
	module_header "${moduleName}"

	add_attribute	"Terminal type"
	add_values		"$TERM"

	add_attribute	"Terminal speed"
	add_values		"$(stty speed)"

	add_attribute	"Rows"
	add_values		"$(stty size | awk '{print $1}')"

	add_attribute	"Columns"
	add_values		"$(stty size | awk '{print $2}')"

	module_footer
	flush_values
}


#######################
# PRINTERS AVAILABLE TO THE SYSTEM

# EXPERIMENTAL!

# uses only lpstat (cups) and hasn't been tested on multi-printer
# environments
Module_printers() {
	moduleName="Printers"
	module_header "${moduleName}"

	local lp_nr

	# first of all, check if lpstat is available
	if [ "$(type -p lpstat)" ]; then

		#	if [ "$(lpstat -a 2&>1 | grep -Eo refused)" != "refused" ]; then

		add_attribute		'Printer'	'local_printer'

		# as there may be several printers, print info from all
		for lp_nr in $(seq 1 1 $(lpstat -a | wc -l) ); do

			add_values	"$(lpstat -a 2> /dev/null | sed -n "$lp_nr{p;q;}")"

		done

	fi


	module_footer
	flush_values
}


#######################
# USERS
#
# reports the current user, the user's X11 session manager + shell
# the last logged user, and other users that have logged in
# (that last can see).
Module_users() {
	moduleName="Users"
	module_header "${moduleName}"

	value_header	'Current user'
	add_attribute	"Unix name"				'active_user'
	add_values		"$(whoami)"


	add_attribute	'Real name'				"real_name"
	add_values		"$(grep $(whoami) /etc/passwd | awk -F: {'print $5'})"


	add_attribute	"User's X11 session"	"users_window_manager"
	# KDE sometimes sets $DESKTOP_SESSION nicely, Gnome doesn't.
	# AnMaster: KDE doesn't set that for me (in konsole at least)
	# ruxpin: I get this in konsole: DESKTOP_SESSION="kde-7.0"
	# any ideas where else to look?

	local session_id="$DESKTOP_SESSION"
	if [ "$session_id" == "default" ]; then
		if [ "$GNOME_DESKTOP_SESSION_ID" ]; then
			# try to get Gnome version
			local gnome_version="$(gnome-about --version | awk {'print $NF'})"
			session_id="Gnome $gnome_version"
		fi
	fi
	add_values		"$session_id"


	add_attribute	"User's shell"
	add_values		"$SHELL"


	add_attribute	"User's locale"
	add_values		"$LC_ALL"


	value_footer
	value_header	'Last logged in user'
	[ $usexml = 1 ] &&	add_attribute	'Last login' "last_logged_user"
	add_values		"$(last -1 | head -n 1 | awk {'print $1'})"
	value_footer

	value_header	'\nAll users\t\tlast login'
	[ $usexml = 1 ] &&	add_attribute	'All users' "users"
	# because 'last' command, part of sysvinit core package,
	# interprets the binary file /var/log/wtmp, but chomps off
	# the loginname at 9 characters, we need to find the full names
	# from the source file. a dirty hack...

	local users="$(last | awk {'print $1'} | sort | uniq | \
	               grep -v 'reboot\|wtmp' | grep '^[a-zA-Z]')"
	               # removes users 'reboot' and 'wtmp'
	local user
	local wtmp_file="/var/log/wtmp"
	for user in $users; do

		if [ ${#user} -ge 8 ]; then
			# parse special chars to meta-chars
			user="$(sed 's/[[:punct:]]/\\&/g' <<< $user)"
			add_values	"$(grep -Eoa "$user[a-zA-Z0-9\\\+]*" ${wtmp_file} | uniq)\n"
		else
			add_values	"$user\n"
		fi
	done

	module_footer
	flush_values
}


###########################
# SYSTEM SERVICES (daemons)

# http://linuxhelp.blogspot.com/2006/04/enabling-and-disabling-services-during_01.html

# Gentoo: 
#	rc-status

# Fedora & RedHat, Suse:
#	/sbin/service --status-all
#	chkconfig --list

# Ubuntu/Debian:
#	sysv-init
#	'runlevel' gives to values: "previous current", grep on the current

# Slackware:
#	not scripted?
Module_services() {

	moduleName="Services"
	module_header "${moduleName}"

		# these functions handle scanning, they'll echo output
		if [ "$(type -p rc-status)" ]; then
			# Gentoo
			local services="$(scan_services_rc-status)"

		elif [ "$(type -p sysv-rc-conf)" ]; then
			# Debian and Ubuntu, if they've got the package
			local services="$(scan_services_sysv)"
			
		elif [ "$(type -p chkconfig)" ]; then
			# Red Hat, Fedora Core, SuSE
			local services="$(scan_services_chkconfig)"
		fi


		# attribute only for xml
		if [ $usexml = 1 ]; then
			add_attribute	'Services'	'service'
		fi


		# then report what scan found
		for srv in $services; do
			add_values	"$srv\n"
		done


	module_footer
	flush_values
}

#################################
### SERVICE MODULE SUBFUNCTIONS
# 

	# this script is used on gentoo
	scan_services_rc-status() {
	
		echo $(rc-status | awk '/started/{print $1}' | sort)

	}

	# this works on debian-based systems, probably on many others as well
	scan_services_sysv() {

		local runlevel=$(runlevel | awk {'print $2'})

		echo $(sysv-rc-conf --list 2> /dev/null | awk '/'$runlevel'\:on/{print $1}' | sort)

	}

	scan_services_chkconfig() {

		# similar to sysv-rc-conf
		# works on rpm-based systems
	
		local runlevel=$(runlevel | awk {'print $2'})

		echo $(chkconfig --list 2> /dev/null | awk '/'$runlevel'\:on/{print $1}' | sort)

	}

#################################


##########
# NETWORK
#
# this module detects the network settings of the computer.
#
# there are at least two methods to pull in information; ifconfig and iproute2.
# ifconfig is used; there are at least two versions of ifconfig being used, and
# all tested Linuxes have used the same, whereas FreeBSD v6 had different
# output. the script should work on both versions.
#
# some changes have been made after testing with FreeBSD, so compitibility
# may not be 100% anymore.
#
# WIRELESS SUPPORT IS EXPERIMENTAL
Module_network() {
	moduleName="Network information"
	module_header	"${moduleName}"

	local specials="UP|BROADCAST|LOOPBACK|NOARP|NOTRAILERS|RUNNING|MULTICAST"
	# what are these needed for?

	# allocate the temp file
	local nw_info="$(mktemp /tmp/osinfo.XXXXXX)"
	TempFiles=("${TempFiles[@]}" "$nw_info")

	################################
	# DETECT (WIRED) NETWORK DEVICES
	# using ifconfig
	#
	# detect the type of OS (and ifconfig available); there may other
	# versions, but these two OSes were tested. all ifconfigs in Linux operate
	# more of less similarity, but the one on FreeBSD is different.
	if [ "$(type -p ifconfig)" ]; then
		nw_src="ifconfig"

		if [ "$SYSTEM" == "linux" ] ; then
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST -B 3 | \
			grep -Ev '(^ )|(^--)|LOOPBACK' | awk  {'print $1'})"

		else # *BSD ifconfig
			ETH_DEVICES="$(ifconfig -a | grep BROADCAST | grep -v LOOPBACK | \
			awk -F': ' {'print $1'})"
		fi
	fi


	# collect the information from detected network devices
	for interface_name in $ETH_DEVICES; do
		ifconfig $interface_name > ${nw_info}

		value_header	$interface_name

		add_attribute 'MAC'		"mac_address"
		add_values    "$(grep -Eo '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}' ${nw_info})"

		# TODO: IP type (static or dynamic)
		#add_attribute	'IP type'	"ip_type"

		add_attribute 'IPv4'		"ip_address"
		add_values    "$(grep -Eio 'inet[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' ${nw_info} | \
		                 grep -Eo '[0-9\.]+' )"

		add_attribute 'IPv6'
		add_values    "$(sed "s/  /\n/g" ${nw_info} | grep -i inet6 | \
		                 grep -Eio '([0-9a-f]{3,4}(\:){1,2}){4,8}([0-9a-f]{3,4})' )"

		add_attribute 'NIS domain'
		add_values    "$(hostname -y 2> /dev/null)"
		# hostname produces stderr if no network is available

		add_attribute  'DNS domain'	'domain'
		add_values    "$(hostname -d 2> /dev/null)"

		add_attribute 'FQDN'		"fully_qualified_domain_name"
		add_values    "$(hostname -f 2> /dev/null)"

		add_attribute 'Gateway'	"default_gateway"
		add_values    "$(route -n | awk '/^0.0.0.0/{print $2}')"

		add_attribute 'Broadcast'
		add_values    "$(sed "s/  /\n/g" ${nw_info} | \
		                 grep -Eio 'cast[A-Za-z: ]*([0-9]{1,3}\.){3}[0-9]{1,3}' | \
		                 grep -Eo '[0-9\.]+' )"

		add_attribute 'Netmask'	"subnet_mask"
		add_values    "$(sed "s/  /\n/g" ${nw_info} | \
		                 grep -Eio 'mask[A-Za-z: ]*((([0-9]{1,3}\.){3}[0-9]{1,3})|(0x[0-f]{8}))' | \
		                 grep -Eo '[0-9\.fx]+' )"

		add_attribute 'RX bytes'
		add_values    "$(sed "s/  /\n/g" ${nw_info} | \
		                 grep -i 'RX bytes' | awk -F: {'print $2'})"

		add_attribute 'TX bytes'
		add_values    "$(sed "s/  /\n/g" ${nw_info} | \
		                 grep -i 'TX bytes' | awk -F: {'print $2'})"

		value_footer

	done


	###################################################
	# DETECT WIRELESS NETWORK DEVICES AND ACCESS POINTS
	# with iwconfig, Linux only
	#
	# under developement, does not yet work!

	# FIXME: This odd debug usage sucks... Better add a --debug if you realy need this.
	# note: for debugging, these variables are set here
	if [ "$isdebug" == 1 ]; then
		iw_src="debug/wlan-iwconfig-on"
		WLAN_DEVICES="eth1"
		ap_src="debug/wlan-stations"

		if [ "$(type -p iwconfig)" ]; then

			iw_src="iwconfig"

			# not tested yet
			if [ "$SYSTEM" == "linux" ] ; then

			# FIXME: on my system w/ wireless-tools,
			# but no wlan network (no working drivers)
			#  iwconfig -a
			#  -a        No such device

				ETH_DEVICES="$(iwconfig -a | grep BROADCAST -B 3 | \
				grep -Ev '(^ )|(^--)|LOOPBACK' | \
				awk  {'print $1'})"
			fi

		fi

		# info from access points (AP)
		if [ "$(type -p iwlist)" ]; then
			# tweak this a bit
			ap_src="iwlist $WLAN_DEVICES scan"
		fi

		value_header  'wlan'

		add_attribute "associated ESSID"
		add_values    "$(grep -Eo 'ESSID[:"A-Za-z/ ]*' "${iw_src}" | \
		                 awk -F: {'print $2'})"

		value_footer
	fi



	# cleanup
	rm -f ${nw_info}

	module_footer
	flush_values
}


##
# Gets data from lsb_release
# Parameters:
#  1  string   what value to get.
distro_lsb_release() {
	lsb_release -a 2> /dev/null | grep -i "^$1" | awk -F: '{print $2}' | sed -s 's/^\t*//'
}

#######################
# DISTRIBUTION
#
# this module will try to guess which Linux distrobution is installed.
# the default tool to use is the lsb-release (Linux Standard Base
# version reporting utility)
#
# a secondary id source are the unique files in /etc/, and as a last
# resort the /etc/issue file. this makes it possible to identify
# a distro which resides in a chroot environment, or from a livecd.
Module_distro() {
	moduleName="Distribution"
	module_header "${moduleName}"

	# NOTE: do not make distro_* variables local, as they might be used
	# in other modules

	# locate and echo the root directory.
	# TODO: Some of this isn't actually needed as we allready fixed so there is at most one endning / (can be zero ending / too).
	[ "$prefix" != '/' ] && \
		local root_dir="$(echo $prefix | sed 's/\/*$//')" || \
		local root_dir="$prefix"
	add_attribute		'Root dir'
	add_values			"$root_dir"
	[ "$root_dir" != '/' ] && root_dir="${root_dir}/"


	# look for lsb-release if real root is used.
	if [ "$(type -p lsb_release)" ] && [ "$prefix" == '/' ]; then

		distro_id="$(distro_lsb_release 'distributor')"
		distro_release="$(distro_lsb_release 'release')"
		distro_codename="$(distro_lsb_release 'codename')"
		distro_description="$(distro_lsb_release 'description')"

	else

		# Begin searching for distro identifying files
		local found_files="" myfile
		for myfile in ${root_dir}etc/{SuSE-release,fedora-release,redhat-release,slackware-version,Topologilinux-version,gentoo-release,issue}; do
			[ -e $myfile ] && found_files="$found_files $myfile"
		done

		# Now make a list of distros from the $found_files list above
		local found_distros="" distro_ident
		for distro_ident in $found_files; do
			case $distro_ident in
				"${root_dir}etc/SuSE-release")
					found_distros="$found_distros SuSE"
					break;
					;;
				"${root_dir}etc/fedora-release")
					found_distros="$found_distros Fedora Core"
					break;
					;;
				"${root_dir}etc/redhat-release")
					found_distros="$found_distros Red Hat"
					break;
					;;
				"${root_dir}etc/slackware-version")
					found_distros="$found_distros Slackware"
					break;
					;;
				"${root_dir}etc/Topologilinux-version")
					found_distros="$found_distros Topologilinux"
					break;
					;;
				"${root_dir}etc/gentoo-release")
					found_distros="$found_distros Gentoo"
					break;
					;;
				# if nothing previous matches, then use /etc/issue
				# AnMaster: Inform user that this might be very wrong...
				"${root_dir}etc/issue")
					found_distros="$found_distros misc"
					break;
					;;
			esac
		done
		# Remove leading spaces.
		found_distros="$(sed 's/^ *//' <<< "${found_distros}")"


		# Get distro name
		# NOTE: have been changed to case-insensitive, although
		# has not been thoroughly tested. the commented code
		# may be removed after verifying the new code works.
		case "$(echo ${found_distros} | tr 'A-Z' 'a-z')" in
			'suse'|'fedora core'|'fedora'|'red hat'|'slackware'|'slackware topologilinux'|'gentoo'|'ubuntu')
			#'SuSE'|'Fedora Core'|'Fedora'|'Red Hat'|'Slackware'|'Slackware Topologilinux'|'Gentoo'|'Ubuntu')

				distro_id="${found_distros}"

				# clear spaces
				#[ "$found_distros" = 'Slackware Topologilinux' ] && \
				#	found_distros='Topologilinux'
				#[ "$found_distros" = 'Red Hat' ] && found_distros='RedHat'
				#[ "$found_distros" = 'Fedora Core' ] && found_distros='Fedora'
				;;

			'topologilinux')
				print_error 1 "This module will abort." "$usekdialog" \
					"Topologilinux is based on Slackware and should" \
					"contain ${root_dir}etc/slackware-version AND " \
					"${root_dir}etc/Topologilinux-version."
				return 1
				;;

			'misc')
				for misc_distro in 'Ubuntu' 'Fedora' 'SuSE'; do
					if [ "$(grep -i ${misc_distro} ${distro_ident})" ]; then

						distro_id="${misc_distro}"
					fi
				done
				;;

			'')
				# Abort if no distro found
				print_error 1 "This module will abort." "$usekdialog" \
					"You have zero distros installed or use a distro " \
					"not recognised by ${appname}"
				return 1
				;;

			#*)
				# Abort if more than one distro
				#if [ "$usekdialog" == "1" ]; then
					#kdialog --error  "You have several distros installed at the \
					#same time.\nInstalled distros:\n${found_distros}\n\
					#This module will abort."
				#else
					#echo "${tcRED}ERROR:${tSTD} You have several distros \
						#installed at the same time."
					#echo "${tcRED}ERROR:${tSTD} ${tBOLD}Installed distros:${tSTD}\
						#${found_distros}"
					#echo "${tcRED}This module will abort.${tSTD}"
				#fi
				#return 1
			#;;
			esac


		# Output distro version
		case "${found_distros}" in
			'SuSE')
				distro_release="$(grep -F 'VERSION = ' ${root_dir}etc/SuSE-release          | sed 's/VERSION = //'    )" ;;
			'Red Hat')
				distro_release="$(cat ${root_dir}etc/redhat-release)" ;;
			'Fedora')
				distro_release="$(cat ${root_dir}etc/fedora-release)" ;;
			'Slackware')
				distro_release="$(grep -F 'Slackware ' ${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
			'Topologilinux')
				distro_release="$(grep -F 'Topologilinux ' ${root_dir}etc/Topologilinux-version | sed 's/Topologilinux //')"
				local  SlackwareBase="$(grep -F 'Slackware  '${root_dir}etc/slackware-version     | sed 's/Slackware //'    )" ;;
			'Gentoo')
				# AnMaster: Not sure if readlink is POSIX but it exists on Gentoo and we allready know this is Gentoo.
				distro_release="$(readlink /etc/make.profile | grep -Eo '[0-9]{4}\.[0-9]')";;
			'misc')
				# FIXME: AnMaster: . is a wildcard meaning any single char. Isn't grep -F what you want?
				distro_release="$(grep '.' "${root_dir}etc/issue" | grep -Eo '([A-Za-z0-9 ."])+' | head -n 1 )";;
				# TODO: improve the grep
		esac

	fi


	# then output what we found..

	[ "${distro_id}" ] && \
		add_attribute	'Distro ID'
		add_values		"${distro_id}"

	[ "${distro_release}" ] && \
		add_attribute	'Release'
		add_values		"$distro_release"

	[ "${distro_codename}" ] && \
		add_attribute	'Codename'
		add_values		"$distro_codename"

	[ "${distro_description}" ] && \
		add_attribute	'Description'
		add_values		"$distro_description"

	[ "$SlackwareBase" ] && \
		add_values	'Based on Slackware version' \
					"$SlackwareBase"


	module_footer
	flush_values
}


#######################
# APPLICATIONS
#
# version information of standard *nix, dev, and dependency packages.
# probably should take an additional switch like --X, --server, etc.
Module_applications() {
	moduleName="Applications"
	module_header "${moduleName}"

	local APPLICATIONS app
	## Applications to look for..
	if [ "$SYSTEM" == "linux" ] ; then

		APPLICATIONS="X kde-config gnome-about x11vnc \
			bash csh ls \
			gcc make \
			awk sed grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			udevinfo lspci lshw dmidecode smartctl hdparm"

	elif [ "$(grep -i bsd <<< "$SYSTEM")" ]; then

		APPLICATIONS="X kde-config x11vnc \
			csh bash ksh \
			gcc grep gzip \
			perl python \
			apache2 php mysql smbd cups-config \
			lspci lshw smartctl hdparm"

	fi

	## Write the header for output
	if [ $usexml = 1 ]; then
		add_attribute "Applications" 'software'
	fi

	local missing_ERRMSG="if you want to be able to use all modules of ${appname}"
	## Process all applications
	for app in ${APPLICATIONS}; do

		if [ "$(type -p $app)" ]; then # it is installed
			case "$app" in
				'perl')
					add_values 	"Perl $($app --version 2>&1 | grep 'perl, v' | \
								grep -Eo 'v[ A-Za-z0-9.-]*')\n"
					;;
				'python')
					add_values	"$($app -V 2>&1 | head -n 1 )\n"
					;;
				'X')
					add_values	"$($app -version 2>&1 | grep Revision)\n"
					;;
				'kde-config')
					add_values	"$($app -version 2>&1 | grep KDE)\n"
					;;
				'gnome-about')
					add_values	"$($app --version 2>&1 )\n"
					;;
				'apache2'|'apache')
					add_values	"$($app -V | head -n 1 | awk -F': ' {'print $2'})\n"
					;;
				'cups-config')
					add_values	"Cups $($app --version 2>&1 )\n"
					;;
				'smbd')
					add_values	"Samba $($app -V 2>&1 )\n"
					;;
				'udevinfo')
					add_values	"$($app -V 2>&1 )\n"
					;;
				'awk')
					add_values	"$($app -W version 2>&1 | head -n 1 )\n"
					;;
				'dmidecode')
					add_values	"dmidecode $(dmidecode -V 2> /dev/null )\n"
					;;
				*)
						add_values	"$($app --version 2>&1 | grep '\w' | head -n 1)\n"
					;;
										#grep  -P '[0-9]+\.[0-9]+' | sed 's/^tune2fs //')"
			esac
		else
			case "$app" in
				'lspci')
					add_values 'lspci'      "please install pciutils ${missing_ERRMSG}\n"
					;;
				'lshw')
					add_values 'lshw'       "please install lshw ${missing_ERRMSG}\n"
					;;
				'smartctl')
					add_values 'smartctl'   "please install smartmontools ${missing_ERRMSG}\n"
					;;
				'dmidecode')
					add_values 'demidecode' "please install dmidecode ${missing_ERRMSG}\n"
					;;
			esac
		fi
	done
	module_footer
	flush_values
}


#######################
# hardware devices of the system
#
# this function parses the physical devices in the computer from lspci.
# depends on pciutils.
#
# the output verbosity can be increased to include devices in the
# DO_NOT_OUTPUT string to include standard motherboard controllers
# which are suppressed in the normal level of verbosity.
Module_devices() {
	moduleName="Devices"
	module_header "${moduleName}"
	local DEVICE
	local DEV_ARRAY=1;
	for DEVICE in $(lspci | awk {'$1="\b" ; print $0'} | tr ' ' '_' ); do

		devices[$DEV_ARRAY]="$(

			echo $DEVICE | sed -r 's/:_/:/g;s/(^_)//g' | tr ':' ' ' )"

			# with lspci 2.2 and later, the -m switch works fine
			#	for DEVICE in $(lspci -m | tr ' ' '_'); do
			#		devices_dbg[$DEV_ARRAY]="$(	echo $DEVICE | grep -Eo '"[^"]+"' | awk -F\" {'print $2'} )";

		((DEV_ARRAY++))
	done

	# the devices array now contains the ' ' separated entries from lsmod.
	# [1] device type		# [2] manufacturer		# [3] device name	etc
	# ${#devices[@]} # is the number of devices in the array

	# by default output all, but
	DO_NOT_OUTPUT="pci\|usb\|smb\|bridge\|ide"

	[[ "$isverbose" -eq 1 ]] && \
		DO_NOT_OUTPUT="smb\|bridge"


	for DEV_ARRAY in $(seq 1 1 ${#devices[@]}); do
		#if [ ! "$(echo ${devices[$DEV_ARRAY]} | awk {'print $1'} | \
		#	grep -i $DO_NOT_OUTPUT)" ]; then
		if [ -z "$(grep -i $DO_NOT_OUTPUT <<< ${devices[$DEV_ARRAY]})" ]; then


			# make an exception for display and ethernet adapters
			# so they can be tagged properly in the xml output.

			# make sure that if several adapters are found, they are
			# printed as <value>s under the same <attribute> tag

			# AnMaster: Could you please tell me what you (ruxpin) mean with this?
			#           As there is nothing about network in lspci...
			#           And Display adapter(s) seems broken.
			#               01:00.0 VGA compatible controller: ATI Technologies Inc RV280 [Radeon 9200 PRO] (rev 01)
			#               01:00.1 Display controller: ATI Technologies Inc RV280 [Radeon 9200 PRO] (Secondary) (rev 01)
			#           And there is only one in osinfo. In osinfo --xml there is one normal and one empty for it.
			#               <value>ATI Technologies Inc RV280 [Radeon 9200 PRO] (rev 01) </value>
			#               <value></value>
			#           Same in the lanforce output.

			# ruxpin: I already though of fixing it, because I got two network cards
			# to output. I can't debug that right now.

			local description="$(awk  '{ print $1 }' <<< ${devices[$DEV_ARRAY]} | \
			                     tr '_' ' ' | sed 's/^.//;s/^ *//')"
			local device="$(awk  '{ print $2" "$3 }' <<< ${devices[$DEV_ARRAY]} | \
								tr '_' ' ')"


			if [ "$(grep -i 'network\|ethernet' <<< "$description")" ]; then

				# these values should not be local,
				# older bash fails there
				eth_adapter[${#eth_adapter[@]}]="$device"

			elif [ "$(grep -i 'vga\|display' <<< "$description")" ]; then

				video_adapter[${#video_adapter[@]}]="$device"

			else

				add_attribute "$description"
				add_values    "$device"

			fi

		fi
	done


	#then report the eth and video adapters
	if [ "$eth_adapter" ]; then
		add_attribute	'Ethernet controller(s)'	"network_adapter"
		for i in $(seq 0 1 $((${#eth_adapter[@]}-1)) ); do
			add_values		"${eth_adapter[$i]}\n"
		done
	fi


	if [ "$video_adapter" ]; then
		add_attribute	'Display adapter(s)'		"display_adapter"
		for i in $(seq 0 1 $((${#video_adapter[@]}-1)) ); do
			add_values		"${video_adapter[$i]}\n"
		done
	fi

	#12:04 < LinuxNIT> is there a way to check and see how much ram my video card actually has available/is using? not just what i set in the xorg.conf
	#12:04 < Kevin`> lspci -vv
	#12:06 < LinuxNIT> IRegion 0: Memory at e8000000 (32-bit, prefetchable) [size=128M]

	module_footer
	flush_values
}


#######################
# ENVIRONMENT VARIABLES
#
# xml only, stdout is not needed
Module_env() {
	moduleName="Environment variables"
	module_header "${moduleName}"

	## Write the header for output
	add_attribute   'System enviroment variables\n' \
	                'system_enviroment_variables'
	## Process all variables
	for var in $(env); do

		add_values	"${var}\n"

	done

	module_footer
	flush_values
}

